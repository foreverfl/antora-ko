= 심볼릭 링크

Antora는 파일이 표준 계층 구조를 준수해야 하지만 심볼릭 링크를 사용하여 기존 위치의 파일을 이 계층 구조로 재매핑할 수 있습니다. 이 페이지에서는 심볼릭 링크를 소개하고 Antora에서 콘텐츠 계층 구조를 구성하는 데 어떻게 사용할 수 있는지 설명합니다.

== 심볼릭 링크란?

**심볼릭 링크(symlink)**는 자체적으로 파일처럼 작동하는 파일에 대한 바로 가기입니다. 즉, 다른 파일을 가리키는 파일입니다. 심볼릭 링크의 목적은 파일을 복제하지 않고도 파일에 두 번째 위치를 제공하는 것입니다. 심볼릭 링크는 디렉터리를 가리킬 수도 있습니다. 이는 해당 디렉터리 아래의 모든 파일을 새 위치에 효과적으로 연결합니다. 또한 심볼릭 링크는 다른 심볼릭 링크를 가리킬 수도 있어 파일이나 디렉터리에 더 많은 위치를 부여할 수 있습니다.

심볼릭 링크는 약간의 추가 메타데이터가 있는 일반 파일이나 디렉터리처럼 작동합니다. Antora와 같이 심볼릭 링크를 만나는 애플리케이션은 다른 파일이나 디렉터리와 동일하게 처리합니다. 이 속성은 심볼릭 링크를 예제 및 부분과 같은 파일을 Antora 계층 구조로 재매핑하는 데 이상적인 도구로 만듭니다. 이에 대해 알아보기 전에 심볼릭 링크가 지원되는 위치와 생성 방법을 살펴보겠습니다.

== 심볼릭 링크는 어디에서 지원되나요?

심볼릭 링크는 한때 Unix 및 Unix 계열(*nix) 운영 체제에서만 일반적이었지만 현대 컴퓨팅에서는 심볼릭 링크에 대한 지원이 보편적입니다. 심볼릭 링크는 로컬 파일 시스템과 git 리포지토리에서 사용할 수 있으며 둘 사이에서 투명하게 변환됩니다.

궁금해하실 수도 있겠지만 심볼릭 링크는 Windows에서도 작동합니다. Windows 10부터 심볼릭 링크(모방이 아님)가 Windows에서 완전히 지원됩니다. 이 기능의 데뷔에 대해 알아보려면 Windows 10의 심볼릭 링크를 참조하세요.

NOTE: git의 심볼릭 링크는 실제로 OS용 파일 시스템의 심볼릭 링크와 다릅니다. git에서 심볼릭 링크는 리포지토리의 상대 경로에 대한 참조를 저장하는 데이터 파일(특수 파일 모드 포함)입니다. 심볼릭 링크가 포함된 브랜치를 작업 트리(예: git clone 또는 git checkout)로 체크아웃하면 해당 참조가 로컬 파일 시스템의 심볼릭 링크로 변환됩니다. 그러나 그렇게 되지 않더라도(core.symlinks가 활성화되지 않음) 심볼릭 링크는 경로 참조를 포함하는 일반 파일로 생성됩니다(git 리포지토리에서와 같이).

== 심볼릭 링크는 어떻게 만드나요?

심볼릭 링크는 파일, 디렉터리 또는 다른 심볼릭 링크를 가리킬 수 있습니다.

심볼릭 링크를 만들 때는 항상 상대 경로로 관계를 표현해야 합니다. 절대 경로를 사용하면 심볼릭 링크가 로컬 파일 시스템의 레이아웃에 바인딩되고 git으로 변환되지 않습니다.

심볼릭 링크를 만드는 데 사용하는 명령은 Unix 계열 운영 체제를 사용하는지 아니면 Windows를 사용하는지에 따라 다릅니다. 그러나 생성되는 결과는 동일합니다.

=== *nix

Unix 계열 운영 체제(일명 *nix)에서 심볼릭 링크를 만들려면 -s 플래그와 함께 ln 명령을 사용합니다. 다음은 형제 파일에 대한 심볼릭 링크를 만드는 방법의 예입니다:

[source,console]
----
$ ln -s target.adoc link.adoc
----

이 시나리오에서 link.adoc은 파일 target.adoc을 가리키는(즉, 가리키는) 심볼릭 링크입니다.

이는 디렉터리(즉, 폴더)에도 작동합니다:

[source,console]
----
$ ln -s target link
----

이 시나리오에서 link는 디렉터리 target을 가리키는(즉, 가리키는) 심볼릭 링크입니다. 심볼릭 링크는 디렉터리처럼 작동합니다.

더 자주, 현재 디렉터리 외부의 위치에 매핑하고 싶을 것입니다. 즉, 심볼릭 링크 대상의 경로에 하나 이상의 디렉터리 세그먼트를 포함해야 합니다.

디렉터리의 파일에 대한 심볼릭 링크를 만들려면 먼저 심볼릭 링크를 만들 디렉터리로 이동하세요. 그런 다음 해당 디렉터리에서 상대 경로로 대상을 지정하세요. 이것은 거꾸로 보일 것이지만 link에서 시작하여 target을 가리키는 포인터를 생성합니다.

[source]
----
$ ln -s ../../path/to/target.adoc link.adoc
----

이 시나리오에서 __link.adoc__은 심볼릭 링크를 포함하는 디렉터리를 기준으로 파일 __../../path/to/target.adoc__을 가리키는(즉, 가리키는) 심볼릭 링크입니다. 대상은 부모 디렉터리 대신 중첩 디렉터리에 있을 수 있습니다.

디렉터리에 대해서도 동일한 작업을 수행할 수 있습니다:

[source]
----
$ ln -s ../../path/to/target link
----

이 시나리오에서 link는 심볼릭 링크를 포함하는 디렉터리를 기준으로 디렉터리 __../../path/to/target__을 가리키는(즉, 가리키는) 심볼릭 링크입니다. 심볼릭 링크는 디렉터리처럼 작동합니다.

=== Windows

Windows에서 심볼릭 링크를 만들려면 mklink 명령을 사용합니다. 이 명령은 파일 또는 디렉터리에 대한 심볼릭 링크를 만드는 데 사용할 수 있습니다. (심볼릭 링크 사용이 하드 링크 또는 디렉터리 접합부보다 선호됩니다).

파일에 대한 심볼릭 링크를 만들기 위한 구문은 다음과 같습니다:

[source,console]
----
mklink <link> <target>
----

디렉터리에 대한 심볼릭 링크를 만들기 위한 구문은 다음과 같습니다:

[source,console]
----
mklink /d <link> <target>
----

NOTE: Windows에서는 *nix ln 명령과 비교할 때 링크와 대상의 순서가 반대입니다.

다음은 mklink를 사용하여 형제 파일에 대한 심볼릭 링크를 만드는 방법의 예입니다:

[source,console]
----
$ mklink link.adoc target.adoc
----

이 시나리오에서 __link.adoc__은 파일 __target.adoc__을 가리키는(즉, 가리키는) 심볼릭 링크입니다.

이제 형제 폴더에 대한 심볼릭 링크를 만들어 보겠습니다.

[source]
----
mklink /d link target
----

이 시나리오에서 __link__는 디렉터리 __target__을 가리키는(즉, 가리키는) 심볼릭 링크입니다. 심볼릭 링크는 디렉터리처럼 작동합니다.

더 자주, 현재 디렉터리 외부의 위치에 링크하고 싶을 것입니다. 즉, 심볼릭 링크 대상의 경로에 하나 이상의 디렉터리 경로 구성 요소를 포함해야 합니다.

디렉터리의 파일에 대한 심볼릭 링크를 만들려면 먼저 심볼릭 링크를 만들 디렉터리로 이동하세요. 그런 다음 해당 디렉터리에서 상대 경로로 대상을 지정하세요. 이렇게 하면 link에서 시작하여 target을 가리키는 포인터가 생성됩니다.

[source]
----
$ mklink link.adoc ..\..\path\to\target.adoc
----

이 시나리오에서 __link.adoc__은 심볼릭 링크를 포함하는 디렉터리를 기준으로 파일 __..\..\path\to\target.adoc__을 가리키는(즉, 가리키는) 심볼릭 링크입니다. 대상은 부모 디렉터리 대신 중첩 디렉터리에 있을 수 있습니다.

디렉터리에 대해서도 동일한 작업을 수행할 수 있습니다:

[source]
----
$ mklink /d link ..\..\path\to\target
----

이 시나리오에서 __link__는 심볼릭 링크를 포함하는 디렉터리를 기준으로 디렉터리 __..\..\path\to\target__을 가리키는(즉, 가리키는) 심볼릭 링크입니다. 심볼릭 링크는 디렉터리처럼 작동합니다.

== Antora의 심볼릭 링크

Antora는 심볼릭 링크를 완전히 지원합니다. 즉, 작업 트리에서 심볼릭 링크를 사용할 수 있고 git 트리에서 심볼릭 링크를 사용할 수 있습니다. (맞습니다. git도 심볼릭 링크를 지원합니다).

=== 어떻게 작동하나요?

Antora가 파일에 대한 심볼릭 링크를 만나면 심볼릭 링크로 유지하려고 시도하지 않습니다. 오히려 만나는 다른 파일에 대해 하는 것처럼 일반 가상 파일을 만듭니다. Antora의 가상 파일 시스템 내에서 파일이 복제된다고 말할 수 있지만 심볼릭 링크의 일부만 Antora 계층 구조에 있는 경우 유일한 인스턴스가 될 수 있습니다.

Antora가 디렉터리에 대한 심볼릭 링크를 만나면 대상 디렉터리 아래의 모든 파일을 읽고 각 파일에 대해 일반 가상 파일을 만듭니다. 이 경우 Antora는 심볼릭 링크의 경로를 유지한 다음 해당 지점에서 파일 경로를 추가합니다. Antora가 관심을 갖는 한, 심볼릭 링크가 실제 디렉터리인 것처럼 파일은 심볼릭 링크로 표시되는 디렉터리 내부에 있습니다. Antora의 가상 파일 시스템 내에서 해당 디렉터리 아래의 모든 파일이 복제된다고 말할 수 있지만 대상 디렉터리가 Antora 계층 구조의 일부가 아닌 경우 해당 파일의 유일한 인스턴스가 될 수 있습니다.

여기서 주목할 점은 심볼릭 링크를 사용하여 파일이나 디렉터리가 실제로 있는 위치와 다른 위치에 있다고 Antora를 속일 수 있다는 것입니다. 파일에 대한 심볼릭 링크인 경우 Antora는 파일을 복사한 것처럼 처리하지만 실제로는 복사하지 않았습니다. 디렉터리에 대한 심볼릭 링크인 경우 Antora는 디렉터리를 재귀적으로 복사한 것처럼 처리하지만 실제로는 복사하지 않았습니다.

이 기능을 어떻게 활용하는지 알아봅시다.

=== 심볼릭 링크를 사용하여 파일 재매핑

Antora에서 심볼릭 링크 기능의 가장 일반적인 사용 사례 중 하나를 고려해 보겠습니다. 문서에 포함하려는 예제 파일이 있지만 해당 파일은 표준 Antora 디렉터리 구조 내에 없습니다. Antora에서 사용할 수 있도록 하려면 Antora 계층 구조로 재매핑해야 합니다.
해당 레이아웃의 그림을 봅시다:

[source]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----

우리가 하고 싶은 것은 __index.adoc__ 페이지에 소스 파일 __MyClass.java__(또는 일부)를 포함하는 것입니다. 그러나 소스 파일이 Antora 계층 구조 아래에 없기 때문에 현재는 불가능합니다. 심볼릭 링크가 구원해줍니다!

심볼릭 링크가 위치할 __ROOT__ 모듈 아래에 __examples__ 폴더를 만드는 것부터 시작하세요.

[source]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 examples
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----

다음으로 __examples__ 폴더에서 __MyClass.java__로 심볼릭 링크를 만들어 Antora 계층 구조로 가져와 보겠습니다. 터미널에서 해당 디렉터리로 전환하는 것부터 시작하세요.

[source]
----
$ cd docs/modules/ROOT/examples
----

그런 다음 운영 체제에 적합한 명령을 사용하여 심볼릭 링크를 만듭니다.

.*nix
[source,console]
----
$ ln -s ../../../src/main/java/org/example/MyClass.java MyClass.java
----

.Windows
[source,console]
----
$ mklink MyClass.java ..\..\..\src\main\java\org\example\MyClass.java
----

결과는 다음과 같습니다.

[source]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 examples
        🔗 MyClass.java <1>
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----
<1> MyClass.java는 리포지토리 루트의 src/main/java/org/example 아래에 있는 MyClass.java 파일에 대한 심볼릭 링크입니다.

TIP: 문서 콘텐츠 소스를 git 참조에서 가져오는 경우 다른 파일과 마찬가지로 심볼릭 링크를 git 저장소에 커밋하세요.

이제 다음 include 지시문을 사용하여 __index.adoc__ 페이지에 소스 파일을 포함할 수 있습니다:

[source]
----
\include::example$MyClass.java[]
----

포함하려는 모든 파일에 대해 심볼릭 링크를 만드는 것이 지루할 수 있습니다. 바로 여기서 디렉터리 심볼릭 링크가 작동합니다. 디렉터리에 대한 심볼릭 링크를 만들 수 있으며, 이는 해당 계층 구조를 Antora 계층 구조에 효과적으로 이식합니다.

소스 파일에 대한 심볼릭 링크 디렉터리를 만드는 대신 __src__ 폴더에 대한 심볼릭 링크를 만들어 보겠습니다. 다시 한 번, __examples__ 디렉터리로 전환하는 것부터 시작하세요.

[source,console]
----
$ cd docs/modules/ROOT/examples
----

그런 다음 운영 체제에 적합한 명령을 사용하여 심볼릭 링크를 만듭니다.

.*nix
[source,console]
----
$ ln -s ../../../src src
----

.Windows
[source,console]
----
$ mklink src ..\..\..\src
----

결과는 다음과 같습니다:

[source]
----
📒 docs
  📄 antora.yml
  📂 modules
    📂 ROOT
      📂 examples
        🔗 src <1>
      📂 pages
        📄 index.adoc
      📄 nav.adoc
📒 src
  📒 main
    📒 java
      📒 org
        📒 example
          📄 MyClass.java
----
<1> src는 리포지토리 루트의 src 폴더에 대한 심볼릭 링크입니다.

문서 콘텐츠 소스를 git 참조에서 가져오는 경우 다른 파일과 마찬가지로 심볼릭 링크를 git 저장소에 커밋하세요. 심볼릭 링크가 디렉터리를 가리키더라도 git에서는 여전히 파일처럼 취급됩니다.

이제 다음 include 지시문을 사용하여 __index.adoc__ 페이지에 소스 파일을 포함할 수 있습니다:

[source]
----
\include::example$src/main/java/org/example/MyClass.java[]
----

예제, 부분, 페이지, 이미지 등을 포함하여 모든 유형의 리소스에 대한 심볼릭 링크를 만들 수 있습니다. 심볼릭 링크의 대상은 일반적으로 Antora 계층 구조 외부에 있지만, 파일이나 디렉터리를 복제하려는 경우 심볼릭 링크가 Antora 계층 구조 내의 위치를 가리킬 수 있습니다.

== 제한 사항

Antora에서 심볼릭 링크를 사용할 때 알아야 할 몇 가지 제한 사항이 있습니다.

- 심볼릭 링크의 대상이 존재해야 합니다. Antora가 심볼릭 링크를 해결할 수 없으면 오류가 발생합니다.
- 심볼릭 링크는 자신을 가리킬 수 없습니다. Antora가 이 시나리오를 감지하면 오류가 발생합니다.
- git 리포지토리의 심볼릭 링크는 git 리포지토리 외부의 위치를 가리킬 수 없습니다.
- git 리포지토리의 심볼릭 링크는 git 리포지토리의 다른 참조에 있는 위치를 가리킬 수 없습니다.
- 심볼릭 링크의 대상은 상대적이어야 합니다. 절대 경로를 대상으로 하는 심볼릭 링크를 만들면 정의되지 않았거나 이식 가능하지 않은 동작이 발생합니다.

문서 사이트에서 사용되지 않는 많은 파일을 Antora 계층 구조에 매핑하지 마세요. 그렇게 하면 빌드 속도를 느리게 만들 수 있는 Antora에 대한 추가 처리가 추가됩니다. Antora 계층 구조로 매핑하는 파일에 대해 최대한 수술적이고 정확하게 작업하세요.
