= 콘텐츠 소스 버전 관리 방법

이 페이지에서는 콘텐츠 버전을 관리하는 데 사용할 수 있는 몇 가지 방법에 대해 설명합니다. 이러한 권장 사항은 소프트웨어 문서에 가장 적용되지만 다른 콘텐츠에도 적용될 수 있습니다.

== 브랜치를 사용하여 콘텐츠 버전 관리

이 방법을 사용하면 소프트웨어 프로젝트의 버전 라인을 저장하기 위해 브랜치를 사용하는 것처럼 git 저장소의 브랜치에 각 문서 버전을 저장합니다. 그런 다음 콘텐츠 소스의 branches 키를 설정하여 Antora에 사용할 브랜치를 알려줍니다. 브랜치의 이름 자체는 중요하지 않습니다. 구성 요소 버전 설명자 또는 플레이북의 version 키가 버전을 결정합니다.

브랜치를 사용하여 콘텐츠 버전을 관리하는 것은 Antora를 사용할 때 시작하는 것이 좋습니다. 브랜치는 동일한 콘텐츠의 여러 버전을 관리하는 데 이상적입니다.

이전에 버전 관리에 브랜치를 사용하지 않았다면 폴더에 버전을 저장했을 수 있습니다. 단일 브랜치에 모든 문서 버전을 저장하기 위해 버전 폴더를 사용한다면 새 버전을 만들기 위해 버전의 모든 파일을 새 폴더에 명시적으로 복사해야 합니다. 그렇게 하면 더 이상 git에 의존하여 동일한 문서의 서로 다른 버전을 비교, 관리 및 병합할 수 없습니다.

태그를 사용하여 문서 버전을 저장하면 태그가 만들어진 후에는 문서를 업데이트할 수 없으므로 문서가 업데이트를 받지 못하도록 효과적으로 동결됩니다.

브랜치는 적절한 균형을 제공합니다. 저장소의 기존 참조에서 새 브랜치를 만들어 새 버전을 유지하면 저장소는 해당 브랜치 지점 이후로 변경된 내용만 저장합니다. 그리고 해당 브랜치는 언제든지 업데이트를 받을 수 있습니다. 그것이 git이 가장 잘하는 일입니다.

브랜치는 git에서 제공하는 참조 시스템과 잘 매핑되며 문서를 자유롭게 업데이트할 수 있을 만큼 유연합니다.

== 태그를 사용하여 콘텐츠 버전 관리

이 방법을 사용하면 소프트웨어 릴리스를 저장하기 위해 태그를 사용하는 것처럼 git 저장소의 태그에 각 문서 버전을 저장합니다. 그런 다음 콘텐츠 소스의 tags 키를 설정하여 Antora에 사용할 태그를 알려줍니다. 태그는 브랜치와 동일한 많은 이점을 제공하지만 몇 가지 주목할 만한 단점이 있습니다.

브랜치와 마찬가지로 태그를 사용하면 버전에 걸쳐 파일의 서로 다른 인스턴스를 비교할 수 있으며 저장소는 이전 태그 지점 이후로 변경된 내용만 저장합니다. 태그의 단점은 일단 생성되면 브랜치처럼 업데이트할 수 없다는 것입니다. 따라서 오타를 발견하거나 예제를 추가해야 하는 경우 태그의 콘텐츠를 편집할 수 없습니다. 동결됩니다. 업데이트를 게시하려면 태그를 삭제하고 다시 만들거나 새 태그를 만들고 해당 태그를 가리켜야 합니다.

단점에도 불구하고 태그를 사용하여 콘텐츠 버전을 관리하기로 결정한 경우 문서 전용 태그(예: release/2.0.1을 따르는 docs/2.0.1)를 사용하는 것이 **매우** 좋습니다. 그렇게 하면 소프트웨어 태그가 생성된 후 문서가 동결(태그 지정)되기 전에 문서를 업데이트할 수 있는 창을 제공합니다. 그렇지 않으면 소프트웨어가 릴리스되기 전에 모든 문서 업데이트가 완료되었는지 확인해야 하는데, 이는 거의 그렇지 않습니다. (대안은 소프트웨어 릴리스를 너무 자주 릴리스하여 소프트웨어 릴리스를 놓치는 것이 큰 문제가 되지 않는 것입니다).

== 폴더를 사용하여 콘텐츠 버전 관리

이 방법을 사용하면 저장소의 단일 참조(브랜치 또는 태그)에 있는 폴더에 각 문서 버전을 저장합니다. 그런 다음 콘텐츠 소스의 start_paths 키를 설정하여 해당 폴더를 찾을 디렉터리를 Antora에 알려주고 branches 또는 tags 키를 설정하여 Antora를 디렉터리가 있는 참조로 가리킵니다. 폴더의 이름 자체는 중요하지 않습니다. 컴포넌트 버전 설명자(__antora.yml)__의 version 키가 버전을 결정합니다.

앞에서 설명한 대로 git이 제공하는 많은 이점을 잃기 때문에 일반적으로 이 방법은 권장하지 않습니다. 그러나 동일한 저장소에 많은 다른 버전 관리 소프트웨어 구성 요소에 대한 문서가 공존할 때 유용할 수 있습니다. 이 시나리오에서는 단일 소프트웨어 구성 요소에 대한 참조가 다른 소프트웨어 구성 요소의 관련 없는(그리고 아마도 오래된) 문서를 함께 전달하므로 참조(브랜치 또는 태그)가 잘 작동하지 않습니다. 그러한 배열은 git의 모델에 맞지 않습니다. 그리고 작성자에게 혼란스러울 수 있습니다.

콘텐츠 버전 관리에 폴더를 사용하는 것은 논란의 여지가 있지만 작성자가 사용하기에 가장 쉬운 시스템입니다. 작성자는 콘텐츠 소스 저장소를 복제하고 브랜치 전환을 수행하지 않고도 모든 버전에서 파일을 즉시 편집할 수 있습니다. 작성자가 더 이상 git에 의존하여 다른 버전을 비교, 관리 및 병합할 수 없으며 각 버전이 이전 버전의 완전한 사본으로 시작되지만 모든 파일을 함께 사용하는 것의 생산성 이점이 우선할 수 있습니다. 그래서 Antora는 이 방법을 지원합니다. 그러나 여러 작업 트리를 사용하면 git의 버전 제어 메커니즘을 사용하는 기능을 희생하지 않고 브랜치를 사용하여 유사한 설정을 달성할 수 있습니다.

저장소가 많은 다른 구성 요소에 대한 버전 관리 문서를 호스팅하거나 작성자가 브랜치로 작업할 수 없는 경우에만 폴더를 사용하여 콘텐츠 버전을 관리하는 것을 고려해야 합니다.

== 문서 버전 및 소프트웨어 릴리스

우리는 문서를 릴리스 라인의 소프트웨어에 대한 설명으로 봅니다. 문서는 게시된 소프트웨어를 설명합니다. 따라서 소프트웨어가 릴리스된 후에도(어쩌면 오랜 시간이 지난 후에도) 문서를 업데이트할 수 있어야 합니다.

문서 수명 주기는 소프트웨어 수명 주기에 얽매이지 않고 오히려 따라갑니다. 많은 경우 소프트웨어 릴리스가 이루어질 때 문서가 준비되지 않았으며 여전히 작업이 필요합니다(그렇지 않으면 문서 팀에 엄청난 압박을 가하게 됩니다). 다른 경우에는 해당 릴리스에 대한 문서에 추가해야 하는 소프트웨어 릴리스에 대한 새로운 정보가 발견됩니다.

소프트웨어가 의미 체계 버전 관리를 준수하는 경우 일반적으로 문서 버전을 소프트웨어의 부 버전(예: 1.0, 1.1, 2.0 등)에 매핑하는 것이 좋습니다. 소프트웨어가 부 릴리스 라인(예: v1.0.x, v1.1.x, v2.0.x 등)을 따르는 브랜치를 사용하여 관리될 때 이 매핑이 가능합니다.

문서 버전을 소프트웨어의 부 버전 라인에 매핑하는 것은 일반적으로 문서가 패치 릴리스에 묶여 있지 않기 때문에 작동합니다. 많은 경우 문서는 이전에 누락된 정보를 포함하도록 업데이트됩니다. 그리고 그 정보는 다음 패치 릴리스 이전이나 이후 언제든지 추가될 수 있습니다.

요약하면 일반적으로 태그에서 소프트웨어 릴리스에 대한 문서를 작성하는 것은 권장하지 않습니다. 문서는 소프트웨어 자체가 아니라 소프트웨어에 대한 설명입니다. 소프트웨어 버전이 동결되고 릴리스된 후에도 문서를 업데이트할 수 있어야 합니다. 태그를 사용하는 경우 소프트웨어 릴리스용 태그와 구별되는 문서용 태그를 사용하는 것이 좋습니다.

=== 사전 릴리스용 태그

태그가 적합한 곳은 사전 릴리스에 대한 문서를 게시할 때입니다. 사전 릴리스(prerelease)에서는 소프트웨어가 게시되기 훨씬 전에 새로운 기능을 추가할 수 있습니다. 이러한 새로운 기능에는 해당 기능을 설명하는 문서가 수반될 수 있습니다. 그 결과 문서는 아직 사용할 수 없는 기능을 참조합니다. Antora가 사전 릴리스 브랜치에서 문서를 게시하면 사용자가 특정 기능을 사용할 수 있다고 생각하지만 실제로는 그렇지 않습니다.

이 문제를 해결하려면 대신 마지막 사전 릴리스의 태그에서 문서를 가져올 수 있습니다. 태그에서 사전 릴리스에 대한 문서를 게시함으로써 소프트웨어가 릴리스될 때 사용 가능한 내용으로만 문서를 잠글 수 있습니다. 이렇게 하면 아직 사용할 수 없는 기능에 대한 문서를 게시하지 않습니다.

유일한 주의 사항은 사전 릴리스가 태그되기 전에 완성되지 않은 문서는 다음 사전 릴리스까지 사용할 수 없다는 것입니다. 이는 앞에서 설명한 대로 태그를 사용할 때의 동일한 제한 사항입니다. 그러나 사전 릴리스는 본질적으로 완전하다고 간주되지 않으며 다른 사전 릴리스가 뒤따를 수 있기 때문에 이 경우에는 덜 우려됩니다.

== 더 알아보기

- Define a Component Version
- How Component Versions are Sorted
- Define a Component with No Version
