= 콘텐츠 파일 구성 방법

Antora는 콘텐츠를 집계하고 사이트를 생성하기 위해 규칙과 구성을 모두 사용합니다. 리포지토리를 설정하거나 마이그레이션하기 전에 Antora와 함께 작동하도록 문서 프로젝트와 콘텐츠 파일을 구성하는 방법에 영향을 미칠 수 있는 몇 가지 주요 개념을 살펴보겠습니다.

== 콘텐츠 소스 파일 저장

Antora는 분기, 태그 또는 로컬 작업 트리의 시작 경로 또는 여러 시작 경로 아래에서 파일 또는 해당 symlink를 검색하여 여러 git 리포지토리에서 콘텐츠 소스 파일을 검색할 수 있습니다. Antora가 사용하는 리포지토리는 문서 저장용으로만 예약될 필요는 없습니다(시작 경로를 지정함으로써 가능합니다). Antora는 형제 계층 구조에서 애플리케이션 코드, 테스트 및 기타 자료를 호스팅하는 리포지토리에서 파일을 검색할 수 있습니다. Antora는 규칙과 구성에 모두 의존하여 문서 콘텐츠를 식별합니다.

여러 개의 다중 사용 리포지토리에서 소스 파일을 가져오려면 Antora에서 문서 파일이 다음과 같아야 합니다:

- 콘텐츠 소스 루트 아래에 위치
- __antora.yml__이라는 파일로 레이블 지정
- 표준 디렉터리 세트로 구성

필수는 아니지만 파일 이름에 항상 소문자를 사용하는 것이 **매우** 권장합니다. 일부 파일 시스템은 대소문자를 구분하고 다른 파일 시스템은 대소문자를 구분하지 않습니다. 항상 소문자를 사용하면 파일 시스템, 웹 서버 또는 전송 도구가 대소문자를 보존하지 않을 경우 발생하는 문제를 방지할 수 있습니다.

== 콘텐츠 소스 파일 분류

Antora는 모든 콘텐츠 소스 루트에서 소스 파일을 수집한 후 각 파일에 메타데이터를 할당하여 분류합니다. 이 메타데이터는 사이트 내에서 파일을 고유하게 식별하는 데 사용됩니다. 파일의 식별자(리소스 ID라고 함)는 페이지, 기타 리소스 및 구성에서 참조를 만드는 데 사용됩니다. 이 단계에서는 소스 파일을 구성 요소 버전으로 암시적으로 분할합니다.

=== Antora의 가상 파일 시스템

Antora는 소스 파일을 수집한 후 저장 위치에서 분리합니다. 모든 의도와 목적을 위해 각 파일의 출처는 무관합니다. 즉, Antora는 파일이 발견되고 로드되면 파일을 읽기 위해 파일 시스템이나 git 리포지토리로 돌아가지 않습니다. Antora는 파일을 수집한 후 생성한 가상 파일 시스템(VFS)을 기반으로 모든 파일 작업을 수행합니다.

파일 시스템의 위치에 매핑되는 파일의 유일한 부분은 패밀리 상대 경로입니다. 그리고 이 연결 조차도 단순히 작성자의 편의를 위해 유지 관리됩니다. 패밀리 상대 경로를 제외하고 파일 ID의 다른 모든 부분은 구성 요소 이름, 버전, 모듈 이름 및 패밀리과 같은 연관 메타데이터를 기반으로 합니다.

=== 파일 메타데이터

그렇다면 파일은 이 메타데이터를 어떻게 얻을까요? 동일한 콘텐츠 소스 루트의 모든 파일은 __antora.yml__이라는 구성 요소 버전 설명자 파일에서 구성 요소 이름과 버전을 상속합니다. 이러한 설명자 파일은 Antora가 수집된 모든 소스 파일을 구성 요소 버전으로 정렬하고 구성하는 데 도움이 됩니다. 구성 요소 버전을 프로젝트 버전에 대한 모든 문서로 생각할 수 있습니다. 예를 들어, 지금 Antora 3.1 구성 요소 버전의 페이지를 읽고 있습니다.

이러한 __antora.yml__ 파일은 동일한 버전의 프로젝트에 속하는 콘텐츠를 Antora에서 식별하는 방법입니다. 또한 구성 요소 버전이 암시적으로 정의되고 채워지는 방법이기도 합니다.

콘텐츠 소스 루트 내에서 파일은 모듈 및 패밀리 폴더로 더 그룹화되어 소스 파일 ID의 두 가지 측면을 더 제공합니다. 마지막으로 패밀리 상대 경로가 캡처되어 여러 리포지토리 또는 git 참조에서도 패밀리 내에서 소스 파일을 고유하게 식별합니다.

=== 파일 위치 및 URL

소스 파일의 위치는 게시된 파일의 위치를 지정하지 않습니다. 소스 파일이 Antora의 VFS에 로드되면 파일의 출력 위치와 URL을 계산하는 것을 포함하여 파일의 메타데이터가 조작됩니다. 파일의 각 패밀리에는 이러한 값이 계산되는 방법에 대한 서로 다른 규칙이 있습니다. 소스 파일이 발견되는 위치, 게시된 파일이 사이트에 배치되는 위치 또는 해당 파일에 액세스하는 방법 간의 연결은 하드 와이어링되지 않습니다.

콘텐츠 소스 파일 그룹에 구성 요소 이름, 버전 및 기타 선택적 정보를 할당하는 방법을 알아보려면 "What's a component version?" 및 "What's antora.yml?"을 참조하세요.

== git refname

분기 및 태그 이름을 포함하는 git refname은 URL 인코딩할 필요가 없는 문자만 포함해야 합니다. 이 규칙은 git에 의해 적용되지 않지만 위반하면 Antora에서 미묘한 문제가 발생할 수 있습니다.

refname은 게시된 리소스의 URL에 나타나지 않지만 파일의 출처에 대한 참조에 사용됩니다. 특히 URL 인코딩해야 하는 문자를 refname에 사용하면 페이지의 편집 URL 조립이 복잡해집니다.

예를 들어 ``#`` 문자는 이 규칙을 위반하므로 ``%23``으로 인코딩해야 합니다. Antora는 이 문자를 포함하도록 편집 URL을 기꺼이 작성하지만 브라우저에서 예상대로 URL이 해석되지 않습니다. 그 이유는 ``#``이 서버로 전송되는 URL과 브라우저에서만 볼 수 있는 프래그먼트 사이의 경계를 표시하기 때문입니다. 결과는 불완전한 URL이 되고 따라서 404 페이지가 됩니다.

refname에 범용 디렉터리 구분 기호인 ``/``를 사용하는 것은 허용됩니다. 그렇게 하면 ref를 폴더 구조로 효과적으로 구성합니다(예: r/3.0.x). 그러나 이 전략은 refname 일치에 영향을 줄 수 있습니다. refname 패턴의 ``*`` 문자는 ``/``와 일치하지 않습니다(폴더의 경계를 넘지 않음). 따라서 r/3.0.x와 같은 refname과 일치시키려면 ``r*`` 대신 ``r/*`` 패턴을 사용해야 합니다.