= Antora Documentation

== Images

=== 이미지 리소스

이미지는 사진, 다이어그램, 스크린샷 등과 같이 images 패밀리 디렉토리에 저장되는 소스 파일입니다. AsciiDoc 이미지 매크로를 사용하면 이미지가 속한 모듈이나 컴포넌트 버전에 관계없이 모든 페이지나 부분에 이미지를 삽입할 수 있습니다. AsciiDoc은 PNG, JPG, SVG 및 GIF(정적 및 애니메이션) 이미지 파일 형식을 지원합니다.

=== 블록 및 인라인 이미지 매크로

블록과 인라인의 두 가지 AsciiDoc 이미지 매크로 유형이 있습니다. 블록 이미지는 페이지에서 개별 요소로 표시됩니다.

.예제 1. 블록 이미지 매크로
[source,asciidoc]
----
This is a paragraph.

image::resource-id-of-target-image.ext[]
----
인라인 이미지는 단락이나 사이드바 블록과 같은 다른 요소의 흐름 안에 표시됩니다.

.예제 2. 인라인 이미지 매크로
[source,asciidoc]
----
This sentence contains an inline image:resource-id-of-target-image.ext[] image.
----

=== 이미지 매크로에서 리소스로 연결

xref 요소 속성을 사용하면 페이지에 포함된 이미지에서 페이지, 첨부 파일, 요소 또는 다른 이미지까지 참조할 수 있습니다.

.예제 3. 이미지 매크로에 할당된 xref 요소 속성
[source,asciidoc]
----
image::resource-id-of-target-image.ext[xref=resource-id.ext]
----

자세한 내용은 이미지에서 리소스 링크를 참조하세요.



== Images - Add Block Images

이 페이지에서 다음을 배웁니다:

* [*] AsciiDoc 블록 이미지 매크로의 구조.
* [*] 리소스 ID를 사용하여 블록 이미지를 삽입하는 방법.

=== AsciiDoc 블록 이미지 매크로

AsciiDoc 블록 이미지 매크로는 이미지의 소스 파일을 부분 또는 페이지에 포함하는 데 사용됩니다. 블록 이미지 매크로는 PNG, JPG, SVG 및 GIF(정적 및 애니메이션) 이미지 파일의 Antora 리소스 ID를 값으로 받아들입니다.

Antora가 실행되면 블록 이미지 매크로에 의해 참조되는 이미지 파일이 게시된 페이지에 개별 요소로 포함되어 표시됩니다. 예를 들어, 이 단락 아래의 SVG 이미지는 블록 이미지 매크로를 사용하여 이 페이지에 포함되어 있습니다.

image::img/console.svg[]

==== 블록 이미지 매크로 구조

예제 1은 블록 이미지 매크로의 구조를 보여줍니다.

.예제 1. 블록 이미지 매크로
[source,asciidoc]
----
This is a paragraph.

image::resource-id-of-target-image.ext[optional attribute,optional attribute] <1>

This is another paragraph.
----
<1> 블록 이미지는 매크로 이름 뒤에 두 개의 콜론(::)으로 지정됩니다. 빈 줄이 앞에 오고, 그 자체로 한 줄에 입력된 다음, 빈 줄이 뒤따릅니다.

최소한 블록 이미지 매크로는 매크로의 접두사(image::), 대상 이미지의 리소스 ID 및 대괄호([])로 구성됩니다. 대상 이미지는 현재 페이지에서 참조하는 이미지 소스 파일입니다. 대상 이미지는 현재 페이지의 내용에서 인라인 또는 블록 이미지 매크로에 리소스 ID를 할당하여 참조됩니다. 현재 페이지는 대상 이미지를 참조하는 이미지 매크로를 포함하는 페이지 소스 파일입니다.

예제 1에 표시된 블록 이미지 매크로의 각 부분은 아래에서 더 자세히 설명합니다.

image::
블록 이미지 매크로는 매크로의 이름 image와 두 개의 콜론(::)으로 시작합니다.

대상 이미지의 리소스 ID::
이미지 매크로는 이미지 소스 파일의 리소스 ID를 값으로 받아들입니다. 값은 매크로 이름(image::) 뒤의 두 번째 콜론 바로 뒤에 입력됩니다. 현재 페이지와 관련하여 대상 이미지의 컴포넌트 버전 및 모듈에 따라 대상 이미지의 리소스 ID 좌표를 얼마나 많이 지정해야 하는지가 결정됩니다. 이미지 매크로에서 이미지를 참조할 때는 대상 이미지의 리소스 ID에 image$ 패밀리 좌표를 포함할 필요가 없습니다. 런타임에 자동으로 적용됩니다.

[optional attribute,optional attribute]::
블록 이미지 매크로는 대상 이미지의 리소스 ID 끝에 대괄호([])로 완성됩니다. 대괄호를 비워 둘 수 있으며, 선택적 속성을 하나 이상 쉼표로 구분된 목록으로 대괄호 안에 할당할 수 있습니다.

다음 섹션인 블록 이미지 포함에서는 블록 이미지 매크로를 단계별로 설정하는 방법을 설명합니다.

=== 블록 이미지 포함

블록 이미지 매크로를 사용하여 페이지(현재 페이지)에 이미지(대상 이미지)를 삽입하는 데 필요한 블록 이미지 매크로와 리소스 ID 좌표를 분석해 보겠습니다.

. IDE 또는 텍스트 편집기에서 이미지를 삽입할 페이지를 엽니다. 이 연습에서는 __satellites.adoc__ 파일을 열었습니다. __satellites.adoc__는 현재 페이지입니다.

. __satellites.adoc__에서 블록 이미지 __console.svg__를 포함해 보겠습니다.

. 새 줄의 시작 부분에 매크로의 이름 다음에 두 개의 콜론을 입력합니다(image::). 이전 요소(예: 단락 또는 소스 블록)와 이미지 매크로를 배치하는 줄 사이에 빈 줄이 있는지 확인하세요.
+
.예제 2. satellites.adoc (현재 페이지)
[source,asciidoc]
----
After scanning your badge, you should see this screen.

image::
----

. 두 개의 콜론 바로 뒤에 대상 이미지 파일의 리소스 ID를 입력합니다. 이 예제에서는 __console.svg__와 __satellites.adoc__ 모두 동일한 컴포넌트 버전과 모듈에 속하며 대상 이미지가 이미지 패밀리 디렉토리의 루트에 저장되어 있습니다. 따라서 __console.svg__의 파일 이름과 확장자만 블록 이미지 매크로의 값으로 할당하면 됩니다.
+
.예제 3. satellites.adoc (현재 페이지)
[source,asciidoc]
----
After scanning your badge, you should see this screen.

image::console.svg
----
+
__console.svg__의 리소스 ID에 패밀리 좌표가 포함되어 있지 않다는 점에 주목하세요. Antora는 이미지 매크로에 할당된 리소스 ID에 자동으로 image$ 패밀리 좌표를 적용합니다.

. 대상 이미지의 리소스 ID 바로 뒤에 왼쪽 대괄호([)를 입력한 다음 오른쪽 대괄호(])를 입력합니다.
+
.예제 4. satellites.adoc (현재 페이지)
[source,asciidoc]
----
After scanning your badge, you should see this screen.

image::console.svg[]
----
+
이 예제에서는 블록 이미지 매크로에 선택적 속성을 적용하지 않았습니다. 그러나 대괄호 안에 쉼표로 구분된 목록으로 하나 이상의 속성을 지정할 수 있습니다.

. 마지막 대괄호(]) 뒤에 kbd:[Enter] 키를 두 번 눌러 이미지 매크로 뒤에 새 줄을 삽입합니다.
+
.예제 5. satellites.adoc (현재 페이지)
[source,asciidoc]
----
After scanning your badge, you should see this screen.

image::console.svg[]

Enter the satellite position after the prompt.
----

이것으로 끝입니다! AsciiDoc 블록 이미지 매크로를 사용하여 대상 이미지(__console.svg__)를 현재 페이지(__satellites.adoc__)에 삽입했습니다.

=== 더 알아보기

다른 모듈, 문서 컴포넌트 및 버전에 속하는 이미지를 포함하는 방법을 알아보려면 Image resource ID examples를 참조하세요.



== Images - Add Inline Images

이 페이지에서 다음을 배웁니다:

* [*] AsciiDoc 인라인 이미지 매크로의 구조.
* [*] 리소스 ID를 사용하여 인라인 이미지를 삽입하는 방법.

=== AsciiDoc 인라인 이미지 매크로

AsciiDoc 인라인 이미지 매크로는 이미지의 소스 파일을 부분 또는 페이지에 포함하는 데 사용됩니다. 인라인 이미지 매크로는 PNG, JPG, SVG 및 GIF(정적 및 애니메이션) 이미지 파일의 Antora 리소스 ID를 값으로 받아들입니다.

Antora가 실행되면 인라인 이미지 매크로에 의해 참조되는 이미지 파일이 사이드바 블록과 같은 다른 요소의 흐름에 포함되어 게시된 페이지에 표시됩니다. 예를 들어, 이것은 인라인 이미지 매크로를 사용하여 이 단락에 포함된 SVG 이미지 image:img/blue-dot.svg[]입니다.

==== 인라인 이미지 매크로 구조

예제 1은 인라인 이미지 매크로의 구조를 보여줍니다.

.예제 1. 인라인 이미지 매크로
[source,asciidoc]
----
This sentence contains an inline image:resource-id-of-target-image.ext[optional attribute,optional attribute] image. <1>
----
<1> 인라인 이미지는 내용의 흐름에 삽입됩니다. 매크로 이름 뒤에 하나의 콜론(:)으로 지정됩니다.

최소한 인라인 이미지 매크로는 매크로의 접두사(pass:[image:]), 대상 이미지의 리소스 ID 및 대괄호([])로 구성됩니다. 대상 이미지는 현재 페이지에서 참조하는 이미지 소스 파일입니다. 대상 이미지는 현재 페이지의 내용에서 인라인 또는 블록 이미지 매크로에 리소스 ID를 할당하여 참조됩니다. 현재 페이지는 대상 이미지를 참조하는 이미지 매크로를 포함하는 페이지 소스 파일입니다.

예제 1에 표시된 인라인 이미지 매크로의 각 부분은 아래에서 더 자세히 설명합니다.

pass:[image:]::
인라인 이미지 매크로는 매크로의 이름 image와 하나의 콜론(:)으로 시작합니다.

대상 이미지의 리소스 ID::
이미지 매크로는 이미지 소스 파일의 리소스 ID를 값으로 받아들입니다. 값은 매크로 이름(image:) 뒤의 콜론 바로 뒤에 입력됩니다. 현재 페이지와 관련하여 대상 이미지의 컴포넌트 버전 및 모듈에 따라 대상 이미지의 리소스 ID 좌표를 얼마나 많이 지정해야 하는지가 결정됩니다. 이미지 매크로에서 이미지를 참조할 때는 대상 이미지의 리소스 ID에 image$ 패밀리 좌표를 포함할 필요가 없습니다. 런타임에 자동으로 적용됩니다.

[optional attribute,optional attribute]::
인라인 이미지 매크로는 대상 이미지의 리소스 ID 끝에 대괄호([])로 완성됩니다. 대괄호를 비워 둘 수 있으며, 선택적 속성을 하나 이상 쉼표로 구분된 목록으로 대괄호 안에 할당할 수 있습니다.

다음 섹션인 인라인 이미지 포함에서는 인라인 이미지 매크로를 단계별로 설정하는 방법을 설명합니다.

=== 인라인 이미지 포함

인라인 이미지 매크로를 사용하여 페이지(현재 페이지)에 이미지(대상 이미지)를 삽입하는 데 필요한 인라인 이미지 매크로와 리소스 ID 좌표를 분석해 보겠습니다.

. IDE 또는 텍스트 편집기에서 이미지를 삽입할 페이지를 엽니다. 이 연습에서는 __satellites.adoc__ 파일을 열었습니다. __satellites.adoc__는 현재 페이지입니다.

. __satellites.adoc__에서 인라인 이미지 __blue-dot.svg__를 포함해 보겠습니다. 대상 이미지를 표시할 현재 페이지 내용 흐름의 위치를 선택합니다. 매크로의 이름 다음에 하나의 콜론을 입력합니다(image:).
+
.예제 2. satellites.adoc (현재 페이지)
[source,asciidoc]
----
Look for the image:
----

. 콜론 바로 뒤에 대상 이미지 파일의 리소스 ID를 입력합니다. 이 예제에서는 __blue-dot.svg__와 __satellites.adoc__ 모두 동일한 컴포넌트 버전과 모듈에 속하며 대상 이미지가 이미지 패밀리 디렉토리의 루트에 저장되어 있습니다. 따라서 __blue-dot.svg__의 파일 이름과 확장자만 인라인 이미지 매크로의 값으로 할당하면 됩니다.
+
.예제 3. satellites.adoc (현재 페이지)
[source,asciidoc]
----
Look for the image:blue-dot.svg
----
+
__blue-dot.svg__의 리소스 ID에 패밀리 좌표가 포함되어 있지 않다는 점에 주목하세요. Antora는 이미지 매크로에 할당된 리소스 ID에 자동으로 image$ 패밀리 좌표를 적용합니다.

. 대상 이미지의 리소스 ID 바로 뒤에 왼쪽 대괄호([)를 입력한 다음 오른쪽 대괄호(])를 입력합니다.
+
.예제 4. satellites.adoc (현재 페이지)
[source,asciidoc]
----
Look for the image:blue-dot.svg[]
----
+
이 예제에서는 인라인 이미지 매크로에 선택적 속성을 적용하지 않았습니다. 그러나 대괄호 안에 쉼표로 구분된 목록으로 하나 이상의 속성을 지정할 수 있습니다.

. 마지막 대괄호(]) 뒤에 kbd:[SPACE] 바를 한 번 눌러 매크로 뒤에 공백을 삽입한 다음 내용을 계속 입력합니다.
+
.예제 5. satellites.adoc (현재 페이지)
[source,asciidoc]
----
Look for the image:blue-dot.svg[] on the console.
----

이것으로 끝입니다! AsciiDoc 인라인 이미지 매크로를 사용하여 대상 이미지(__blue-dot.svg__)를 현재 페이지(__satellites.adoc__)에 삽입했습니다.

=== 더 알아보기

다른 모듈, 문서 컴포넌트 및 버전에 속하는 이미지를 포함하는 방법을 알아보려면  Image resource ID examples를 참조하세요.



== Images - Image Resource ID Examples

=== 이미지 리소스 ID 예제

대상 이미지 파일이 속한 모듈이나 컴포넌트 버전에 관계없이 사이트의 모든 페이지에 이미지를 삽입할 수 있습니다. 이 페이지에서는 이미지가 포함될 페이지와 관련하여 이미지가 속한 버전, 컴포넌트 및 모듈을 기준으로 이미지 매크로에 올바른 리소스 ID 좌표를 할당하는 방법을 배웁니다.

[NOTE]
====
블록 이미지 매크로 및 인라인 이미지 매크로에 대한 개요와 페이지에 추가하는 단계별 지침은 다음을 참조하세요:

- Add Block Images
- Add Inline Images

Antora 리소스 ID 또는 그 좌표에 익숙하지 않은 경우 다음을 참조하세요:

- Resources and Resource IDs
- Resource ID Coordinates

====

TIP: 이 페이지의 모든 예제는 개념을 설명하는 데 사용하는 이미지 매크로에 관계없이 블록 이미지 매크로와 인라인 이미지 매크로 모두에 적용됩니다.

=== 모듈 내에서 이미지 사용

이미지 매크로로 참조하는 대부분의 이미지는 아마도 현재 페이지와 동일한 모듈 및 컴포넌트 버전에 속할 것입니다. 이러한 상황에서는 AsciiDoc 이미지 매크로에 대상 이미지의 리소스 ID의 파일 좌표만 값으로 할당하면 됩니다.

NOTE: 대상 이미지는 현재 페이지에서 참조하는 이미지 소스 파일입니다. 대상 이미지는 현재 페이지의 내용에서 인라인 또는 블록 이미지 매크로에 리소스 ID를 할당하여 참조됩니다. 현재 페이지는 대상 이미지를 참조하는 이미지 매크로를 포함하는 페이지 소스 파일입니다.

대상 이미지의 파일 좌표 구조는 대상 이미지가 이미지 패밀리 디렉토리의 루트에 저장되는지 아니면 이미지 디렉토리의 하위 디렉토리에 저장되는지에 따라 달라집니다.

.예제 1. current-page.adoc
[source,asciidoc]
----
image:target-image-filename.ext[optional attribute] <1>

image:path/to/target-image-filename.ext[optional attribute] <2>

image:./target-image-filename.ext[optional attribute] <3>
----
<1> 대상 이미지가 이미지 디렉토리의 루트에 저장된 경우 대상 이미지의 파일 좌표.
<2> 대상 이미지가 이미지 디렉토리의 하위 디렉토리에 저장된 경우 대상 이미지의 파일 좌표.
<3> 대상 이미지와 현재 페이지가 패밀리 상대 디렉토리 경로가 동일한 하위 디렉토리에 저장된 경우 대상 이미지의 파일 좌표. 이것은 고급 사용 사례입니다.
다음 섹션에서는 다양한 파일 좌표 구조를 보여주는 예제를 제공합니다.

==== 이미지 디렉토리 루트의 파일 좌표

대상 이미지가 이미지 패밀리 디렉토리의 루트에 저장되면 파일 좌표는 대상 이미지의 파일 이름과 파일 확장자입니다. 대상 이미지의 파일 좌표는 항상 이미지 패밀리 디렉토리의 루트에서 계산된다는 점을 기억하세요.

.예제 2. 대상 이미지가 이미지 디렉토리의 루트에 저장된 경우 이미지 매크로의 파일 좌표
[source,asciidoc]
----
image::target-image-filename.ext[optional attribute]
----

이 섹션의 예제에 대한 기준으로 컴포넌트 버전 __colorado 5.2__에 속하는 파일을 사용해 보겠습니다. 컴포넌트 버전의 소스 파일은 예제 3에 나열된 표준 디렉토리 세트를 기준으로 모듈과 패밀리에 할당됩니다.

.예제 3. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 la-garita <2>
    📂 images <3>
      📄 wilderness-map.jpg
    📂 pages <4>
      📄 ridge.adoc
----
<1> 컴포넌트 버전을 __colorado 5.2__로 정의합니다.
<2> __la-garita__라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 이미지로 정의합니다.
<4> 후속 파일을 페이지로 정의합니다.

위의 예제 3에 표시된 __la-garita__ 모듈에 속하는 두 파일을 사용하여 __wilderness-map.jpg__ 이미지를 __ridge.adoc__ 페이지에 삽입해 보겠습니다. 즉, 소스 파일 __wilderness-map.jpg__는 대상 이미지이고 __ridge.adoc__는 현재 페이지입니다.

예제 4는 __ridge.adoc__ 페이지(현재 페이지)에서 __wilderness-map.jpg__ 이미지(대상 이미지)를 참조하는 블록 이미지 매크로를 보여줍니다. 대상 이미지와 현재 페이지가 동일한 모듈에 속할 때는 대상 이미지의 리소스 ID의 파일 좌표만 이미지 매크로에 입력하면 됩니다.

.예제 4. ridge.adoc (현재 페이지)
[source,asciidoc]
----
The trailhead is north of town.

image::wilderness-map.jpg[]
----

예제 4에서 __wilderness-map.jpg__ 이미지의 파일 좌표는 __wilderness-map.jpg__입니다. __wilderness-map.jpg__가 이미지 디렉토리의 루트에 저장되어 있기 때문에 파일 좌표는 파일 이름과 파일 확장자로만 구성됩니다.

대상 이미지가 이미지 디렉토리의 하위 디렉토리에 저장된 경우 파일 좌표에는 이미지 상대 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다. 대상 이미지가 하위 디렉토리에 저장된 경우의 파일 좌표 예제는 이미지 상대 디렉토리 경로가 있는 파일 좌표를 참조하세요.

==== 이미지 상대 디렉토리 경로가 있는 파일 좌표

대상 이미지가 이미지 디렉토리의 하위 디렉토리에 저장된 경우 파일 좌표에 대상 이미지의 이미지 상대 디렉토리 경로가 필요합니다.

.예제 5. 대상 이미지가 이미지 디렉토리의 하위 디렉토리에 저장된 경우 이미지 매크로의 파일 좌표
[source,asciidoc]
----
image::path/to/target-image-filename.ext[optional attribute]
----

이 섹션의 예제에 대한 기준으로 예제 6에 표시된 컴포넌트 버전에 속하는 페이지를 사용해 보겠습니다.

.예제 6. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 la-garita <2>
    📂 images <3>
      📂 aerial <4>
        📄 skyline.jpg
    📂 pages <5>
      📄 ridge.adoc
----
<1> 컴포넌트 버전을 __colorado 5.2__로 정의합니다.
<2> __la-garita__라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 이미지로 정의합니다.
<4> 이미지의 소스 파일이 포함된 이미지의 하위 디렉토리
<5> 후속 파일을 페이지로 정의합니다.

__ridge.adoc__에서 __skyline.jpg__를 참조해 보겠습니다. 위의 예제 6에서 볼 수 있듯이 이미지와 페이지는 __la-garita__ 모듈에 속합니다. 예제 7에서는 __ridge.adoc__ 페이지(현재 페이지)의 이미지 매크로가 __skyline.jpg__ 이미지(대상 이미지)를 참조합니다.

.예제 7. ridge.adoc (현재 페이지)
[source,asciidoc]
----
= La Garita Ridgeline

image::aerial/skyline.jpg[]
----

예제 7에서 볼 수 있듯이 __skyline.jpg__의 파일 좌표는 __aerial/skyline.jpg__입니다. __skyline.jpg__의 파일 좌표는 aerial 하위 디렉토리에 저장되어 있기 때문에 이미지 상대 디렉토리 경로, 파일 이름 및 파일 확장자로 구성됩니다.

TIP: 대상 이미지의 이미지 상대 디렉토리 경로와 현재 페이지의 페이지 상대 디렉토리 경로가 병렬인 특별한 상황에서는 파일 좌표의 이미지 상대 디렉토리 경로를 상대 경로 토큰 ./로 대체할 수 있습니다.

=== 다른 모듈의 이미지 사용

대상 이미지와 현재 페이지가 동일한 모듈에 속하지 않는 경우 이미지 매크로에 대상 이미지의 모듈 좌표와 파일 좌표를 지정해야 합니다.

.예제 8. 이미지 매크로에 할당된 모듈 및 파일 좌표
[source,asciidoc]
----
image:module:target-image-filename.ext[optional attribute] <1>

image:module:path/to/target-image-filename.ext[optional attribute] <2>
----
<1> 대상 이미지가 현재 페이지와 동일한 모듈에 속하지 않을 때 이미지 매크로에 대상 이미지의 모듈 좌표와 파일 좌표가 할당됩니다. 대상 이미지가 이미지 패밀리 디렉토리의 루트에 저장된 경우 대상 이미지의 파일 좌표는 파일 이름과 파일 확장자입니다.
<2> 대상 이미지가 이미지 디렉토리의 하위 디렉토리에 저장된 경우 대상 이미지의 파일 좌표에는 이미지 상대 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다.

이 섹션의 예제에 대한 기준으로 예제 9에 표시된 컴포넌트 버전에 속하는 파일을 사용해 보겠습니다.

.예제 9. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 la-garita <2> 
    📂 images <3>
      📂 aerial <4>
        📄 skyline.jpg
    📂 pages <5>
      📄 ridge.adoc
      📄 willow-creek.adoc
  📂 ROOT <6>
    📂 images <7>
      📄 peak.svg
    📂 pages <8>
      📄 index.adoc
      📄 ranges.adoc
----
<1> 컴포넌트 버전을 colorado 5.2로 정의합니다.
<2> la-garita라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 이미지로 정의합니다.
<4> 이미지의 소스 파일이 포함된 이미지의 하위 디렉토리
<5> 후속 파일을 페이지로 정의합니다.
<6> ROOT 모듈을 정의합니다.
<7> 후속 파일을 이미지로 정의합니다.
<8> 후속 파일을 페이지로 정의합니다.

위의 예제 9에 표시된 __colorado 5.2__ 컴포넌트 버전에서 __peak.svg__ 이미지를 __willow-creek.adoc__ 페이지에 삽입해 보겠습니다. 즉, 소스 파일 __peak.svg__는 대상 이미지이고 __willow-creek.adoc__는 현재 페이지입니다.

예제 10은 __willow-creek.adoc__(현재 페이지)에서 이미지 파일 __peak.svg__(대상 이미지)를 참조하는 인라인 이미지 매크로를 보여줍니다. 대상 이미지의 리소스 ID의 모듈 및 파일 좌표가 이미지 매크로에 할당됩니다. __willow-creek.adoc__ 페이지는 __la-garita__ 모듈에 속합니다. __peak.svg__ 이미지는 __ROOT__ 모듈에 속합니다.

.예제 10. peak.svg(대상 이미지)를 willow-creek.adoc(현재 페이지)에 삽입
[source,asciidoc]
----
The elevation is image:ROOT:peak.svg[] 10,067 ft (3,068 m).
----

예제 10에서 볼 수 있듯이 대상 이미지의 모듈 좌표는 __ROOT__이고 파일 좌표는 __peak.svg__입니다.

예제 11에서는 __skyline.jpg__ 이미지(대상 이미지)를 __ranges.adoc__(현재 페이지)에 포함해 보겠습니다. __skyline.jpg__ 이미지는 __la-garita__ 모듈에 속하고 __ranges.adoc__은 __ROOT__ 모듈에 속합니다.

.예제 11. skyline.jpg(대상 이미지)를 ranges.adoc(현재 페이지)에 삽입
[source,asciidoc]
----
image::la-garita:aerial/skyline.jpg[]
----

예제 11에서 볼 수 있듯이 대상 이미지의 모듈 좌표는 __la-garita__이고 파일 좌표는 __aerial/skyline.jpg__입니다. 이미지 패밀리 디렉토리의 __aerial__ 하위 디렉토리에 저장되어 있기 때문입니다.

=== 다른 문서 컴포넌트의 이미지 사용

대상 이미지와 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우 이미지 매크로에 최소한 대상 이미지의 컴포넌트, 모듈 및 파일 좌표를 지정해야 합니다. 대부분의 경우 버전 좌표도 지정합니다.

.예제 12. 이미지 매크로에 할당된 버전, 컴포넌트, 모듈 및 파일 좌표
[source,asciidoc]
----
image:version@component:module:target-image-filename.ext[optional attribute] <1>

image:version@component:module:path/to/target-image-filename.ext[optional attribute] <2>

image:component:module:file-coordinate-of-target-image.ext[optional attribute] <3>
----
<1> 대상 이미지와 현재 페이지가 동일한 컴포넌트 버전에 속하지 않을 때 이미지 매크로에 대상 이미지의 버전, 컴포넌트, 모듈 및 파일 좌표가 할당됩니다. 대상 이미지가 이미지 패밀리 디렉토리의 루트에 저장된 경우 대상 이미지의 파일 좌표는 파일 이름과 파일 확장자입니다.
<2> 대상 이미지가 이미지 디렉토리의 하위 디렉토리에 저장된 경우 대상 이미지의 파일 좌표에는 이미지 상대 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다.
<3> 버전 좌표가 지정되지 않은 경우 Antora는 런타임에 대상 이미지의 컴포넌트 최신 버전을 사용하여 리소스 ID를 완성합니다. 이 동작은 대상 이미지와 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우에만 적용됩니다.

이 섹션의 예제에 대한 기준으로 컴포넌트 버전 __colorado 5.2__(예제 13)와 __wyoming 1.0__(예제 14)에 속하는 파일을 사용해 보겠습니다.

.예제 13. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 ROOT <2>
    📂 images <3> 
      📄 peak.svg
    📂 pages <4>
      📄 index.adoc
      📄 ranges.adoc
----
<1> 컴포넌트 버전을 colorado 5.2로 정의합니다.
<2> ROOT 모듈을 정의합니다.
<3> 후속 파일을 이미지로 정의합니다.
<4> 후속 소스 파일을 페이지로 정의합니다.

.예제 14. wyoming 1.0에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 sierra-madre <2>
    📂 images <3>
      📄 panorama.png
    📂 pages <4>
      📄 elevation.adoc
      📄 wilderness-areas.adoc
----
<1> 컴포넌트 버전을 __wyoming 1.0__으로 정의합니다.
<2> __sierra-madre__라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 이미지로 정의합니다.
<4> 후속 파일을 페이지로 정의합니다.

예제 13과 예제 14의 파일을 사용하여 __panorama.png__(대상 이미지)를 __ranges.adoc__(현재 페이지)에 삽입해 보겠습니다. __panorama.png__ 이미지는 __wyoming 1.0__의 __sierra-madre__모듈에 속합니다. 예제 15에서는 대상 이미지가 __wyoming 1.0__ 컴포넌트 버전에 속하는 반면 현재 페이지는 __colorado 5.2__에 속하므로 이미지 매크로에 할당된 리소스 ID는 대상 이미지의 버전, 컴포넌트, 모듈 및 파일 좌표를 지정합니다.

.예제 15. panorama.png(대상 이미지)를 ranges.adoc(현재 페이지)에 블록 이미지로 삽입

[source,asciidoc]
----
image::1.0@wyoming:sierra-madre:panorama.png[]
----

예제 15에서 볼 수 있듯이 대상 이미지의 버전 좌표는 1.0, 컴포넌트 좌표는 wyoming, 모듈 좌표는 sierra-madre, 파일 좌표는 panorama.png입니다.

이제 예제 16에서는 __peak.svg__(대상 이미지)를 __wilderness-areas.adoc__(현재 페이지)에 삽입해 보겠습니다. __peak.svg__ 이미지는 컴포넌트 버전 __colorado 5.2__에 속합니다. __wilderness-areas.adoc__ 페이지는 컴포넌트 버전 __wyoming 1.0__에 속합니다.

.예제 16. wilderness-areas.adoc (현재 페이지)
[source,asciidoc]
----
image:5.2@colorado::peak.svg[] Bridger Peak is in the Sierra Madre range.
----

예제 16에서 모듈 좌표 ROOT가 리소스 ID에서 누락된 것 같다는 점에 주목하세요. 리소스 ID에 컴포넌트 좌표가 지정되고 대상 이미지가 ROOT 모듈에 속하는 경우 모듈 좌표 ROOT를 명시적으로 지정할 필요가 없습니다. 그러나 모듈 좌표 뒤에 오는 콜론(:)은 여전히 입력해야 합니다. 파일 좌표 peak.svg 바로 앞에 이 :가 있는 것을 볼 수 있습니다. 이 단축 표기법은 컴포넌트 좌표가 지정되고 대상 이미지의 모듈 좌표가 ROOT인 경우에만 작동합니다. 모듈 좌표가 필요한 다른 모든 경우에는 모듈의 이름을 지정해야 합니다.

예제 15와 예제 16 모두에서 버전 좌표가 지정되었다는 점을 알아차렸을 것입니다. 버전을 지정하지 않으면 Antora는 런타임에 대상 이미지의 최신 컴포넌트 버전의 버전 좌표를 사용하여 대상 이미지의 리소스 ID를 완성합니다.

==== 이미지의 최신 버전 사용

TIP: 이 동작은 대상 이미지와 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우에만 적용됩니다!

리소스 ID에 버전이 지정되지 않고 **대상 이미지와 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우** Antora는 런타임에 대상 이미지의 컴포넌트 최신 버전의 버전 좌표를 사용하여 리소스 ID를 완성합니다.

이 섹션의 예제에 대한 기준으로 __colorado 5.2__(이전 섹션의 예제 13), __wyoming 1.0__(이전 섹션의 예제 14) 및 __wyoming 1.5__(아래의 예제 17)에 속하는 파일을 사용해 보겠습니다.

.예제 17. wyoming 1.5에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 sierra-madre
    📂 images
      📄 panorama.png
    📂 pages
      📄 elevation.adoc
      📄 wilderness-areas.adoc
----
<1> 컴포넌트 버전을 __wyoming 1.5__로 정의합니다.

__index.adoc__(현재 페이지)에서 __panorama.png__ 이미지(대상 이미지)를 참조해 보겠습니다. __index.adoc__은 __colorado 5.2__ 컴포넌트 버전에 속합니다. __wyoming__ 컴포넌트, __sierra-madre__ 모듈 및 이미지 패밀리에 속하는 __panorama.png__ 파일은 두 개가 있습니다. 하나의 __panorama.png__는 버전 1.0에 속하고 다른 __panorama.png__는 버전 1.5에 속합니다.

예제 18은 __index.adoc__(현재 페이지)에서 __panorama.png__(대상 이미지)를 참조하는 블록 이미지 매크로를 보여줍니다. 대상 이미지의 버전 좌표가 지정되지 않았다는 점에 주목하세요.

.예제 18. index.adoc (현재 페이지)
[source,asciidoc]
----
image::wyoming:sierra-madre:panorama.png[]
----

Antora가 실행되면 버전 정렬 규칙과 최신 버전 기준에 따라 __wyoming 1.5__를 __wyoming__ 컴포넌트의 최신 버전으로 식별합니다. 예제 18에 버전 좌표가 지정되지 않았기 때문에 Antora는 최신 __wyoming__ 컴포넌트의 버전 좌표(1.5)를 사용하여 이미지 매크로에 할당된 리소스 ID를 완성합니다.

WARNING: 이 최신 버전으로 연결하는 동작은 버전 좌표가 지정되지 않고 대상 이미지와 현재 페이지가 서로 다른 컴포넌트에 속하는 경우에만 적용됩니다. 리소스 ID에 버전 및 컴포넌트 좌표가 지정되지 않은 경우 Antora는 대상 이미지가 현재 페이지와 동일한 컴포넌트 버전에 속한다고 가정하고 현재 페이지의 버전 및 컴포넌트 좌표를 사용하여 대상 이미지의 리소스 ID를 완성합니다.

=== 컴포넌트의 다른 버전에서 이미지 사용

현재 페이지와 대상 이미지가 동일한 컴포넌트에 속하지만 대상 이미지가 컴포넌트의 다른 버전에 속하는 경우 버전, 모듈(현재 페이지의 모듈과 다른 경우) 및 파일 좌표를 지정합니다.

.예제 19. current-page.adoc
[source,asciidoc]
----
image:version@module:file-coordinate-of-target-image.ext[optional attribute] <1>

image:version@file-coordinate-of-target-image.ext[optional attribute] <2>
----
<1> 대상 이미지가 현재 페이지와 동일한 버전과 모듈에 속하지 않을 때 이미지 매크로에 대상 이미지의 버전, 모듈 및 파일 좌표가 할당됩니다.
<2> 대상 이미지가 현재 페이지와 동일한 버전에 속하지 않을 때 이미지 매크로에 대상 이미지의 버전 및 파일 좌표가 할당됩니다.
이 섹션의 예제에 대한 기준으로 컴포넌트 버전 __colorado 5.2__(예제 20)와 컴포넌트 버전 __colorado 6.0__(예제 21)에 속하는 파일을 사용해 보겠습니다.

.예제 20. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 la-garita
    📂 images
      📄 wilderness-map.jpg
    📂 pages
      📄 index.adoc
      ...
----
<1> 컴포넌트 버전을 __colorado 5.2__로 정의합니다.

.예제 21. colorado 6.0에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
  📂 la-garita
    📂 pages
      📄 index.adoc
      📄 ridge.adoc
      📄 willow-creek.adoc
----
<1> 컴포넌트 버전을 __colorado 6.0__으로 정의합니다.

예제 20의 __colorado 5.2__ 컴포넌트 버전에는 이미지 __wilderness-map.jpg__가 있습니다. 그러나 예제 21에 표시된 __colorado 6.0__에는 그러한 이미지 파일이 없습니다.

__colorado 5.2__에 속하는 이미지 __wilderness-map.jpg__(대상 이미지)를 __colorado 6.0__ 컴포넌트 버전에 속하는 __ridge.adoc__ 페이지(현재 페이지)에서 참조해 보겠습니다. 두 리소스 모두 __la-garita__ 모듈에 속합니다. 예제 22에서는 이미지 __wilderness-map.jpg__(대상 이미지)가 페이지 __ridge.adoc__(현재 페이지)에 포함되어 있습니다.

.예제 22. ridge.adoc (현재 페이지) in colorado 6.0
[source,asciidoc]
----
image::5.2@wilderness-map.jpg[]
----

예제 22에서 볼 수 있듯이 대상 이미지의 버전 좌표는 5.2이고 파일 좌표는 wilderness-map.jpg입니다.



== Images - Resource Links From Images

=== 이미지에서 리소스로 링크 생성

xref 속성을 인라인 또는 블록 이미지 매크로에 할당하여 이미지에서 페이지, 첨부 파일, 이미지 또는 요소로 연결되는 링크를 만들 수 있습니다.

=== Xref 요소 속성

xref 요소 속성은 블록 및 인라인 이미지 매크로의 속성 목록에 설정할 수 있습니다. xref 속성은 선택 사항입니다. 블록 이미지 매크로 또는 인라인 이미지 매크로에 할당하는지 여부에 관계없이 구조와 동작 방식이 동일합니다.

xref 속성은 게시 가능한 리소스(페이지, 첨부 파일 또는 이미지)의 리소스 ID를 값으로 받아들입니다.

.예제 1. xref 속성 설정 및 리소스 ID 할당 [source,asciidoc]
image::an-image.jpg[xref=version@component:module:family$file.ext]
또한 현재 페이지에 지정된 요소의 ID를 받아들입니다. xref 속성에 할당할 때는 요소 ID 앞에 해시 기호(#)를 붙여야 합니다.

.예제 2. xref 속성 설정 및 요소 ID 할당 [source,asciidoc]
image::an-image.gif[xref=#fragment]
사이트가 게시되고 방문자가 포함된 이미지를 선택하면 게시된 리소스의 URL 또는 지정된 요소 ID에 해당하는 현재 게시된 페이지의 앵커로 연결됩니다.

xref 속성은 명명된 속성입니다. 이미지 매크로에 alt 텍스트, 너비 또는 높이와 같은 위치 속성을 설정하는 경우 xref 또는 기타 명명된 속성을 설정하기 전에 속성 목록에서 이를 할당하세요.

.예제 3. 이미지 매크로에 할당된 선택적 위치 및 명명된 속성 [source,asciidoc]
image:an-image.svg[The image alt text,xref=version@component:module:family$file.ext,title="A tooltip for the image"]
위치 및 명명된 요소 속성은 이미지 매크로의 속성 목록에서 쉼표로 구분됩니다.

=== 이미지에서 페이지로 링크

포함된 이미지에서 페이지를 참조하려면 속성 목록에서 xref 속성을 설정한 다음 등호(=)를 입력하고 대상 페이지의 리소스 ID를 입력하세요. 현재 페이지와 관련하여 대상 페이지의 컴포넌트 버전 및 모듈에 따라 대상 페이지의 리소스 ID 좌표를 얼마나 많이 지정해야 하는지가 결정됩니다.

.예제 4. current-page.adoc [source,asciidoc]
image::console.svg[xref=modes.adoc] <1>
<1> 이 예제에서는 현재 페이지와 대상 페이지가 동일한 컴포넌트 버전과 모듈에 속한다고 가정하므로 xref에 할당된 리소스 ID는 페이지의 파일 좌표만 지정합니다.

예제 4에 표시된 블록 이미지 매크로는 이미지 console.svg를 현재 페이지에 포함하고 이미지에서 대상 페이지의 게시된 URL로 연결되는 링크를 만듭니다.

페이지의 리소스 ID 끝에 프래그먼트를 추가하여 페이지 내의 요소에 연결할 수도 있습니다. 예제 5에서는 modes.adoc의 내용에 설정된 요소 ID protocols에 해당하는 프래그먼트가 modes.adoc의 리소스 ID 끝에 추가되어 있습니다.

.예제 5. current-page.adoc [source,asciidoc]
image::console.svg[xref=modes.adoc#protocols]
현재 페이지의 요소 ID에 연결할 수도 있습니다.

=== 이미지에서 첨부 파일로 링크

포함된 이미지에서 첨부 파일을 참조하려면 속성 목록에서 xref 속성을 설정한 다음 등호(=)를 입력하고 대상 첨부 파일의 리소스 ID를 입력하세요. xref 속성에 할당된 값에 패밀리 좌표 attachment$가 지정되었는지 확인하세요.

예제 6은 매크로의 속성 목록에 세 개의 위치 속성이 설정된 인라인 이미지 매크로와 명명된 xref 속성을 보여줍니다. xref 속성에는 첨부 파일의 리소스 ID가 할당됩니다.

.예제 6. current-page.adoc [source,asciidoc]
Select the image:red-dot.jpg[Red circle,40,40,xref=telemetry:attachment$flight-patterns.pdf]. <1>
<1> 위치 속성은 선택 사항입니다. 이미지 매크로에 하나 이상의 위치 속성을 설정하는 경우 xref 또는 기타 명명된 속성을 설정하기 전에 속성 목록에서 이를 할당하세요. 이 예제에서는 위치 속성 alt, width 및 height가 이미지 매크로에서 허용하는 순서대로 설정됩니다.

이 예제에서는 대상 첨부 파일이 현재 페이지와 다른 모듈에 속한다고 가정하므로 xref에 할당된 리소스 ID는 대상 첨부 파일의 모듈, attachment$ 및 파일 좌표를 지정합니다. 리소스가 첨부 파일인 경우에는 항상 attachment$ 좌표가 필요합니다.

예제 6에 표시된 인라인 이미지 매크로는 이미지 red-dot.jpg를 현재 페이지에 포함하고 이미지에서 대상 첨부 파일의 게시된 URL로 연결되는 링크를 만듭니다.

=== 이미지에서 현재 페이지의 요소로 딥 링크

현재 페이지의 요소를 참조하려면 요소의 ID를 xref 속성에 할당하세요. xref 속성에 할당할 때는 요소 ID 앞에 해시 기호(#)를 붙이세요. 예제 7은 xref 속성에 현재 페이지의 ID에 해당하는 요소 ID가 할당된 블록 이미지 매크로를 보여줍니다.

.예제 7. current-page.adoc [source,asciidoc]
image::panorama.png[xref=#elevation] <1>

The range can be traversed by Cottonwood Pass, Independence Pass, or Hagerman Pass.

[#elevation] <2>
== Pass elevations

The passes usually open in late spring.
<1> 속성 목록에서 xref 속성을 설정한 다음 등호(=), 해시 기호(#)를 입력하고 현재 페이지의 요소에 할당된 ID에 해당하는 요소 ID를 입력하세요.
<2> 현재 페이지의 섹션에 설정되고 할당된 요소 ID.

예제 7에 표시된 블록 이미지 매크로는 이미지 panorama.png를 현재 페이지에 포함하고 이미지에서 현재 페이지의 Pass elevations 섹션의 시작 부분으로 연결되는 링크를 만듭니다.

=== 원본 크기로 열기 위해 이미지 자체에 연결

이미지를 원본 크기로 제한 없이 열 수 있게 하려면(html 출력에서) link=self 속성을 추가하세요.

[source,asciidoc]
image::panorama.png[link=self]
=== 더 알아보기

추가 이미지 매크로 속성과 요소 ID에 대한 자세한 내용은 AsciiDoc 문서를 참조하세요.



== Partials

=== 재사용 가능한 단일 소스 콘텐츠

Partials는 사이트 전체에서 하나 이상의 페이지에서 재사용하는 공통 설명, 프로젝트 소개, 용어, 자주 사용되는 경고 및 참조 테이블과 같은 콘텐츠 스니펫을 저장하는 데 적합합니다. Partial을 변경하면 다음에 사이트를 빌드할 때 Partial을 참조한 모든 페이지에 변경 사항이 전파됩니다.

=== Partial 파일 이름 및 파일 확장자

Partial 파일은 partials 디렉토리에 저장됩니다. Partial 파일은 일반적으로 AsciiDoc으로 마크업되어 .adoc 파일 확장자로 저장됩니다. 그러나 Partial은 AsciiDoc 파일일 필요는 없으며, 게시 가능한 리소스와 달리 파일 확장자가 없는 Partial 파일은 숨겨진 파일로 취급되지 않습니다. Antora는 파일 확장자가 없는 Partial을 콘텐츠 카탈로그에 로드하고 참조를 위해 Partial에 리소스 ID를 할당합니다.

새 Partial 파일을 저장할 때 다음 파일 이름 요구 사항과 권장 사항을 염두에 두세요:

- Partial의 파일 이름에는 공백이 포함될 수 없습니다. AsciiDoc include 지시어는 공백이 있는 값을 허용하지 않기 때문입니다.
- 파일 이름에는 대문자를 사용하지 않는 것이 좋습니다. 일부 파일 시스템은 대소문자를 구분하지 않습니다. 따라서 작성자가 사용하는 파일 시스템에 따라 파일 충돌이 발생할 수 있습니다.
- AsciiDoc 파일인 경우 .adoc 확장자로 Partial 파일을 저장하고, 그렇지 않으면 해당 파일 유형에 유효한 파일 확장자를 사용하세요. 특정 파일 유형에 확장자가 없는 것이 일반적인 업계 관행인 경우에만 파일 확장자 없이 Partial을 저장해야 합니다. Partial 파일을 저장할 때 올바른 파일 확장자를 사용하지 않으면 일부 Antora 확장을 적용하거나 향후 기능으로 업그레이드하는 기능이 제한될 수 있습니다.

Antora는 Partial 파일을 개별 사이트 페이지로 게시하지 않습니다. Partial의 내용을 게시하려면 페이지 또는 결국 페이지에 포함되는 리소스에서 include 지시어로 Partial을 참조해야 합니다.

=== Partial 파일 만들기

Partial은 일반적으로 AsciiDoc으로 마크업된 일반 콘텐츠입니다. 페이지와 달리 Partial에는 제목과 같은 필수 구조 요소가 없지만 그러한 요소를 포함할 수 있습니다. 다음 섹션에서는 새 Partial 파일을 만들고 AsciiDoc으로 마크업하는 방법을 살펴보겠습니다.

==== AsciiDoc Partial 파일 설정

. IDE 또는 일반 텍스트 편집기에서 새 파일을 엽니다.
. 파일의 첫 번째 줄에 단락 텍스트, 표 또는 속성 항목과 같은 내용을 입력합니다. 이 예제에서는 사이트 전체의 여러 페이지에서 사용될 경고를 만들어 보겠습니다.

[source,asciidoc]
----
[WARNING]
====
High, open places above the treeline are awe-inspiring--
but you need to be prepared for the altitude and
rapidly changing weather conditions.
====
----

[start=3]
. 내용 생성을 완료한 후 partials 디렉토리에 .adoc 확장자로 파일을 저장합니다.

[source]
----
📂 modules
  📂 ROOT
    📂 pages
      📄 a-source-file.adoc
    📂 partials
      📄 treeline-warning.adoc
----

Partial을 만들었습니다! 이제 페이지에 포함될 준비가 되었습니다. Partial이 속한 컴포넌트 버전에 관계없이 Partial의 리소스 ID와 AsciiDoc include 지시어를 사용하여 사이트의 모든 페이지 또는 Partial에서 참조할 수 있습니다. include 지시어의 tag, tags 또는 lines 속성을 사용하여 Partial의 모든 내용 대신 Partial에서 영역 또는 행을 선택하고 해당 영역 또는 행만 삽입할 수도 있습니다.

=== 현재 페이지 컨텍스트 및 구조

Partial에서 내용을 만들 때 현재 페이지의 컨텍스트 및 구조에 따라 조정해야 할 수 있는 특정 AsciiDoc 요소가 있습니다. Partial은 페이지에 삽입된 후 변환됩니다. 따라서 현재 페이지의 컴포넌트 버전, 모듈, 속성 및 기타 요소가 포함된 내용에 적용되고 영향을 미칠 수 있습니다.

==== 페이지 및 리소스 참조

===== Xrefs

Partial이 다른 모듈이나 문서 컴포넌트에 속하는 페이지에 포함되는 경우 Partial의 내용에서 xref 매크로에 할당된 대상 페이지 또는 첨부 파일의 리소스 ID를 적절히 지정해야 합니다. 필요한 리소스 ID 좌표의 수는 Partial이 삽입되는 현재 페이지의 컴포넌트 버전 및 모듈과 Partial의 내용에서 xref 매크로로 참조되는 대상 첨부 파일 또는 페이지에 따라 달라집니다.

===== 이미지, 예제 및 기타 Partials

Partial은 include 지시어를 사용하여 다른 Partial 및 예제를 참조하고 이미지 매크로를 사용하여 이미지를 참조할 수 있습니다. xref에 리소스 ID를 입력할 때와 마찬가지로 Partial이 포함되는 현재 페이지의 컴포넌트 버전 및 모듈과 Partial에서 참조되는 리소스에 따라 대상 리소스의 리소스 ID에 추가 좌표를 지정해야 할 수 있습니다.

===== 섹션 제목

Partial에는 섹션 제목이 포함될 수 있습니다. 현재 페이지에서 참조 include 지시어를 입력하는 위치에 따라 leveloffset 속성을 사용하여 Partial의 제목 수준을 조정해야 할 수 있습니다.

===== 인라인, 블록 및 섹션 ID

Partial의 요소 ID는 삽입되는 페이지의 요소 ID와 충돌할 수 없습니다.

==== 속성

속성은 Partial에서 설정, 할당 및 참조할 수 있습니다. Partial에서 속성이 참조되는 경우 Partial, 현재 페이지 또는 현재 페이지의 컴포넌트 버전 설명자에서 속성에 값을 설정하고 할당해야 합니다.

Partial에서 속성이 설정되고 값이 할당되면 Partial이 포함된 지점부터 현재 페이지에서 속성을 사용할 수 있습니다. 이러한 경우 Partial의 속성은 현재 페이지의 헤더에서 설정 또는 설정 해제되거나 현재 페이지의 컴포넌트 버전 설명자에서 소프트 설정 또는 설정 해제된 동일한 이름의 속성을 재정의합니다.



== Partials - Include a Partial

=== include 지시어를 사용하여 Partial 내용 삽입

AsciiDoc include 지시어와 Partial의 리소스 ID를 사용하여 Partial을 사이트의 모든 페이지 또는 다른 Partial에 삽입할 수 있습니다.

[NOTE]
====
Antora 리소스 ID와 그 좌표에 익숙하지 않은 경우 다음을 참조하세요:

- 리소스 및 리소스 ID 
- 리소스 ID 좌표
====

=== Partials용 AsciiDoc include 지시어

AsciiDoc include 지시어는 Partial의 소스 파일에서 다른 Partial 또는 페이지로 내용을 삽입합니다. include 지시어는 Partials, 예제 및 페이지의 Antora 리소스 ID를 값으로 받아들입니다.

Partial은 일반적으로 AsciiDoc 조각이지만 Partial은 파일 확장자에 제한이 없는 모든 텍스트 문서일 수 있습니다. Partial이 AsciiDoc이 아닌 경우 다이어그램 블록, 코드 블록 또는 CSV 테이블과 같이 AsciiDoc이 아닌 내용을 허용하는 AsciiDoc 문서의 위치에 삽입해야 합니다. Partial이 코드 예제인 경우 예제가 특수한 형태의 Partial이므로 Partial이 아닌 예제로 저장하는 것이 좋습니다. 이 페이지는 AsciiDoc 파일인 Partials에 중점을 둡니다.

예제 1은 Partial의 완전한 리소스 ID가 포함된 include 지시어의 구조를 보여줍니다. include 지시어는 다른 리소스를 참조하는 데 사용되므로 Partial의 리소스 ID가 include 지시어에 할당될 때 partial$ 패밀리 좌표를 지정해야 합니다.

.예제 1. Partial의 완전한 리소스 ID가 할당된 include 지시어
[source,asciidoc]
----
\include::version@component:module:partial$file-coordinate-of-target-partial.adoc[optional attribute]
----

최소한 include 지시어는 지시어의 접두사(include::), 대상 Partial의 리소스 ID 및 대괄호([])로 구성됩니다. 대괄호 내에 쉼표로 구분된 키-값 쌍으로 선택적 속성을 지정할 수 있습니다. 대상 Partial은 현재 페이지에서 참조하는 Partial의 소스 파일입니다. 대상 Partial은 현재 페이지의 내용에서 include 지시어에 리소스 ID를 할당하여 참조됩니다. 현재 페이지는 대상 Partial을 참조하는 include 지시어를 포함하는 페이지 소스 파일입니다.

Antora가 실행되면 대상 Partial의 내용이 include 지시어가 입력된 위치에 현재 페이지에 삽입됩니다. 대상 Partial의 내용은 현재 페이지에 삽입된 후 변환됩니다. 즉, 현재 페이지의 컴포넌트 버전, 모듈, 속성 및 기타 요소가 대상 Partial에서 포함된 내용에 적용되거나 영향을 줄 수 있습니다. 자세한 내용은 현재 페이지 컨텍스트 및 구조를 참조하세요.

=== 페이지에 Partial 삽입

대상 Partial을 현재 페이지에 삽입하는 데 필요한 AsciiDoc include 지시어와 리소스 ID 좌표를 분석해 보겠습니다.

. IDE 또는 일반 텍스트 편집기에서 Partial을 삽입할 페이지를 엽니다. 이 단계와 후속 단계에서는 ranges.adoc 파일을 열었다고 가정해 보겠습니다.

.예제 2. ranges.adoc (현재 페이지)
[source,asciidoc]
----
= Hike the Ranges
== Terrain
Above the treeline, the trail becomes a hard scramble.
----

현재 페이지인 ranges.adoc는 예제 3에 표시된 대로 컴포넌트 버전 colorado 5.2와 모듈 ROOT에 속합니다.

.예제 3. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 pages <3>
📄 index.adoc
📄 ranges.adoc
📂 partials <4>
📄 treeline-warning.adoc
----

<1> 컴포넌트 버전을 colorado 5.2로 정의합니다.
<2> ROOT 모듈을 정의합니다.
<3> 후속 파일을 페이지로 정의합니다.
<4> 후속 파일을 Partials로 정의합니다.
. 현재 페이지에서 Partial의 내용을 삽입할 행을 선택합니다. 행의 시작 부분에 지시어 이름 다음에 두 개의 콜론을 입력합니다(include::).

.예제 4. ranges.adoc (현재 페이지)
[source,asciidoc]
----
Above the treeline, the trail becomes a hard scramble.
include::
----
. 현재 페이지에서 대상 Partial인 treeline-warning.adoc를 참조해 보겠습니다. 대상 Partial의 리소스 ID를 include 지시어에 할당합니다. treeline-warning.adoc와 ranges.adoc는 모두 동일한 컴포넌트 버전과 모듈에 속합니다(예제 3 참조). 따라서 대상 Partial의 partial$ 패밀리 좌표와 파일 좌표만 지정하면 됩니다.

.예제 5. ranges.adoc (현재 페이지)
[source,asciidoc]
----
Above the treeline, the trail becomes a hard scramble.
include::partial$treeline-warning.adoc
----
treeline-warning.adoc Partial의 파일 좌표는 treeline-warning.adoc입니다. 대상 Partial의 파일 좌표는 treeline-warning.adoc이 partials 디렉토리의 루트에 저장되어 있기 때문에 파일 이름과 파일 확장자로만 구성됩니다.
기본적으로 include 지시어는 좌표가 지정되지 않은 경우 패밀리 좌표가 page$라고 가정합니다. partial$ 좌표를 사용하는 것을 잊으면 Antora는 Partial을 찾을 수 없어 오류를 보고합니다.
. 대상 Partial의 리소스 ID 바로 뒤에 대괄호([])를 사용하여 지시어를 완성합니다.

.예제 6. ranges.adoc (현재 페이지)
[source,asciidoc]
----
Above the treeline, the trail becomes a hard scramble.
// include::partial$treeline-warning.adoc[]
----
include 지시어의 대괄호에는 lines, tag 또는 tags와 같은 선택적 속성 목록이 포함될 수 있습니다. 속성은 쉼표로 구분된 키-값 쌍으로 입력됩니다. lines, tag 및 tags 구문에 대한 자세한 내용은 AsciiDoc include 지시어 문서를 참조하세요.
이것으로 끝입니다! 대상 Partial을 현재 페이지에 삽입하는 include 지시어를 만들었습니다.
앞의 지침에서는 가장 일반적인 시나리오(대상 Partial과 현재 페이지가 동일한 컴포넌트 버전과 모듈에 속하고 대상 Partial이 partials 폴더의 루트에 저장됨)에서 Partial을 페이지에 삽입하는 방법을 보여주었습니다. 그러나 대상 Partial이 partials 디렉토리의 하위 디렉토리에 저장된 경우 파일 좌표에는 파일 이름과 파일 확장자 외에 partials-relative 디렉토리 경로를 지정해야 합니다.

.예제 7. current-page.adoc
[source,asciidoc]
----
include::partial$target-partial-filename.adoc[] <1>
include::partial$path/to/target-partial-filename.adoc[] <2>
include::partial$./target-partial-filename.adoc[] <3>
----
<1> partials 디렉토리의 루트에 저장된 경우 대상 Partial의 파일 좌표.
<2> partials 디렉토리의 하위 디렉토리에 저장된 경우 대상 Partial의 파일 좌표.
<3> 대상 Partial과 현재 페이지가 병렬 패밀리 상대 디렉토리 경로를 가진 하위 디렉토리에 저장된 경우 대상 Partial의 파일 좌표. 이것은 고급 사용 사례입니다.
또한 대상 Partial과 현재 페이지가 동일한 모듈 또는 컴포넌트 버전에 속하지 않을 때는 추가 리소스 ID 좌표를 지정해야 합니다. 다음 섹션에서는 다양한 리소스 ID 시나리오를 보여주는 예제를 제공합니다.

==== partials-relative 디렉토리 경로가 있는 파일 좌표

대상 Partial이 partials 디렉토리의 하위 디렉토리에 저장된 경우 파일 좌표에 대상 Partial의 partials-relative 디렉토리 경로가 필요합니다.

.예제 8. 대상 Partial이 partials 디렉토리의 하위 디렉토리에 저장된 경우의 파일 좌표
[source,asciidoc]
----
// include::partial$path/to/target-partial-filename.adoc[optional attribute]
----
이 섹션의 예제에 대한 기준으로 예제 9의 컴포넌트 버전에 속하는 파일을 사용해 보겠습니다.

.예제 9. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 la-garita <2>
📂 pages <3>
📄 ridge.adoc
📂 partials <4>
📂 climate <5>
📄 gear-list.adoc
----

<1> 컴포넌트 버전을 colorado 5.2로 정의합니다.
<2> la-garita라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 페이지로 정의합니다.
<4> 후속 파일을 Partials로 정의합니다.
<5> Partials의 소스 파일이 포함된 partials의 하위 디렉토리

ridge.adoc에서 gear-list.adoc를 참조해 보겠습니다. 위의 예제 9에서 볼 수 있듯이 Partial과 페이지는 la-garita 모듈에 속합니다. 예제 10에서는 ridge.adoc 페이지(현재 페이지)의 include 지시어가 gear-list.adoc 파일(대상 Partial)을 참조합니다.

.예제 10. ridge.adoc (현재 페이지)
[source,asciidoc]
----
== Plan your hike
// include::partial$climate/gear-list.adoc[]
----

예제 10에서 볼 수 있듯이 패밀리 좌표는 partial$이고 gear-list.adoc의 파일 좌표는 climate/gear-list.adoc입니다. gear-list.adoc의 파일 좌표는 climate 하위 디렉토리에 저장되어 있기 때문에 partials-relative 디렉토리 경로, 파일 이름 및 파일 확장자로 구성됩니다.

특별한 상황에서 대상 Partial의 partials-relative 디렉토리 경로와 현재 페이지의 pages-relative 디렉토리 경로가 병렬인 경우 partials-relative 디렉토리 경로를 상대 경로 토큰 ./로 대체할 수 있습니다.

=== 다른 모듈의 Partial 포함

대상 Partial과 현재 페이지가 동일한 모듈에 속하지 않는 경우 include 지시어에 대상 Partial의 모듈, 패밀리 및 파일 좌표를 지정해야 합니다.

.예제 11. include 지시어에 할당된 모듈, 패밀리 및 파일 좌표
[source,asciidoc]
----
include::module:partial$target-partial-filename.adoc[optional attribute] <1>
include::module:partial$path/to/target-partial-filename.adoc[optionalattribute] <2>
----

<1> 대상 Partial과 현재 페이지가 동일한 컴포넌트 버전에 속하지만 동일한 모듈에 속하지 않을 때 include 지시어에 대상 Partial의 모듈, partial$ 및 파일 좌표가 할당됩니다. 대상 Partial이 partials 패밀리 디렉토리의 루트에 저장된 경우 대상 Partial의 파일 좌표는 파일 이름과 파일 확장자입니다.
<2> 대상 Partial이 partials 디렉토리의 하위 디렉토리에 저장된 경우 대상 Partial의 파일 좌표에는 partials-relative 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다.
이 섹션의 예제에 대한 기준으로 예제 12에 표시된 컴포넌트 버전에 속하는 파일을 사용해 보겠습니다.

.예제 12. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 la-garita <2>
📂 pages <3>
📄 ridge.adoc
📂 ROOT <4>
📂 partials <5>
📄 treeline-warning.adoc
----

<1> 컴포넌트 버전을 colorado 5.2로 정의합니다.
<2> la-garita라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 페이지로 정의합니다.
<4> ROOT라는 이름의 모듈을 정의합니다.
<5> 후속 파일을 Partials로 정의합니다.

ridge.adoc 페이지에 treeline-warning.adoc Partial을 삽입해 보겠습니다. 즉, 소스 파일 treeline-warning.adoc은 대상 Partial이고 ridge.adoc은 현재 페이지입니다. 예제 12에서 볼 수 있듯이 ridge.adoc 페이지는 la-garita 모듈에 속하고 treeline-warning.adoc Partial은 ROOT 모듈에 속합니다.

예제 13은 ridge.adoc에서 Partial treeline-warning.adoc을 참조하는 include 지시어를 보여줍니다. 대상 Partial의 모듈, partial$ 및 파일 좌표가 include 지시어에 할당됩니다.

.예제 13. ridge.adoc (현재 페이지)
[source,asciidoc]
----
include::ROOT:partial$treeline-warning.adoc[]
----

예제 13에서 볼 수 있듯이 대상 Partial의 모듈 좌표는 ROOT, 패밀리 좌표는 partial$, 파일 좌표는 treeline-warning.adoc입니다.
=== 다른 컴포넌트의 Partial 포함
대상 Partial과 현재 페이지가 동일한 문서 컴포넌트에 속하지 않는 경우 include 지시어에 할당된 리소스 ID에 Partial의 버전, 컴포넌트, 모듈, 패밀리 및 파일 좌표를 지정하세요.
.예제 14. include 지시어에 할당된 버전, 컴포넌트, 모듈, 패밀리 및 파일 좌표
[source,asciidoc]
----
include::version@component:module:partial$target-partial-filename.adoc[] <1>
include::version@component:module:partial$path/to/target-partial-filename.adoc[] <2>
include::component:module:partial$file-coordinate-of-target-partial.adoc[] <3>
----

<1> 대상 Partial과 현재 페이지가 동일한 컴포넌트 버전에 속하지 않을 때 include 지시어에 대상 Partial의 버전, 컴포넌트, 모듈, 패밀리 및 파일 좌표가 할당됩니다. 대상 Partial이 partials 패밀리 디렉토리의 루트에 저장된 경우 대상 Partial의 파일 좌표는 파일 이름과 파일 확장자입니다.
<2> 대상 Partial이 partials 디렉토리의 하위 디렉토리에 저장된 경우 대상 Partial의 파일 좌표에는 partials-relative 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다.
<3> 버전 좌표가 지정되지 않은 경우 Antora는 런타임에 대상 Partial의 컴포넌트 최신 버전을 사용하여 리소스 ID를 완성합니다. 이 동작은 대상 Partial과 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우에만 적용됩니다.
이 섹션의 예제에 대한 기준으로 컴포넌트 버전 colorado 5.2(예제 15)와 wyoming 1.0(예제 16)에 속하는 파일을 사용해 보겠습니다.

.예제 15. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 pages <3>
📄 index.adoc
📂 partials <4>
📄 treeline-warning.adoc
----
<1> 컴포넌트 버전을 colorado 5.2로 정의합니다.
<2> ROOT 모듈을 정의합니다.
<3> 후속 소스 파일을 페이지로 정의합니다.
<4> 후속 소스 파일을 Partials로 정의합니다.

.예제 16. wyoming 1.0에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 sierra-madre <2>
📂 pages <3>
📄 elevation.adoc
----

<1> 컴포넌트 버전을 wyoming 1.0으로 정의합니다.
<2> sierra-madre라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 페이지로 정의합니다.

예제 15와 예제 16의 파일을 사용하여 elevation.adoc(현재 페이지)에서 treeline-warning.adoc(대상 Partial)을 참조해 보겠습니다. treeline-warning.adoc Partial은 컴포넌트 버전 colorado 5.2에 속합니다. elevation.adoc 페이지는 컴포넌트 버전 wyoming 1.0에 속합니다.
예제 17의 include 지시어는 treeline-warning.adoc Partial의 내용을 elevation.adoc 페이지에 포함합니다.

.예제 17. elevation.adoc (현재 페이지)
[source,asciidoc]
----
// include::5.2@colorado:ROOT:partial$treeline-warning.adoc[]
----
예제 17에서 볼 수 있듯이 대상 Partial의 버전 좌표는 5.2, 컴포넌트 좌표는 colorado, 모듈 좌표는 ROOT, 패밀리 좌표는 partial$, 파일 좌표는 treeline-warning.adoc입니다. treeline-warning.adoc의 리소스 ID를 5.2@colorado::partial$treeline-warning.adoc(모듈 좌표 ROOT가 누락된 것처럼 보임)로 지정할 수도 있습니다. 대상 Partial의 컴포넌트 좌표가 지정되고 대상 Partial이 ROOT 모듈에 속하는 경우 모듈 좌표 ROOT를 명시적으로 지정할 필요가 없습니다. 그러나 모듈 좌표 뒤에 오는 콜론(:)은 여전히 입력해야 합니다. 이 단축 표기법은 컴포넌트 좌표가 지정되고 대상 Partial의 모듈 좌표가 ROOT인 경우에만 작동합니다.

=== Partial의 최신 버전 사용

이 동작은 대상 Partial과 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우에만 적용됩니다!

include 지시어에 할당된 리소스 ID에 버전이 지정되지 않고 대상 Partial과 현재 페이지가 동일한 컴포넌트에 속하지 않는 경우 Antora는 런타임에 대상 Partial의 컴포넌트 최신 버전의 버전 좌표를 사용하여 리소스 ID를 완성합니다.
이 섹션의 예제에 대한 기준으로 컴포넌트 버전 colorado 5.2(예제 18), wyoming 1.0(예제 19) 및 wyoming 1.5(예제 20)에 속하는 파일을 사용해 보겠습니다.

.예제 18. colorado 5.2에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 la-garita
📂 pages
📄 willow-creek.adoc
----
<1> 컴포넌트 버전을 colorado 5.2로 정의합니다.

.예제 19. wyoming 1.0에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 sierra-madre
📂 pages
📄 elevation.adoc
📂 partials
📄 bears.adoc
----
<1> 컴포넌트 버전을 wyoming 1.0으로 정의합니다.

.예제 20. wyoming 1.5에 할당된 디렉토리 및 파일
[source]
----
📄 antora.yml <1>
📂 modules
📂 sierra-madre
📂 pages
📄 elevation.adoc
📂 partials
📄 bears.adoc
----

<1> 컴포넌트 버전을 wyoming 1.5로 정의합니다.

willow-creek.adoc 페이지(현재 페이지)에서 bears.adoc Partial(대상 Partial)을 참조해 보겠습니다. willow-creek.adoc은 컴포넌트 버전 colorado 5.2에 속합니다. wyoming 컴포넌트, sierra-madre 모듈 및 partials 패밀리에 속하는 bears.adoc 파일은 두 개가 있습니다. 하나의 bears.adoc은 버전 1.0에 속하고 다른 bears.adoc은 버전 1.5에 속합니다.

예제 21은 willow-creek.adoc(현재 페이지)에서 bears.adoc(대상 Partial)을 참조하는 include 지시어를 보여줍니다. 대상 Partial의 버전 좌표가 지정되지 않았다는 점에 주목하세요.

.예제 21. willow-creek.adoc (현재 페이지)
[source,asciidoc]
----
include::wyoming:sierra-madre:partial$bears.adoc[]
----

Antora가 실행되면 버전 정렬 규칙과 최신 버전 기준에 따라 wyoming 1.5를 wyoming 컴포넌트의 최신 버전으로 식별합니다. 예제 21에 버전 좌표가 지정되지 않았기 때문에 Antora는 최신 wyoming 컴포넌트의 버전 좌표(1.5)를 사용하여 include 지시어에 할당된 리소스 ID를 완성합니다.

버전 좌표가 지정되지 않고 대상 Partial과 현재 페이지가 서로 다른 컴포넌트에 속하는 경우에만 최신 버전으로 연결하는 이 동작이 적용됩니다. 리소스 ID에 버전 및 컴포넌트 좌표가 지정되지 않은 경우 Antora는 대상 Partial이 현재 페이지와 동일한 컴포넌트 버전에 속한다고 가정하고 현재 페이지의 버전 및 컴포넌트 좌표를 사용하여 대상 Partial의 리소스 ID를 완성합니다.

=== include 지시어 배치

include 지시어는 새 줄의 시작 부분에 배치됩니다. include 지시어 위아래에 빈 줄을 입력하면 대상 Partial의 내용이 독립 실행형 블록으로 표시됩니다. include 지시어를 새 줄에 직접 인접한 내용 바로 위에 배치하여 대상 Partial의 내용을 현재 페이지의 블록에 연결할 수 있습니다.

.예제 22. current-page.adoc
[source,asciidoc]
----
A paragraph in the page.
include::partial$cli-options.adoc[tag=compass] <1>
A line of content.
include::partial$addendum.adoc[] <2>
Another line of content.
----

<1> 포함된 내용을 독립 실행형 블록으로 표시하려면 include 지시어 위아래로 빈 줄이 있는지 확인하세요.
<2> 포함된 내용을 현재 페이지의 블록에 연결하려면 include 지시어를 블록의 내용 줄 바로 위, 사이 또는 아래의 새 줄에 입력합니다.

=== 다이어그램 소스 포함

소스에서 생성된 다이어그램을 페이지에서 사용하는 경우 다이어그램의 소스를 별도의 파일에 저장하는 것이 좋습니다. 해당 소스를 예제로 저장할지 Partial로 저장할지는 사용자에게 달려 있습니다. 소스가 코드 예제가 아니므로 Partial이 더 논리적인 위치인 것 같습니다.
partials 디렉토리 아래에 diagrams라는 폴더를 만듭니다. 그런 다음 해당 폴더에 다이어그램의 소스를 저장합니다. 파일 이름을 partials/diagrams/my-schema.puml이라고 가정해 보겠습니다. 이제 다음과 같이 해당 소스를 페이지에 포함할 수 있습니다:

.예제 23. 다이어그램의 소스 포함
[source,asciidoc]
----
[plantuml,my-schema,svg]

\include::partial$diagrams/my-schema.puml[]
----

다른 Partials와 마찬가지로 다른 모듈, 버전 또는 컴포넌트의 다이어그램 소스를 참조할 수 있습니다.

=== 더 알아보기

Include an Example
Include a Page
Resources and Resource IDs
AsciiDoc and Asciidoctor resources
Offset section headings with leveloffset
Select regions of content with tags
AsciiDoc include 지시어



== Examples

=== 재사용 가능한 단일 소스 예제
예제는 사이트 전체에서 하나 이상의 페이지에서 재사용하는 소스 코드, 쿼리, 구성 매개변수, 터미널 출력, 로그, 데이터 세트 및 기타 비 AsciiDoc 파일을 저장하는 데 유용합니다. 예제 파일을 변경하면 다음에 사이트를 빌드할 때 예제를 참조한 모든 페이지에 변경 사항이 전파됩니다.
=== 예제 파일 이름 및 파일 확장자
예제 파일은 일반적으로 비 AsciiDoc 파일입니다. examples 디렉토리에 저장됩니다.
새 예제 파일을 저장할 때 다음 파일 이름 요구 사항과 권장 사항을 염두에 두세요:

예제의 파일 이름에는 공백을 포함할 수 없습니다. AsciiDoc include 지시어는 공백이 있는 값을 허용하지 않기 때문입니다.
파일 이름에는 대문자를 사용하지 않는 것이 좋습니다. 일부 파일 시스템은 대소문자를 구분하지 않습니다. 따라서 작성자가 사용하는 파일 시스템에 따라 파일 충돌이 발생할 수 있습니다.
특정 파일 유형(예: Dockerfile)에 확장자가 없는 것이 일반적인 업계 관행이 아닌 경우 유효한 파일 확장자로 예제 파일을 저장하세요. 예제 파일을 저장할 때 올바른 파일 확장자를 사용하지 않으면 일부 Antora 확장을 적용하거나 향후 기능으로 업그레이드하는 기능이 제한될 수 있습니다.

게시 가능한 리소스와 달리 파일 확장자가 없는 예제 파일은 숨겨진 파일로 취급되지 않습니다. Antora는 파일 확장자가 없는 예제를 콘텐츠 카탈로그에 로드하고 참조를 위해 예제에 리소스 ID를 할당합니다.
Antora는 예제 파일을 개별 사이트 페이지로 게시하지 않습니다. 예제의 내용을 게시하려면 페이지 또는 결국 페이지에 포함되는 리소스에서 include 지시어로 예제를 참조해야 합니다.
=== 예제 파일 사용법
일반적으로 예제 파일의 내용은 소스, 목록 및 리터럴 블록에 삽입됩니다. 예제 파일이 속한 컴포넌트 버전에 관계없이 사이트의 모든 페이지 또는 Partial에서 참조할 수 있습니다. 예제는 리소스 ID와 AsciiDoc include 지시어를 사용하여 참조됩니다. 예제의 전체 내용 대신 예제에서 영역이나 행을 선택하고 include 지시어의 tag, tags 또는 lines 속성을 사용하여 해당 영역이나 행만 삽입할 수도 있습니다.
예제는 AsciiDoc 예제 블록과 혼동해서는 안 되지만, include 지시어를 사용하여 예제 파일의 내용을 예제 블록에 삽입할 수 있습니다.



== Examples - Include an Example

=== include 지시어를 사용하여 예제 내용 삽입
AsciiDoc include 지시어와 예제의 리소스 ID를 사용하여 예제를 사이트의 모든 페이지 또는 Partial에 삽입할 수 있습니다.
Antora 리소스 ID와 그 좌표에 익숙하지 않은 경우 다음을 참조하세요:

리소스 및 리소스 ID
리소스 ID 좌표

=== 예제용 AsciiDoc include 지시어
AsciiDoc include 지시어는 예제의 소스 파일에서 Partial 또는 페이지로 내용을 삽입합니다. include 지시어는 예제, Partials 및 페이지의 Antora 리소스 ID를 값으로 받아들입니다.
예제 1은 예제의 완전한 리소스 ID가 포함된 include 지시어의 구조를 보여줍니다. include 지시어는 다른 리소스를 참조하는 데 사용되므로 예제의 리소스 ID가 include 지시어에 할당될 때 example$ 패밀리 좌표를 지정해야 합니다.
.예제 1. 예제의 완전한 리소스 ID가 할당된 include 지시어
[source,asciidoc]
----
\include::version@component:module:example$file-coordinate-of-target-example.ext[optional attribute]
----
include 지시어는 지시어의 접두사(include::), 대상 예제의 리소스 ID 및 대괄호([])로 구성됩니다. 대괄호 내에 쉼표로 구분된 키-값 쌍으로 선택적 속성을 지정할 수 있습니다. 대상 예제는 현재 페이지에서 참조하는 예제의 소스 파일입니다. 대상 예제는 현재 페이지의 내용에서 include 지시어에 리소스 ID를 할당하여 참조됩니다. 현재 페이지는 대상 예제를 참조하는 include 지시어를 포함하는 페이지 소스 파일입니다.
Antora가 실행되면 대상 예제의 내용이 include 지시어가 입력된 위치에 현재 페이지에 삽입됩니다. 대상 예제의 내용은 현재 페이지에 삽입된 후 변환됩니다. 즉, 현재 페이지의 컴포넌트 버전, 모듈, 속성 및 기타 요소가 대상 예제에서 포함된 내용에 적용되거나 영향을 줄 수 있습니다.
=== 페이지에 예제 삽입
대상 예제를 현재 페이지에 삽입하는 데 필요한 AsciiDoc include 지시어와 리소스 ID 좌표를 분석해 보겠습니다.
. IDE 또는 일반 텍스트 편집기에서 예제를 삽입할 페이지를 엽니다. 이 단계와 후속 단계에서는 phases.adoc 파일을 열었다고 가정해 보겠습니다.
예제 파일은 종종 소스 블록에 삽입됩니다. 예제 2는 현재 페이지에 설정된 제목과 할당된 언어가 있는 소스 블록을 보여줍니다.
.예제 2. phases.adoc (현재 페이지)
[source,asciidoc]
.First test phase
[,js]


현재 페이지인 phases.adoc는 예제 3에 표시된 대로 컴포넌트 버전 mapper 8.0과 모듈 testing에 속합니다.
.예제 3. mapper 8.0에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 testing <2>
📂 examples <3>
📄 timer.js
📂 pages <4>
📄 index.adoc
📄 phases.adoc
<1> 컴포넌트 버전을 mapper 8.0으로 정의합니다.
<2> testing 모듈을 정의합니다.
<3> 후속 파일을 예제로 정의합니다.
<4> 후속 파일을 페이지로 정의합니다.
. 현재 페이지에서 예제의 내용을 삽입할 행을 선택합니다. 행의 시작 부분에 지시어 이름 다음에 두 개의 콜론을 입력합니다(include::).
.예제 4. phases.adoc (현재 페이지)
[source,asciidoc]
.First test phase
[,js]
include::

. 현재 페이지에서 대상 예제인 timer.js를 참조해 보겠습니다. 대상 예제의 리소스 ID를 include 지시어에 할당합니다. timer.js와 phases.adoc는 모두 동일한 컴포넌트 버전과 모듈에 속합니다(예제 3 참조). 따라서 대상 예제의 example$ 패밀리 좌표와 파일 좌표만 지정하면 됩니다.
.예제 5. phases.adoc (현재 페이지)
[source,asciidoc]
.First test phase
[,js]
include::example$timer.js

timer.js 예제의 파일 좌표는 timer.js입니다. 대상 예제의 파일 좌표는 timer.js가 examples 디렉토리의 루트에 저장되어 있기 때문에 파일 이름과 파일 확장자로만 구성됩니다.
기본적으로 include 지시어는 좌표가 지정되지 않은 경우 패밀리 좌표가 page$라고 가정합니다. example$ 좌표를 사용하는 것을 잊으면 Antora는 예제를 찾을 수 없어 오류를 보고합니다.
. 대상 예제의 리소스 ID 바로 뒤에 대괄호([])를 사용하여 지시어를 완성합니다.
.예제 6. phases.adoc (현재 페이지)
[source,asciidoc]
----
.First test phase
[,js]
\include::example$timer.js[]
----
include 지시어의 대괄호에는 lines, tag 또는 tags와 같은 선택적 속성 목록이 포함될 수 있습니다. 속성은 쉼표로 구분된 키-값 쌍으로 입력됩니다. lines, tag 및 tags 구문에 대한 자세한 내용은 AsciiDoc include 지시어 문서를 참조하세요.
이것으로 끝입니다! 대상 예제를 현재 페이지에 삽입하는 include 지시어를 만들었습니다.
앞의 지침에서는 가장 일반적인 시나리오(대상 예제와 현재 페이지가 동일한 컴포넌트 버전과 모듈에 속하고 대상 예제가 examples 폴더의 루트에 저장됨)에서 예제를 페이지에 삽입하는 방법을 보여주었습니다. 그러나 대상 예제가 examples 디렉토리의 하위 디렉토리에 저장된 경우 파일 좌표에는 파일 이름과 파일 확장자 외에 examples-relative 디렉토리 경로를 지정해야 합니다.
.예제 7. current-page.adoc
[source,asciidoc]
include::example$target-example-filename.ext[] <1>
include::example$path/to/target-example-filename.ext[] <2>
include::example$./target-example-filename.ext[] <3>
<1> examples 디렉토리의 루트에 저장된 경우 대상 예제의 파일 좌표.
<2> examples 디렉토리의 하위 디렉토리에 저장된 경우 대상 예제의 파일 좌표.
<3> 대상 예제와 현재 페이지가 병렬 패밀리 상대 디렉토리 경로를 가진 하위 디렉토리에 저장된 경우 대상 예제의 파일 좌표. 이것은 고급 사용 사례입니다.
또한 대상 예제와 현재 페이지가 동일한 모듈 또는 컴포넌트 버전에 속하지 않을 때는 추가 리소스 ID 좌표를 지정해야 합니다. 다음 섹션에서는 다양한 리소스 ID 시나리오를 보여주는 예제를 제공합니다.
==== examples-relative 디렉토리 경로가 있는 파일 좌표
대상 예제가 examples 디렉토리의 하위 디렉토리에 저장된 경우 파일 좌표에 대상 예제의 examples-relative 디렉토리 경로가 필요합니다.
.예제 8. 대상 예제가 examples 디렉토리의 하위 디렉토리에 저장된 경우의 파일 좌표
[source,asciidoc]
----
\include::example$path/to/target-example-filename.ext[optional attribute]
----

이 섹션의 예제에 대한 기준으로 예제 9의 컴포넌트 버전에 속하는 파일을 사용해 보겠습니다.
.예제 9. grid-twist 2.5에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 examples <3>
📂 providers <4>
📄 job.yml
📂 pages <5>
📄 interface-loader.adoc
<1> 컴포넌트 버전을 grid-twist 2.5로 정의합니다.
<2> ROOT라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 예제로 정의합니다.
<4> 예제의 소스 파일이 포함된 examples의 하위 디렉토리
<5> 후속 파일을 페이지로 정의합니다.
interface-loader.adoc에서 job.yml을 참조해 보겠습니다. 위의 예제 9에서 볼 수 있듯이 예제와 페이지는 ROOT 모듈에 속합니다. 예제 10에서는 interface-loader.adoc 페이지(현재 페이지)의 include 지시어가 job.yml 파일(대상 예제)을 참조합니다.
.예제 10. interface-loader.adoc (현재 페이지)
[source,asciidoc]
----
[,yaml]
\include::example$providers/job.yml[]
----

예제 10에서 볼 수 있듯이 패밀리 좌표는 example$이고 job.yml의 파일 좌표는 providers/job.yml입니다. job.yml의 파일 좌표는 providers 하위 디렉토리에 저장되어 있기 때문에 examples-relative 디렉토리 경로, 파일 이름 및 파일 확장자로 구성됩니다.
특별한 상황에서 대상 예제의 examples-relative 디렉토리 경로와 현재 페이지의 pages-relative 디렉토리 경로가 병렬인 경우 examples-relative 디렉토리 경로를 상대 경로 토큰 ./로 대체할 수 있습니다.
=== 다른 모듈의 예제 포함
대상 예제와 현재 페이지가 동일한 모듈에 속하지 않는 경우 include 지시어에 대상 예제의 모듈, 패밀리 및 파일 좌표를 지정해야 합니다.
.예제 11. include 지시어에 할당된 모듈, 패밀리 및 파일 좌표
[source,asciidoc]
include::module:example$target-example-filename.ext[optional attribute] <1>
include::module:example$path/to/target-example-filename.ext[optional attribute] <2>
<1> 대상 예제와 현재 페이지가 동일한 컴포넌트 버전에 속하지만 동일한 모듈에 속하지 않을 때 include 지시어에 대상 예제의 모듈, example$ 및 파일 좌표가 할당됩니다. 대상 예제가 examples 패밀리 디렉토리의 루트에 저장된 경우 대상 예제의 파일 좌표는 파일 이름과 파일 확장자입니다.
<2> 대상 예제가 examples 디렉토리의 하위 디렉토리에 저장된 경우 대상 예제의 파일 좌표에는 examples-relative 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다.
이 섹션의 예제에 대한 기준으로 예제 12에 표시된 컴포넌트 버전에 속하는 파일을 사용해 보겠습니다.
.예제 12. mapper 8.0에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 examples <3>
📄 warm-up.js
📂 testing <4>
📂 examples <5>
📄 timer.js
📂 pages <6>
📄 index.adoc
📄 phases.adoc
<1> 컴포넌트 버전을 mapper 8.0으로 정의합니다.
<2> ROOT 모듈을 정의합니다.
<3> 후속 파일을 예제로 정의합니다.
<4> testing 모듈을 정의합니다.
<5> 후속 파일을 예제로 정의합니다.
<6> 후속 파일을 페이지로 정의합니다.
index.adoc 페이지에 warm-up.js 예제를 삽입해 보겠습니다. 즉, 소스 파일 warm-up.js는 대상 예제이고 index.adoc은 현재 페이지입니다. 예제 12에서 볼 수 있듯이 index.adoc 페이지는 testing 모듈에 속하고 warm-up.js 예제는 ROOT 모듈에 속합니다.
예제 13은 index.adoc에서 예제 warm-up.js를 참조하는 include 지시어를 보여줍니다. 대상 예제의 모듈, example$ 및 파일 좌표가 include 지시어에 할당됩니다.
.예제 13. index.adoc (현재 페이지)
[source,asciidoc]
[,js]
include::ROOT:example$warm-up.js[]

예제 13에서 볼 수 있듯이 대상 예제의 모듈 좌표는 ROOT, 패밀리 좌표는 example$, 파일 좌표는 warm-up.js입니다.
=== 다른 컴포넌트의 예제 포함
대상 예제와 현재 페이지가 동일한 문서 컴포넌트에 속하지 않는 경우 include 지시어에 할당된 리소스 ID에 예제의 버전, 컴포넌트, 모듈, 패밀리 및 파일 좌표를 지정하세요.
.예제 14. include 지시어에 할당된 버전, 컴포넌트, 모듈, 패밀리 및 파일 좌표
[source,asciidoc]
include::version@component:module:example$target-example-filename.ext[] <1>
include::version@component:module:example$path/to/target-example-filename.ext[] <2>
include::component:module:example$file-coordinate-of-target-example.ext[] <3>
<1> 대상 예제와 현재 페이지가 동일한 컴포넌트 버전에 속하지 않을 때 include 지시어에 대상 예제의 버전, 컴포넌트, 모듈, 패밀리 및 파일 좌표가 할당됩니다. 대상 예제가 examples 패밀리 디렉토리의 루트에 저장된 경우 대상 예제의 파일 좌표는 파일 이름과 파일 확장자입니다.
<2> 대상 예제가 examples 디렉토리의 하위 디렉토리에 저장된 경우 대상 예제의 파일 좌표에는 examples-relative 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다.
<3> 버전 좌표가 지정되지 않은 경우 Antora는 런타임에 대상 예제의 컴포넌트 최신 버전을 사용하여 리소스 ID를 완성합니다. 이 동작은 대상 예제와 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우에만 적용됩니다.
이 섹션의 예제에 대한 기준으로 컴포넌트 버전 mapper 8.0(예제 15)과 grid-twist 2.5(예제 16)에 속하는 파일을 사용해 보겠습니다.
.예제 15. mapper 8.0에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 examples <3>
📄 warm-up.js
📂 testing <4>
📂 examples <5>
📄 timer.js
📂 pages <6>
📄 index.adoc
📄 phases.adoc
<1> 컴포넌트 버전을 mapper 8.0으로 정의합니다.
<2> ROOT 모듈을 정의합니다.
<3> 후속 파일을 예제로 정의합니다.
<4> testing 모듈을 정의합니다.
<5> 후속 파일을 예제로 정의합니다.
<6> 후속 파일을 페이지로 정의합니다.
.예제 16. grid-twist 2.5에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 examples <3>
📂 providers <4>
📄 job.yml
📂 pages <5>
📄 interface-loader.adoc
<1> 컴포넌트 버전을 grid-twist 2.5로 정의합니다.
<2> ROOT라는 이름의 모듈을 정의합니다.
<3> 후속 파일을 예제로 정의합니다.
<4> 예제의 소스 파일이 포함된 examples의 하위 디렉토리
<5> 후속 파일을 페이지로 정의합니다.
예제 15와 예제 16의 파일을 사용하여 interface-loader.adoc(현재 페이지)에서 warm-up.js(대상 예제)를 참조해 보겠습니다. warm-up.js 예제는 컴포넌트 버전 mapper 8.0에 속합니다. interface-loader.adoc 페이지는 컴포넌트 버전 grid-twist 2.5에 속합니다.
예제 17의 include 지시어는 warm-up.js 예제의 내용을 interface-loader.adoc 페이지에 포함합니다.
.예제 17. interface-loader.adoc (현재 페이지)
[source,asciidoc]
----
[,js]
\include::8.0@mapper:ROOT:example$warm-up.js[]
----

예제 17에서 볼 수 있듯이 대상 예제의 버전 좌표는 8.0, 컴포넌트 좌표는 mapper, 모듈 좌표는 ROOT, 패밀리 좌표는 example$, 파일 좌표는 warm-up.js입니다. warm-up.js의 리소스 ID를 8.0@mapper::example$warm-up.js(모듈 좌표 ROOT가 누락된 것처럼 보임)로 지정할 수도 있습니다. 대상 예제의 컴포넌트 좌표가 지정되고 대상 예제가 ROOT 모듈에 속하는 경우 모듈 좌표 ROOT를 명시적으로 지정할 필요가 없습니다. 그러나 모듈 좌표 뒤에 오는 콜론(:)은 여전히 입력해야 합니다. 이 단축 표기법은 컴포넌트 좌표가 지정되고 대상 예제의 모듈 좌표가 ROOT인 경우에만 작동합니다.
=== 예제의 최신 버전 사용
이 동작은 대상 예제와 현재 페이지가 서로 다른 문서 컴포넌트에 속하는 경우에만 적용됩니다!
include 지시어에 할당된 리소스 ID에 버전이 지정되지 않고 대상 예제와 현재 페이지가 동일한 컴포넌트에 속하지 않는 경우 Antora는 런타임에 대상 예제의 컴포넌트 최신 버전의 버전 좌표를 사용하여 리소스 ID를 완성합니다.
이 섹션의 예제에 대한 기준으로 컴포넌트 버전 mapper 8.0(예제 18), mapper 8.1(예제 19) 및 grid-twist 2.5(예제 20)에 속하는 파일을 사용해 보겠습니다.
.예제 18. mapper 8.0에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 examples <3>
📄 warm-up.js
📂 testing <4>
📂 examples <5>
📄 timer.js
📂 pages <6>
📄 index.adoc
📄 phases.adoc
<1> 컴포넌트 버전을 mapper 8.0으로 정의합니다.
.예제 19. mapper 8.1에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 examples <3>
📄 warm-up.js
📂 testing <4>
📂 examples <5>
📄 timer.js
📂 pages <6>
📄 index.adoc
📄 phases.adoc
<1> 컴포넌트 버전을 mapper 8.1로 정의합니다.
.예제 20. grid-twist 2.5에 할당된 디렉토리 및 파일
[source]
📄 antora.yml <1>
📂 modules
📂 ROOT <2>
📂 examples <3>
📂 providers <4>
📄 job.yml
📂 pages <5>
📄 interface-loader.adoc
<1> 컴포넌트 버전을 grid-twist 2.5로 정의합니다.
interface-loader.adoc 페이지(현재 페이지)에서 timer.js 예제(대상 예제)를 참조해 보겠습니다. interface-loader.adoc은 컴포넌트 버전 grid-twist 2.5에 속합니다. mapper 컴포넌트, testing 모듈 및 examples 패밀리에 속하는 timer.js 파일은 두 개가 있습니다. 하나의 timer.js는 버전 8.0에 속하고 다른 timer.js는 버전 8.1에 속합니다.
예제 21은 interface-loader.adoc(현재 페이지)에서 timer.js(대상 예제)를 참조하는 include 지시어를 보여줍니다. 대상 예제의 버전 좌표가 지정되지 않았다는 점에 주목하세요.
.예제 21. interface-loader.adoc (현재 페이지)
[source,asciidoc]
[,js]
include::mapper:testing:example$timer.js[]

Antora가 실행되면 버전 정렬 규칙과 최신 버전 기준에 따라 mapper 8.1을 mapper 컴포넌트의 최신 버전으로 식별합니다. 예제 21에 버전 좌표가 지정되지 않았기 때문에 Antora는 최신 mapper 컴포넌트의 버전 좌표(8.1)를 사용하여 include 지시어에 할당된 리소스 ID를 완성합니다.
버전 좌표가 지정되지 않고 대상 예제와 현재 페이지가 서로 다른 컴포넌트에 속하는 경우에만 최신 버전으로 연결하는 이 동작이 적용됩니다. 리소스 ID에 버전 및 컴포넌트 좌표가 지정되지 않은 경우 Antora는 대상 예제가 현재 페이지와 동일한 컴포넌트 버전에 속한다고 가정하고 현재 페이지의 버전 및 컴포넌트 좌표를 사용하여 대상 예제의 리소스 ID를 완성합니다.
=== 더 알아보기

Include a Partial
Include a Page
Resources and Resource IDs
Source Blocks
AsciiDoc and Asciidoctor resources
Select regions of content with tags
Normalize block indentation with indent
AsciiDoc include 지시어



== Attachments

=== 첨부 파일 리소스
첨부 파일은 PDF 또는 샘플 프로젝트의 ZIP 아카이브와 같이 attachments 패밀리 디렉토리에 저장되는 다운로드 가능한 리소스입니다. 일반적이지는 않지만 예제 파일도 다운로드 가능하도록 첨부 파일로 승격될 수 있습니다.
=== 첨부 파일용 AsciiDoc xref 매크로
첨부 파일은 AsciiDoc xref 매크로와 첨부 파일의 리소스 ID를 사용하여 페이지, 기타 리소스 및 탐색 파일에서 상호 참조할 수 있습니다.
예제 1은 첨부 파일의 완전한 리소스 ID가 포함된 xref 매크로의 구조를 보여줍니다.
.예제 1. 첨부 파일 참조를 위한 Xref 매크로 구조
[source,asciidoc]
xref:version@component:module:attachment$file-coordinate-of-attachment.ext[optional link text]
최소한 xref 매크로는 매크로의 접두사(xref:), 대상 첨부 파일의 리소스 ID 및 대괄호([])로 구성됩니다. 대상 첨부 파일은 현재 페이지에서 참조하는 첨부 파일 소스 파일입니다. 대상 첨부 파일은 현재 페이지의 내용에서 xref 매크로에 리소스 ID를 할당하여 참조됩니다. 현재 페이지는 대상 첨부 파일을 참조하는 xref 매크로를 포함하는 페이지 소스 파일입니다.
첨부 파일을 참조할 때 xref 매크로는 페이지의 리소스 ID가 할당될 때와 비슷하게 구조화되고 동작하지만 세 가지 차이점이 있습니다:

첨부 파일의 리소스 ID는 첨부 파일이 xref 매크로에 할당될 때 attachment$ 패밀리 좌표를 지정해야 합니다. 그렇지 않으면 Antora는 런타임에 리소스 ID가 페이지의 리소스 ID라고 가정합니다.
프래그먼트(요소 ID)를 첨부 파일의 리소스 ID 끝에 추가할 수 없습니다.
첨부 파일에는 기본 참조 텍스트가 없습니다. xref 매크로에 링크 텍스트가 지정되지 않은 경우 xref의 대상이 링크 텍스트로 표시됩니다.

현재 페이지와 관련하여 대상 첨부 파일의 컴포넌트 버전 및 모듈에 따라 대상 첨부 파일의 리소스 ID 좌표를 얼마나 많이 지정해야 하는지가 결정됩니다.
=== 첨부 파일에 대한 링크 만들기
현재 편집 중인 페이지(현재 페이지)에서 첨부 파일(대상 첨부 파일)로의 상호 참조를 만드는 데 필요한 xref 매크로와 리소스 ID 좌표를 분석해 보겠습니다.
. IDE 또는 텍스트 편집기에서 첨부 파일에 대한 상호 참조를 만들 페이지를 엽니다. 이 단계와 후속 단계에서는 satellites.adoc라는 이름의 페이지에 대한 소스 파일을 열었다고 가정해 보겠습니다. satellites.adoc는 현재 페이지입니다.
.예제 2. satellites.adoc (현재 페이지)
[source,asciidoc]
----
= System Satellites
The group maintains five satellites.
----

. 현재 페이지 내용 흐름의 위치에서 대상 첨부 파일에 대한 링크를 표시할 위치를 선택합니다. xref 매크로의 이름 다음에 하나의 콜론을 입력합니다(xref:).
.예제 3. satellites.adoc (현재 페이지)
[source,asciidoc]
The group maintains five satellites.
See the xref:
. flight-patterns.pdf라는 파일 이름의 첨부 파일 소스 파일을 참조해 보겠습니다. flight-patterns.pdf와 satellites.adoc 모두 동일한 컴포넌트 버전과 모듈에 속합니다. 따라서 예제 4의 xref 매크로에는 대상 첨부 파일의 attachment$ 패밀리 좌표와 파일 좌표만 할당하면 됩니다. 매크로의 접두사 바로 뒤에 대상 첨부 파일의 리소스 ID를 입력합니다.
.예제 4. satellites.adoc (현재 페이지)
[source,asciidoc]
The group maintains five satellites.
See the xref:attachment$flight-patterns.pdf
flight-patterns.pdf의 파일 좌표는 attachments 디렉토리의 루트에 저장되어 있기 때문에 파일 이름과 파일 확장자로만 구성됩니다. 대상 첨부 파일의 파일 좌표는 항상 첨부 파일이 저장된 attachments 패밀리 디렉토리의 루트에서 계산됩니다. 대상 첨부 파일이 attachments 디렉토리의 하위 디렉토리에 저장된 경우 파일 좌표에는 attachments-relative 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다. (예제 8 참조)
. 대상 첨부 파일의 리소스 ID 바로 뒤에 왼쪽 대괄호([)를 입력한 다음 오른쪽 대괄호(])를 입력합니다.
.예제 5. satellites.adoc (현재 페이지)
[source,asciidoc]
The group maintains five satellites.
See the xref:attachment$flight-patterns.pdf[]
. 페이지와 달리 첨부 파일에는 기본 참조 텍스트가 없으므로 xref 매크로에 링크 텍스트를 추가해 보겠습니다. 매크로의 대괄호 사이에 현재 페이지가 게시될 때 대상 첨부 파일에 대한 링크로 표시할 텍스트를 지정합니다.
.예제 6. satellites.adoc (현재 페이지)
[source,asciidoc]
The group maintains five satellites.
See the xref:attachment$flight-patterns.pdf[flight pattern schedule]
링크 텍스트는 선택 사항입니다. 첨부 파일의 링크 텍스트에 대한 자세한 내용은 첨부 파일의 링크 텍스트를 참조하세요.
. xref 매크로의 닫는 대괄호(]) 뒤에 내용을 계속 입력합니다.

.예제 7. satellites.adoc (현재 페이지)
[source,asciidoc]
----
The group maintains five satellites.
See the xref:attachment$flight-patterns.pdf[flight pattern schedule] for more details.
----
이것으로 끝입니다! AsciiDoc xref 매크로를 사용하여 현재 페이지(satellites.adoc)에서 대상 첨부 파일(flight-patterns.pdf)로의 상호 참조를 만들었습니다.
이전 단계에서는 동일한 컴포넌트 버전과 모듈에 속하는 대상 첨부 파일과 현재 페이지를 사용하지만, 컴포넌트 버전과 모듈에 관계없이 사이트의 모든 첨부 파일을 모든 페이지에서 참조할 수 있습니다. 대상 첨부 파일과 현재 페이지가 동일한 모듈 또는 컴포넌트 버전에 속하지 않을 때는 추가 리소스 ID 좌표를 지정해야 합니다.

.예제 8. 현재 페이지와 관련된 대상 첨부 파일의 리소스 ID 패턴
[source,asciidoc]
----
xref:attachment$target-attachment-filename.ext[link text] <1>
xref:attachment$path/to/target-attachment-filename.ext[link text] <2>
xref:attachment$./target-attachment-filename.ext[link text] <3>
xref:module:attachment$file-coordinate-of-attachment.ext[link text] <4>
xref:version@component:module:attachment$file-coordinate-of-attachment.ext[link text] <5>
xref:component:module:attachment$file-coordinate-of-attachment.ext[link text] <6>
xref:version@module:attachment$file-coordinate-of-attachment.ext[link text] <7>
xref:version@attachment$file-coordinate-of-attachment.ext[link text] <8>
----

<1> 대상 첨부 파일과 현재 페이지가 동일한 컴포넌트 버전과 모듈에 속할 때 xref 매크로에 대상 첨부 파일의 attachment$ 패밀리 좌표와 파일 좌표를 할당합니다. 대상 첨부 파일이 attachments 패밀리 디렉토리의 루트에 저장된 경우 대상 첨부 파일의 파일 좌표는 파일 이름과 파일 확장자입니다.
<2> 대상 첨부 파일이 attachments 디렉토리의 하위 디렉토리에 저장된 경우 대상 첨부 파일의 파일 좌표에는 attachments-relative 디렉토리 경로, 파일 이름 및 파일 확장자를 지정해야 합니다.
<3> 대상 첨부 파일과 현재 페이지가 병렬 패밀리 상대 디렉토리 경로를 가진 하위 디렉토리에 저장된 경우 대상 첨부 파일의 파일 좌표를 상대 경로 토큰(./)으로 줄일 수 있습니다. 이것은 고급 사용 사례입니다.
<4> 대상 첨부 파일과 현재 페이지가 동일한 모듈에 속하지 않지만 동일한 컴포넌트 버전에 속할 때 xref 매크로에 대상 첨부 파일의 모듈, attachment$ 및 파일 좌표를 할당합니다.
<5> 대상 첨부 파일과 현재 페이지가 동일한 컴포넌트 버전에 속하지 않을 때 xref 매크로에 대상 첨부 파일의 버전, 컴포넌트, 모듈, attachment$ 및 파일 좌표를 할당합니다.
<6> 버전 좌표가 지정되지 않은 경우 Antora는 런타임에 대상 첨부 파일의 컴포넌트 최신 버전을 사용하여 리소스 ID를 완성합니다. 이 동작은 대상 첨부 파일과 현재 페이지가 동일한 컴포넌트 버전에 속하지 않는 경우에만 적용됩니다.
<7> 대상 첨부 파일이 현재 페이지와 동일한 버전과 모듈에 속하지 않지만 동일한 컴포넌트에 속할 때 xref 매크로에 대상 첨부 파일의 버전, 모듈, attachment$ 및 파일 좌표를 할당합니다.
<8> 대상 첨부 파일이 현재 페이지와 동일한 버전에 속하지 않지만 동일한 컴포넌트와 모듈에 속할 때 xref 매크로에 대상 첨부 파일의 버전, attachment$ 및 파일 좌표를 할당합니다.
첨부 파일 링크와 페이지 링크는 많은 유사점을 공유합니다. 대상 리소스가 동일한 모듈, 컴포넌트 버전 또는 버전에 속하지 않을 때 대상 리소스의 리소스 ID를 구성하는 방법을 보여주는 더 많은 예제는 페이지 링크 만들기를 참조하세요. xref 매크로에 대상 첨부 파일의 리소스 ID를 할당할 때는 항상 attachment$ 패밀리 좌표를 추가해야 한다는 점을 기억하세요.

=== 첨부 파일의 링크 텍스트
AsciiDoc xref 매크로의 대괄호 사이에 링크 텍스트를 지정하거나 xref 매크로의 대괄호를 비워 둘 수 있습니다. 예제 9는 첨부 파일의 리소스 ID가 할당된 xref 매크로를 보여줍니다. xref 매크로의 대괄호 사이에 링크 텍스트가 지정되지 않았습니다.

.예제 9. 지정된 링크 텍스트가 없는 Xref 매크로 [source,asciidoc]
Download xref:attachment$practice-project.zip[] to try it out!
예제 9의 xref 매크로에 링크 텍스트가 할당되지 않았기 때문에 Antora는 xref 대상을 링크 텍스트로 표시합니다.

Download attachment$practice-project.zip to try it out!

페이지와 달리 첨부 파일에는 기본 참조 텍스트가 없으므로 좋은 독자 경험을 보장하기 위해 항상 링크 텍스트를 지정하는 것이 좋습니다.

xref 매크로의 대괄호 사이에 링크 텍스트를 입력하여 링크 텍스트를 지정할 수 있습니다.

.예제 10. 지정된 링크 텍스트가 있는 Xref 매크로 [source,asciidoc]
Download xref:attachment$practice-project.zip[the sample project] to try it out!
xref 매크로에 링크 텍스트가 지정되면 Antora는 게시된 페이지에서 지정된 내용을 첨부 파일에 대한 링크로 표시합니다.

=== 첨부 파일 포함

첨부 파일에 연결하는 대신 include 지시어를 사용하여 첨부 파일을 AsciiDoc 페이지 또는 Partial에 포함할 수 있습니다. 유일한 제한은 파일이 텍스트 파일이어야 한다는 것입니다. 텍스트 파일을 첨부 파일로 저장하면 여전히 다운로드 가능한 상태로 포함할 수 있습니다.

다음은 첨부 파일의 텍스트를 페이지에 포함하는 방법을 보여주는 전체 구문입니다.

[source,asciidoc]
----
\include::version@component:module:attachment$name-of-file.ext[optional attributes]
----
attachment$ 세그먼트는 Antora에게 attachments 폴더에서 파일을 찾으라고 지시합니다. 첨부 파일이 페이지와 동일한 컴포넌트 버전과 모듈에 있는 경우 대상은 attachment$ 세그먼트로 시작할 수 있습니다.

[source,asciidoc]
----
\include::attachment$name-of-file.ext[optional attributes]
----
동일한 첨부 파일을 xref 매크로와 include 지시어 모두에서 사용할 수 있습니다.

=== 더 알아보기

탐색 파일 및 이미지 매크로에서도 첨부 파일에 대한 링크를 만들 수 있습니다.


== AsciiDoc Primer

== AsciiDoc Primer - Why AsciiDoc?

AsciiDoc은 Antora의 기본 콘텐츠 마크업 언어입니다. AsciiDoc은 다음과 같은 특징으로 인해 문서 작성에 이상적입니다:

- 읽기 쉬움
- 간결함
- 포괄적임
- 확장 가능함
- 배우기 쉬움

=== 구문

AsciiDoc은 성숙하고 경량화된 마크업 언어로, 기술 문서 작성에 필요한 모든 구조적 및 의미론적 요소를 지원합니다.

AsciiDoc 구문은 텍스트를 마크업하고 구조화하기 위한 잘 정립된 일반 텍스트 규칙을 인식하기 때문에 직관적입니다. AsciiDoc에 익숙하지 않은 사람도 대부분의 구문 요소의 목적을 보기만 해도 파악할 수 있어야 합니다. 구문 요소가 의미하는 바와 비슷하게 보이도록 신중하게 선택되었기 때문입니다.

AsciiDoc은 읽거나 쓰기 위해 텍스트 편집기만 필요하므로 시작하기 위한 진입 장벽이 매우 낮습니다.

=== 파서

Asciidoctor.js는 AsciiDoc 콘텐츠를 HTML 및 기타 형식으로 변환하는 프로세서입니다.

==== 속도와 보안

Asciidoctor에 대한 설명에서 속도에 대한 언급이 빠질 수 없습니다. 문서를 매우 빠르게 로드, 파싱 및 변환합니다. 이는 매일 여러 환경에서 수천 개의 문서 파일을 처리해야 하는 팀과 애플리케이션에게 좋은 소식입니다. Asciidoctor는 또한 여러 수준의 보안을 제공하여 서버 측 배포에 적합함을 더욱 입증합니다.

=== 오픈 소스의 장점

AsciiDoc 구문, Asciidoctor.js 및 그 확장의 본거지인 Asciidoctor 프로젝트는 오픈 소스이며 MIT 라이선스에 따라 제공됩니다. Antora 개발자는 또한 주요 Asciidoctor 관리자이기도 하며, 이는 긴밀한 통합을 보장하고 끊임없이 변화하는 문서 요구 사항과 필요성을 해결하기 위해 두 기술을 계속 발전시키는 데 도움이 됩니다.



== AsciiDoc Primer - Document Header

=== 문서 제목

AsciiDoc에서는 페이지 상단의 속성 항목 앞에 선택적으로 0단계 섹션 제목을 사용하여 암시적으로 문서 헤더를 만듭니다. 문서 헤더의 0단계 섹션 제목을 문서 제목 또는 줄여서 doctitle이라고 합니다. 문서 헤더의 속성 항목은 문서 전체에서 사용할 수 있는 속성을 설정(또는 설정 해제)합니다.

AsciiDoc 문서의 문서 제목은 Antora에서 페이지 제목으로 사용됩니다.

[IMPORTANT]
====
Antora는 AsciiDoc의 Atx 스타일 제목 구문만 지원하므로 페이지 제목 앞에는 Atx 마커, 즉 등호 기호(=) 다음에 공백이 와야 합니다. Antora는 AsciiDoc에서 한때 지원되었던 레거시 Setext 스타일(즉, 밑줄) 제목 구문이나 Asciidoctor의 Markdown 스타일 제목 구문을 인식하지 않습니다. Atx 스타일 구문을 사용하지 않으면 페이지의 xref가 해결되지 않고 AsciiDoc의 다른 기능을 사용할 수 없습니다.
====

다음은 문서 헤더의 예입니다:

[source,asciidoc]
----
= Page Title
:description: A description of this page.
----

Antora에서는 모든 페이지에 페이지 제목이 있어야 합니다. 즉, doctitle과 문서 헤더가 필요합니다. 페이지 제목 지정에 대한 자세한 내용은 제목 및 메타데이터 추가를 참조하세요.

페이지에 고유한 CSS 세트를 적용해야 하는 경우 다음과 같이 doctitle에 역할을 추가할 수 있습니다.

[source,asciidoc]
----
= Home Page
:docrole: home
----

사용 중인 UI가 지원한다고 가정하면 이제 body.home 선택자를 사용하여 이 특정 페이지를 대상으로 하는 CSS를 구성할 수 있습니다.

=== 헤더 속성

헤더 속성은 문서 헤더 및 문서 메타데이터와 연결된 문서 전체 AsciiDoc 속성입니다. page-toclevels와 같은 일부 헤더 속성은 페이지의 처리를 제어하는 데 사용할 수 있습니다. 더 일반적으로 헤더 속성은 문서에 대한 재사용 가능한 인라인 콘텐츠를 저장하는 데 사용됩니다.

[IMPORTANT]
====
문서 헤더는 첫 번째 빈 줄에서 암시적으로 끝납니다. 따라서 이 줄 아래의 모든 속성 항목은 헤더 속성으로 처리되지 않습니다.
====

게시된 페이지의 메타데이터를 제어하는 데 사용할 수 있는 몇 가지 내장 헤더 속성이 있습니다. 이러한 속성에 대해 알아보려면 제목 및 메타데이터 추가를 참조하세요.
헤더 속성은 이름 앞에 page-를 붙여 페이지 속성으로 승격할 수 있습니다. 페이지 속성은 페이지 레이아웃 템플릿의 UI 모델에서 액세스할 수 있으므로 페이지 형성 방식을 제어할 수 있습니다.



== AsciiDoc Primer - Sections

=== 제목 구문과 레벨

섹션은 페이지를 콘텐츠 계층 구조로 분할합니다. AsciiDoc에서는 섹션 제목을 사용하여 섹션을 정의합니다.

.예제 1. 섹션 제목 구문
[source,asciidoc]
----
== Level 1 Section Title

=== Level 2 Section Title

==== Level 3 Section Title

===== Level 4 Section Title

====== Level 5 Section Title

== Another Level 1 Section Title
----

페이지가 HTML로 변환되면 각 섹션 제목은 등호 기호의 수와 일치하는 제목 레벨을 가진 제목 요소가 됩니다. 예를 들어 레벨 1 섹션(==)은 <h2> HTML 태그에 매핑됩니다.

섹션 제목은 하나 이상의 등호 기호로 시작하는 Atx 스타일(한 줄)을 사용하여 정의해야 합니다.

[IMPORTANT]
====
Antora는 AsciiDoc에서 한때 지원되었던 레거시 Setext 스타일(즉, 밑줄) 제목 구문이나 Asciidoctor의 Markdown 스타일 제목 구문을 인식하지 않습니다. Atx 스타일 구문을 사용하지 않으면 페이지의 xref가 해결되지 않고 AsciiDoc의 다른 기능을 사용할 수 없습니다.
====

.AsciiDoc 및 Asciidoctor 리소스
- Section titles


== AsciiDoc Primer - Text and Punctuation Styles

=== 시각적 강조
AsciiDoc은 인라인 텍스트(단어, 구 및 문자)를 시각적으로 강조하는 여러 가지 방법을 제공합니다.

_굵게_::
굵은 텍스트는 더 두껍거나 어두운 글꼴을 적용하여 일반 주변 텍스트와 구별됩니다. 굵게는 텍스트가 페이지를 시각적으로 훑어보는 사람의 주의를 끌어야 할 때 유용합니다.

_기울임꼴_::
텍스트는 종종 단어나 구를 강조하거나, 화자를 인용하거나, 용어를 소개하기 위해 기울임꼴로 표시됩니다. 기울임꼴은 오른쪽으로 약간 기울어지며, 글꼴에 따라 필기체 장식이 있을 수 있습니다.

_고정 폭_::
기술 콘텐츠는 종종 명령이나 소스 코드를 나타내는 방식으로 텍스트의 스타일을 지정해야 합니다. 이러한 텍스트는 일반적으로 고정 폭(즉, 고정 폭) 글꼴을 사용하여 강조 표시됩니다.

_강조 표시_::
텍스트에 주의를 끄는 또 다른 방법은 텍스트를 강조 표시(또는 표시)하는 것입니다. 이 의미론적 스타일은 참조 또는 주석 목적으로 사용되거나 주요 주제나 요점의 중요성을 표시하는 데 사용됩니다.

=== 구두점

일반적인 구두점은 이메일이나 워드 프로세서에서와 마찬가지로 AsciiDoc 문서에 입력됩니다. 덜 일반적인 구두점은 직접 입력하거나 AsciiDoc 단축키를 사용하여 입력할 수 있습니다.

덜 일반적인 구두점을 입력하는 한 가지 방법은 운영 체제의 작성 키(즉, 특수 키 시퀀스)를 사용하는 것입니다. 예를 들어 macOS에서는 [⌥ Opt]+[-] 키 시퀀스를 입력하여 en 대시를 입력할 수 있습니다.

키 시퀀스는 기억하기 어려울 수 있으므로 AsciiDoc은 덜 일반적인 구두점을 입력하는 더 간단한 방법을 제공합니다. AsciiDoc에는 곡선(스마트) 따옴표를 입력하기 위한 단축 구문이 있으며 많은 확장 구두점 기호에 대한 내장 대체 및 속성을 제공합니다.

_따옴표 및 작은따옴표 기호_::
따옴표와 작은따옴표는 직선형 또는 곡선형으로 명시적으로 표시할 수 있습니다.

==== 기호, 부호 및 마크

  특수 문자 및 기호 대체는 AsciiDoc에 내장되어 있습니다.

_특수 문자 및 기호_::
AsciiDoc은 HTML 및 XML 문자 엔티티와 10진수 및 16진수 유니코드 코드 포인트 참조를 허용합니다.



== AsciiDoc Primer - Text and Punctuation Styles - Bold

이 페이지에서는 다음을 배웁니다:

- AsciiDoc에서 텍스트를 굵게 만드는 방법.
- 사이트의 굵은 텍스트 스타일을 수정하는 위치.

굵게 표시된 텍스트는 더 두껍거나 어두운 글꼴을 적용하여 일반 주변 텍스트와 구별됩니다. 굵게는 텍스트가 페이지를 빠르게 스캔하는 사이트 방문자의 주의를 끌어야 할 때 유용합니다.

=== 굵은 구문

단어나 구문 앞뒤에 별표 한 쌍(예: pass:[*word*])으로 묶으면 굵게 표시됩니다(제한된 서식). 경계 문자 앞뒤에 별표 두 쌍(예: pass:[char**act**ers])으로 묶으면 굵게 표시됩니다(제한되지 않은 서식).

경계 문자는 다음과 같은 문자입니다:

- 공백이 아닌 문자가 직접 앞에 오는 경우
- 공백이 아닌 문자가 직접 뒤에 오는 경우

굵게 표시된 전체 단어나 구문 뒤에 ;, ", !와 같은 일반적인 구두점이 직접 오는 경우에는 이중 별표를 사용할 필요가 없습니다.

.예제 1. 굵은 인라인 서식
[source,asciidoc]
----
A bold *word*, and a bold *phrase of text*.

Bold c**hara**cter**s** within a word.
----

예제 1의 결과는 아래에 표시됩니다.

====
A bold *word*, and a bold *phrase of text*.

Bold c**hara**cter**s** within a word.
====

=== 굵은 텍스트와 다른 서식 혼합

구문이 올바른 순서로 배치되어 있는 한 굵은 텍스트에 여러 강조 스타일을 추가할 수 있습니다.

.예제 2. 인라인 서식 구문의 순서
[source,asciidoc]
----
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
----

고정 폭 구문(```)은 가장 바깥쪽 서식 세트(즉, 굵은 서식 세트 외부)여야 합니다. 기울임꼴 구문(_)은 항상 가장 안쪽 서식 세트입니다.

예제 2의 결과는 아래에 표시됩니다.

====
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
====

=== 사이트 스타일

사이트에서 굵은 텍스트가 어떻게 표시되는지는 UI에서 로드한 글꼴과 <strong> HTML 태그에 적용된 CSS 스타일에 따라 다릅니다. 사이트에서 굵은 텍스트가 표시되는 방식을 사용자 정의하는 방법에 대한 자세한 내용은 UI 문서에서 확인할 수 있습니다.

AsciiDoc 및 Asciidoctor 리소스::
- Bold text formatting
- Formatting marks and pairs
- Constrained versus unconstrained



== AsciiDoc Primer - Text and Punctuation Styles - Italic

이 페이지에서는 다음을 배웁니다:

- AsciiDoc에서 텍스트를 기울임꼴로 만드는 방법.
- 사이트의 기울임꼴 텍스트 스타일을 수정하는 위치.

텍스트는 종종 단어나 구를 강조하거나, 화자를 인용하거나, 용어를 소개하기 위해 기울임꼴로 표시됩니다. 기울임꼴은 오른쪽으로 약간 기울어지며, 글꼴에 따라 필기체 장식이 있을 수 있습니다.

=== 기울임꼴 구문

단어나 구문 앞뒤에 밑줄 한 쌍(_word_)으로 묶으면 기울임꼴로 표시됩니다(제한된 서식). 경계 문자 앞뒤에 밑줄 두 쌍(char__act__ers)으로 묶으면 기울임꼴로 표시됩니다(제한되지 않은 서식).

경계 문자는 다음과 같은 문자입니다:

- 공백이 아닌 문자가 직접 앞에 오는 경우
- 공백이 아닌 문자가 직접 뒤에 오는 경우

기울임꼴로 표시된 전체 단어나 구문 뒤에 ;, ", !와 같은 일반적인 구두점이 직접 오는 경우에는 이중 밑줄을 사용할 필요가 없습니다.

.예제 1. 기울임꼴 인라인 서식
[source,asciidoc]
----
An italic _word_, and an italic _phrase of text_.

Italic c__hara__cter__s__ within a word.
----

예제 1의 결과는 아래에 표시됩니다.

====
An italic _word_, and an italic _phrase of text_.

Italic c__hara__cter__s__ within a word.
====

=== 기울임꼴과 다른 서식 혼합

구문이 올바른 순서로 배치되어 있는 한 기울임꼴 텍스트에 여러 강조 스타일을 추가할 수 있습니다.

.예제 2. 인라인 서식 구문의 순서
[source,asciidoc]
----
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
----

고정 폭 구문(```)은 가장 바깥쪽 서식 세트여야 합니다. 굵은 구문(*)은 기울임꼴 서식 세트 외부에 있어야 합니다. 기울임꼴 구문은 항상 가장 안쪽 서식 세트입니다.
예제 2의 결과는 아래에 표시됩니다.

====
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
====

=== 사이트 스타일

사이트에서 기울임꼴 텍스트가 어떻게 표시되는지는 UI에서 로드한 글꼴과 <em> HTML 태그에 적용된 CSS 스타일에 따라 다릅니다. 사이트에서 기울임꼴 텍스트가 표시되는 방식을 사용자 정의하는 방법에 대한 자세한 내용은 UI 문서에서 확인할 수 있습니다.

AsciiDoc 및 Asciidoctor 리소스::
- 기울임꼴 텍스트 서식
- 서식 표시 및 쌍
- 제한된 서식과 제한되지 않은 서식



== AsciiDoc Primer - Text and Punctuation Styles - Monospace

이 페이지에서는 다음을 배웁니다:

- AsciiDoc에서 인라인 텍스트에 고정 폭 서식을 적용하는 방법.
- 사이트의 인라인 고정 폭 텍스트 스타일을 수정하는 위치.

기술 콘텐츠는 종종 텍스트가 명령이나 소스 코드임을 나타내는 방식으로 스타일을 지정해야 합니다. 이러한 텍스트는 일반적으로 고정 폭, 즉 고정 폭 글꼴을 사용하여 강조 표시됩니다.

=== 인라인 고정 폭 구문

단어나 구문 앞뒤에 백틱 한 쌍(word)으로 묶으면 고정 폭으로 표시됩니다(제한된 서식). 경계 문자 앞뒤에 백틱 두 쌍(char``act``ers)으로 묶으면 고정 폭으로 표시됩니다(제한되지 않은 서식).

경계 문자는 다음과 같은 문자입니다:

- 공백이 아닌 문자가 직접 앞에 오는 경우
- 공백이 아닌 문자가 직접 뒤에 오는 경우

고정 폭으로 표시된 전체 단어나 구문 뒤에 ;, ", !와 같은 일반적인 구두점이 직접 오는 경우에는 이중 백틱을 사용할 필요가 없습니다.

.예제 1. 고정 폭 인라인 서식
[source,asciidoc]
----
A monospace `word`, and a monospace `phrase of text`.

Monospace c``hara``cter``s`` within a word.
----

예제 1의 결과는 아래에 표시됩니다.

====
A monospace `word`, and a monospace `phrase of text`.

Monospace c``hara``cter``s`` within a word.
====

=== 고정 폭과 다른 서식 혼합

구문이 올바른 순서로 배치되어 있는 한 고정 폭 텍스트에 여러 강조 스타일을 추가할 수 있습니다.

.예제 2. 인라인 서식 구문의 순서
[source,asciidoc]
----
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
----

고정 폭 구문은 항상 가장 바깥쪽 서식 세트입니다. 굵은 구문(*)은 기울임꼴 서식 세트 외부에 있어야 합니다. 기울임꼴 구문(_)은 항상 가장 안쪽 서식 세트입니다.

예제 2의 결과는 아래에 표시됩니다.

====
`*_monospace bold italic phrase_*` & ``**__char__**``acter``**__s__**``
====

=== 사이트 스타일
사이트에서 인라인 고정 폭 텍스트가 어떻게 표시되는지는 UI에서 로드한 글꼴과 <code> HTML 태그에 적용된 CSS 스타일에 따라 다릅니다. 사이트에서 고정 폭 텍스트가 표시되는 방식을 사용자 정의하는 방법에 대한 자세한 내용은 UI 문서에서 확인할 수 있습니다.

AsciiDoc 및 Asciidoctor 리소스::
- Monospace text formatting
- Formatting marks and pairs
- Constrained versus unconstrained



== AsciiDoc Primer - Text and Punctuation Styles - Highlight

이 페이지에서는 다음을 배웁니다:

- AsciiDoc으로 텍스트를 강조 표시하는 방법.
- 사이트의 강조 스타일을 수정하는 위치.

=== 강조 구문

단어나 구문을 강조 표시(또는 표시)하려면 서식을 지정할 텍스트의 시작과 끝에 해시(pass:[#])를 배치합니다(제한된 서식). 다른 문자로 둘러싸인 하나 이상의 문자를 강조 표시하려면 문자 앞뒤에 해시 두 개(pass:[##])를 배치합니다(제한되지 않은 서식).

.예제 1. 강조 인라인 서식
[source,asciidoc]
----
Let's #highlight this phrase# and the i and s in th##is##.
----

예제 1의 결과는 아래에 표시됩니다.

====
Let's #highlight this phrase# and the i and s in th##is##.
====

=== 사이트 스타일

사이트에서 강조 표시된 텍스트가 어떻게 표시되는지는 <mark> HTML 태그에 적용된 CSS 스타일에 따라 다릅니다. 사이트에서 강조 표시된 텍스트가 표시되는 방식을 사용자 정의하는 방법에 대한 자세한 내용은 UI 문서에서 확인할 수 있습니다.

AsciiDoc 및 Asciidoctor 리소스::
- Highlighted text formatting
- Formatting marks and pairs
- Constrained versus unconstrained



== AsciiDoc Primer - Text and Punctuation Styles - Quote Marks and Apostrophes

이 페이지에서는 다음을 배웁니다:

- 작은따옴표와 큰따옴표를 사용하는 방법.
- 곡선형 아포스트로피를 사용하는 방법.

=== 곡선형 따옴표 구문
작은따옴표와 큰따옴표는 기본적으로 곡선형 따옴표로 렌더링되지 않습니다. ' 및 " 키를 사용하여 입력하면 Asciidoctor는 직선형 따옴표를 출력합니다.

곡선형 따옴표를 출력하려면 작은따옴표(') 또는 큰따옴표(")로 둘러싸인 백틱(```) 세트를 추가해야 합니다.

.예제 1. 작은따옴표와 큰따옴표
[source,asciidoc]
----
'`This should be enclosed in curved single quotes when published.`'

"`This should be enclosed in curved double quotes when published.`"
----

예제 1의 결과는 아래에 표시됩니다.

====
'`This should be enclosed in curved single quotes when published.`'

"`This should be enclosed in curved double quotes when published.`"
====

=== 곡선형 아포스트로피 구문

' 키로 입력할 때, 축약형이나 단수 소유격과 같이 문자 앞뒤에 직접 오는 아포스트로피는 자동으로 곡선형 아포스트로피로 출력됩니다.

그러나 복수 소유격과 같이 아포스트로피 뒤에 공백이 직접 오는 경우에는 기본적으로 곡선형이 아닙니다.

두 문자로 묶이지 않은 아포스트로피를 곡선형으로 출력하려면 작은따옴표와 마찬가지로 표시합니다.

.예제 2. 곡선형 아포스트로피
[source,asciidoc]
----
The `'80s.

The students`' books.

I can't find Joey's house.
----

예제 2의 결과는 아래에 표시됩니다.

====
The `'80s.

The students`' books.

I can't find Joey's house.
====

==== 곡선형 아포스트로피 이스케이프

두 문자로 묶인 아포스트로피를 곡선형으로 만들고 싶지 않으면 백슬래시(\)를 앞에 붙여 이스케이프합니다.

.예제 3. 이스케이프된 곡선형 아포스트로피 구문
[source,asciidoc]
----
I can't find Joey\'s house.
----

예제 3의 결과는 아래에 렌더링됩니다.

====
I can't find Joey\'s house.
====



== AsciiDoc Primer - Text and Punctuation Styles - Special Characters and Symbols

이 페이지에서는 다음을 배웁니다:

- AsciiDoc으로 특수 문자(<, >, &)를 추가하는 방법.
- AsciiDoc으로 ©나 ⇒ 같은 기호를 추가하는 방법.
- AsciiDoc에서 HTML 및 XML 엔티티를 사용하는 방법.

특수 문자 및 기호 대체는 Asciidoctor에 내장되어 있습니다.

변환 중에 아래 표의 문자는 적절한 문자 또는 유니코드 엔티티로 대체됩니다. 특수 문자 및 기호 대체는 주석 및 특정 패스스루를 제외한 모든 인라인 및 블록 요소에서 발생합니다. 세 가지 특수 문자 <, >, &는 항상 먼저 대체됩니다.

HTML 및 XML 문자 엔티티와 10진수 및 16진수 유니코드 코드 포인트 참조도 인식되어 대체됩니다.

예를 들어 § 기호를 생성하려면 pass:[&#38;sect;](HTML 출력만 해당), pass:[&#38;#x00A7;] 또는 pass:[&#38;#167;]을 사용할 수 있습니다. 문서가 처리될 때 문자 엔티티 참조인지 숫자 문자 참조인지에 관계없이 대체 치환은 섹션 기호 참조를 pass:[&#38;#167;]로 대체합니다. 차례로 pass:[&#38;#167;]은 §로 표시됩니다.

[cols="2,1,1,1,3"]
|===
|이름 |구문 |대체 |렌더링 |비고

|Ampersand
|&
|pass:[&#38;amp;]
|&
|

|아포스트로피, 곡선형
|pass:[Sam's]
|Sampass:[&#38;#8217;]s
|Sam's
|수직형 아포스트로피는 곡선형 아포스트로피로 대체됩니다.

|저작권
|pass:[(C)]
|pass:[&#38;#169;]
|©
|

|생략 부호
|pass:[...]
|pass:[&#38;#8230;]
|...
|

|Em 대시
|pass:[--]
|pass:[&#38;#8212;]
|--
|두 단어 문자 사이, 단어 문자와 줄 경계 사이 또는 공백으로 둘러싸인 경우에만 대체됩니다.

공백 문자로 둘러싸인 경우(예: a -- b) 일반 공백은 얇은 공백(pass:[&#38;#8212;])으로 대체됩니다.

|보다 큰
|pass:[>]
|pass:[&#38;gt;]
|>
|

|왼쪽 이중 화살표
|pass:[<=]
|pass:[&#38;#8656;]
|⇐
|

|왼쪽 단일 화살표
|pass:[<-]
|pass:[&#38;#8592;]
|←
|

|보다 작은
|pass:[<]
|pass:[&#38;lt;]
|
|

|등록 상표
|pass:[(R)]
|pass:[&#38;#174;]
|®
|

|오른쪽 이중 화살표
|pass:[=>]
|pass:[&#38;#8658;]
|⇒
|

|오른쪽 단일 화살표
|pass:[->]
|pass:[&#38;#8594;]
|→
|

|상표
|pass:[(TM)]
|pass:[&#38;#8482;]
|™
|
|===

.**AsciiDoc 및 Asciidoctor 자료**

- Special characters
- HTML, XML, and Unicode symbols
- Predefined attributes for character replacements



== AsciiDoc Primer - Text and Punctuation Styles - Subscript and Superscript

이 페이지에서는 다음을 배웁니다:

- AsciiDoc으로 아래 첨자 문자 또는 단어를 마크업하는 방법.
- AsciiDoc으로 위 첨자 문자 또는 단어를 마크업하는 방법.

stem 문서 속성을 사용하여 AsciiDoc으로 방정식과 공식을 작성할 수 있습니다.

=== 아래 첨자 구문

텍스트는 틸드(~) 세트로 둘러싸여 아래 첨자로 표시됩니다.

.예제 1. 아래 첨자
[source,asciidoc]
----
The chemical formula for water is H~2~O.
----

예제 1의 결과는 아래와 같이 렌더링됩니다.
====
The chemical formula for water is H~2~O.
====

=== 위 첨자 구문

텍스트는 캐럿(^) 세트로 둘러싸여 위 첨자로 표시됩니다.

.예제 2. 위 첨자
[source,asciidoc]
----
What is the answer to E=mc^2^?
----

예제 2의 결과는 아래와 같이 렌더링됩니다.
====
What is the answer to E=mc^2^?
====



== AsciiDoc Primer - Internal Xrefs

내부 xref는 동일한 페이지 내의 다른 요소에 대한 참조입니다. 섹션, 블록 또는 인라인 요소를 참조할 수 있습니다. 이러한 xref는 앵커(즉, ID)만 지정하면 됩니다.

=== 동일한 페이지의 섹션 참조

AsciiDoc 페이지가 처리될 때 섹션 제목 ID가 자동으로 생성되므로 섹션의 제목을 참조하여 링크로 사용할 수 있습니다. 그러나 제목은 선행 서식 표시 없이 대문자(기본 라틴어)로 시작해야 합니다.

동일한 페이지에서 섹션의 시작 부분으로 연결하려면 이중 꺾쇠 괄호(<< >>)로 지정된 페이지 내 상호 참조를 사용하세요.

.예제 1. 동일한 페이지의 섹션 제목에 연결
[source,asciidoc]
----
This is an in-page cross reference: <<Reference a section in the same page>>. <1>

This is an in-page cross reference:
<<reference-a-section-in-the-same-page,Check it out>>! <2>
----
<1> 섹션의 제목을 사용하는 페이지 내 xref.
<2> 섹션의 암시적 ID를 사용하는 페이지 내 xref.

=== 동일한 페이지의 블록 또는 인라인 요소 참조

동일한 페이지의 블록 또는 인라인 요소에 연결하려면 해당 위치에 ID를 정의해야 합니다.

.예제 2. ID 만들기
[source,asciidoc]
----
[#playbook] <1>
Here's an example of a playbook.

This is an [#name-me]#inline ID#. <2>
----
<1> ID는 단락(즉, 블록)에 배치할 수 있습니다.
<2> ID는 인라인으로 배치할 수 있습니다.

더 많은 사용 사례는 Asciidoctor 설명서의 앵커 정의 섹션을 참조하세요.

해당 ID에 연결하려면 섹션 제목에 사용하는 것과 동일한 페이지 내 xref 구문을 사용하세요.

.예제 3. ID에 연결
[source,asciidoc]
----
We'll walk through a <<playbook,detailed example>> of a playbook in this tutorial.
----



== AsciiDoc Primer - URLs

이 페이지에서는 다음을 배웁니다:

- URL과 상호 참조를 사용해야 하는 시기.
- 링크 텍스트가 있는 링크와 없는 링크를 만드는 방법.
- URL을 이스케이프하는 방법.
- 복잡한 URL을 처리하는 방법.

=== URL 또는 상호 참조?

외부 URL에 대한 링크를 만들 때는 AsciiDoc의 URL 구문을 사용하세요. 외부 URL은 Antora 파이프라인에서 문서 사이트의 일부로 빌드되지 않는 웹페이지에 대한 링크입니다.

문서 사이트의 일부인 페이지, 이미지 또는 첨부 파일에 연결하려면 대신 AsciiDoc xref 매크로와 리소스의 리소스 ID를 사용하세요.

=== URL 구문

외부 URL에 대한 링크를 만들려면 스키마가 접두사로 붙은 URL을 추가하면 됩니다.

Raw URL syntax
Chat with other documentation writers at https://chat.antora.org.

https, ftp, mailto 등과 같은 공식 스키마로 시작하는 링크는 처리될 때 자동으로 하이퍼링크로 변환됩니다. 다음은 Raw URL 구문의 결과입니다.

====
Chat with other documentation writers at chat.antora.org.
====

텍스트에 URL을 첨부하려면 URL 끝에 대괄호([])로 텍스트를 묶으세요.

.예제 1. 링크 텍스트 구문이 있는 URL
[source,asciidoc]
----
Looking for help?
Visit the https://chat.antora.org[Antora chat room].
----

예제 1의 결과는 아래에 표시됩니다.

====
Looking for help?
Visit the https://chat.antora.org[Antora chat room].
====

=== URL 이스케이프

URL을 표시하지만 활성화하고 싶지 않을 때는 백슬래시(\)를 앞에 붙여 이스케이프할 수 있습니다.

.예제 2. 이스케이프 구문
[source,asciidoc]
----
This URL is displayed, \https://gitlab.com, but isn't clickable.
----

예제 2의 결과는 다음과 같습니다.

====
This URL is displayed, \https://gitlab.com, but isn't clickable.
====

=== URL 문제 해결

밑줄(_) 또는 캐럿(^)과 같은 문자가 포함된 경우 이러한 문자가 텍스트 서식 마크업으로 해석되기 때문에 URL이 올바르게 표시되지 않을 수 있습니다.

이 상황을 해결하는 두 가지 방법이 있습니다.

 옵션 1: URL에 대한 사용자 정의 속성을 만듭니다.
 옵션 2: macros가 활성화된 인라인 pass 매크로를 사용합니다.

==== URL에 대한 속성 만들기

복잡한 URL에 대한 속성을 만들어 보겠습니다. URL이 길 때도 URL에 대한 속성을 만드는 것이 좋은 전략입니다. 작성자와 편집자를 위해 소스 텍스트를 깔끔하게 유지할 수 있습니다.

.예제 3. 사용자 정의 AsciiDoc 속성 구문
[source,asciidoc]
----
= Page Title <1>
:url-peak: https://www.google.com/maps/place/Antora+Peak/@38.3249976,-106.2355882,14z/data=!3m1!4b1!4m5!3m4!1s0x871572433f469bd7:0xd2bdf15e615cd269!8m2!3d38.3249994!4d-106.2180786!5m1!1e4

{url-peak}[This URL] was complicated, but a page attribute came to our rescue! <2>
----
<1> 소스 파일의 헤더에 원하는 이름으로 속성을 만듭니다. URL을 할당하세요.
<2> 텍스트에서 해당 URL에 대한 링크를 만들려면 URL을 사용했을 때와 마찬가지로 속성(즉, 해당 속성 참조)을 사용하세요.

예제 3의 결과는 아래에 표시됩니다.

====
{url-peak}[This URL] was complicated, but a page attribute came to our rescue! 
====

==== pass 매크로 사용

복잡한 URL을 표시하고 어떤 텍스트 서식에도 걸리지 않도록 하려면 pass 매크로 안에 넣고 링크를 대체하는 매크로 치환을 활성화하세요.

매크로 치환이 활성화된 pass 매크로의 구성 방식은 다음과 같습니다:

[source,asciidoc]
----
pass:macros[URL goes between these brackets]
----

실제 pass 매크로는 다음과 같습니다:

.예제 4. macros 치환 구문이 있는 Pass 매크로
[source,asciidoc]
----
Anyone want to climb this 13er with me? (pass:macros[https://www.14ers.com/13ers/peak.php?peakkey=4740])
----

예제 4의 결과는 아래에 표시됩니다.

====
Anyone want to climb this 13er with me? (pass:macros[https://www.14ers.com/13ers/peak.php?peakkey=4740])
====

.*AsciiDoc 및 Asciidoctor 리소스*
- Autolink syntax
- URL macro
- Mailto macro
- URL attributes
- Troubleshooting URLs and preventing substitutions



== AsciiDoc Primer - Lists

AsciiDoc을 사용하면 이미지, 예제 블록 및 공지 사항과 같은 다양한 내용을 포함하는 여러 유형의 목록을 만들 수 있습니다. 심지어 다른 목록 항목 유형을 하나의 목록으로 혼합할 수도 있습니다.

그러나 먼저 몇 가지 용어부터 살펴보겠습니다.

**목록**은 목록 항목을 포함하는 AsciiDoc 블록 요소입니다.

**목록 항목**은 여러 단락이나 블록을 포함할 수 있는 내용으로, 목록 유형과 목록에 할당된 옵션에 따라 마커, 숫자, 문자 또는 기호가 앞에 올 수 있습니다.

=== 목록 유형
*체크리스트*::
작업 목록 또는 펀치 목록이라고도 하는 이러한 목록에는 빈 투표 상자(☐) 또는 선택된 상자(☑)로 표시된 항목이 포함됩니다. AsciiDoc으로 클릭 가능한 작업 목록을 만들 수도 있습니다.

*설명 목록*::
용어와 해당 설명 및 정의 목록입니다.

*순서가 지정된 목록*::
시퀀스에서 숫자나 문자가 앞에 오는 열거된 항목의 목록입니다.

*순서가 지정되지 않은 목록*::
일반적으로 글머리 기호(•)가 앞에 오는 항목 목록으로, 글머리 기호 또는 글머리 기호 목록이라고도 합니다. 탐색 파일에도 순서가 지정되지 않은 AsciiDoc 목록이 포함되어 있습니다



== AsciiDoc Primer - Lists - Bullet and Numbered Lists

이 페이지에서는 다음을 배웁니다:

- AsciiDoc으로 순서가 지정된 목록을 마크업하는 방법.
- AsciiDoc으로 순서가 지정되지 않은 목록을 마크업하는 방법.
- 목록 항목에 다른 AsciiDoc 요소를 추가하는 방법.
- 동일한 목록에서 순서가 지정된 항목과 지정되지 않은 항목을 혼합하는 방법.

=== 순서가 지정된 목록 구문

순서가 지정된 목록은 목록 항목에 번호를 매겨야 할 때 유용합니다. 첫 번째 수준 목록 항목은 단일 점(마침표)으로 만들고 중첩된 항목은 각 항목 앞에 두 개 이상의 점을 사용하여 만듭니다. 점(또는 점들)은 목록 항목의 내용과 단일 공백으로 구분됩니다.

.예제 1. 중첩된 수준이 있는 순서가 지정된 목록
[source,asciidoc]
----
. Step 1
. Step 2
.. Details
... Mini-details
.... Micro-details
..... We're really down in the weeds now.
.. More details
. Step 3
----

순서가 지정되지 않은 목록을 원하는 깊이까지 중첩할 수 있습니다. 각 중첩 수준을 식별하는 데 사용되는 다른 번호 매기기 또는 문자 지정 체계(예: 아라비아 숫자, 알파벳, 로마 숫자 등)입니다. 그러나 고유한 체계가 적용되는 깊이는 스타일시트에 따라 달라집니다. 해당 깊이를 넘어서면 브라우저 기본값(아라비아 숫자)으로 되돌아갑니다.

. Step 1
. Step 2
.. Details
... Mini-details
.... Micro-details
..... We're really down in the weeds now.
.. More details
. Step 3

목록 스타일을 사용하여 번호 매기기 체계를 제어할 수 있습니다.

[loweralpha]
. alpha
. beta
. gamma

start 속성을 사용하여 시작 값을 제어할 수 있습니다.

[start=42]
. Picking up where we left off.
. Add one more ingredient.
. Mix and serve!

=== 순서가 지정되지 않은 목록 구문

목록에 번호를 매길 필요가 없을 때는 순서가 지정되지 않은 목록을 사용하세요. 첫 번째 수준 목록 항목은 별표(*)를 사용하여 표시하고 중첩된 항목은 두 개 이상의 별표를 사용하여 표시합니다.

.예제 2. 중첩된 수준이 있는 순서가 지정되지 않은 목록
[source,asciidoc]
----
* Item A
* Item B
** Item B1
*** Details
**** More details
***** Details about the details
** Item B2
* Item C
----

순서가 지정되지 않은 목록을 원하는 깊이까지 중첩할 수 있습니다. 순서가 지정되지 않은 목록은 각 중첩 수준을 식별하기 위해 각 목록 항목 앞에 글머리 기호나 다른 설명 마커를 사용합니다. 그러나 고유한 마커가 적용되는 깊이는 스타일시트에 따라 달라집니다. 해당 깊이를 넘어서면 브라우저 기본값(사각형 글머리 기호)으로 되돌아갑니다.

* Item A
* Item B
** Item B1
*** Details
**** More details
***** Details about the details
** Item B2
* Item C

사이트의 탐색을 구조화하는 데에도 AsciiDoc의 순서가 지정되지 않은 목록 구문을 사용할 수 있습니다.

=== 복잡한 순서가 지정된 목록과 지정되지 않은 목록

목록 항목은 모든 AsciiDoc 요소일 수 있습니다. 또한 순서가 지정된 목록 항목과 지정되지 않은 목록 항목을 혼합할 수 있습니다. 다양한 내용과 목록 항목 유형이 포함된 예제를 살펴보겠습니다.

[source,asciidoc]
--
* A list item can contain two or more paragraphs or blocks of content.
+ <1>
[source,yaml]
----
  artifacts:
    expire_in: 1 week
----
+ <1>
====
An example block
====

** A literal paragraph doesn't require a list continuation.

 $ antora antora-playbook.yml

* You can also mix list item types in the same list.
** Unordered list item
... Ordered list item
.... Another ordered list item
+ <1>
term:: A description list term and content.
--

<1> **목록 연속**은 연결된 블록에 바로 인접한 별도의 행에 있는 더하기 기호(+)입니다.

목록 항목에 단락이나 블록을 추가하려면 목록 연속(+)으로 연결해야 합니다.

위의 복잡한 목록이 렌더링되는 방식은 다음과 같습니다.

* A list item can contain two or more paragraphs or blocks of content.
+
[source,yaml]
----
  artifacts:
    expire_in: 1 week
----
+
====
An example block
====

** A literal paragraph doesn't require a list continuation.

 $ antora antora-playbook.yml

* You can also mix list item types in the same list.
** Unordered list item
... Ordered list item
.... Another ordered list item
+ <1>
term:: A description list term and content.

또는 목록 항목에 여러 블록이 포함된 경우 구분된 열린 블록(--)으로 묶을 수 있습니다. 그러면 열린 블록을 목록 항목에 연결하는 데 단일 목록 연속 행만 필요합니다.

.예제 3. 여러 목록 연속 대신 열린 블록 사용
[source,asciidoc]
--
* A list item that includes several blocks wrapped in an open block.
+ <1>
-- <2>
[source,yaml]
----
  artifacts:
    expire_in: 1 week
----

====
An example block
====

Another paragraph
--<2>
-- 
<1> 목록 항목에 열린 블록을 연결하는 단일 목록 연속.
<2> 여러 블록을 감싸는 열린 블록 구분 기호.

해당 예제가 렌더링될 때의 모습은 다음과 같습니다.

* A list item that includes several blocks wrapped in an open block.
+
--
[source,yaml]
----
  artifacts:
    expire_in: 1 week
----

====
An example block
====

Another paragraph
--


설명 목록 페이지에서 또 다른 복잡한 목록 예제를 찾을 수 있습니다.

*AsciiDoc 및 Asciidoctor 리소스*::
- Basic and complex ordered lists
- Basic and complex unordered lists
- List continuation



== AsciiDoc Primer - Lists - Description Lists

이 페이지에서는 다음을 배웁니다:

- AsciiDoc으로 설명 목록을 마크업하는 방법.
- 설명 내용에 다른 AsciiDoc 요소를 추가하는 방법.

설명 목록은 정의 목록이라고도 하며, 용어나 구문 및 그에 대한 설명 목록을 제공합니다.

=== 설명 목록 구문

설명 목록의 각 항목은 다음과 같이 용어나 구문으로 구성됩니다:

- 연속된 두 개의 콜론(::) 구분 기호,
- 그 다음 하나 이상의 공백이나 줄 바꿈,
- 마지막으로 항목에 대한 설명이나 정의.

==== 기본 설명 목록

다음은 두 개의 용어와 그 내용이 있는 설명 목록의 예입니다.
[source,asciidoc]
----
Keyboard:: 
Used to enter text or control items on the screen. <1>
Mouse:: Used to point to and select items on your computer screen. <2> 
----
<1> 용어와 설명은 별도의 줄에 배치할 수 있습니다.
<2> :: 와 설명 내용 사이에 최소한 하나의 공백이 있는 한 용어와 설명을 같은 줄에 배치할 수 있습니다.

렌더링될 때 각 항목의 설명은 용어 아래에 표시됩니다.

Keyboard:: 
Used to enter text or control items on the screen.
Mouse:: Used to point to and select items on your computer screen.

설명 목록의 내용은 모든 AsciiDoc 요소일 수 있습니다. 심지어 다른 목록 유형을 포함할 수도 있습니다.

===== 복잡한 설명 목록

단일 단락 이외의 내용을 포함하는 예제를 살펴보겠습니다.

.예제 1. 복잡한 내용을 포함하는 설명 목록
[source,asciidoc]
----
term 1::
This description needs two paragraphs.
To attach them both to term 1, use a list continuation (+) on the line separating the paragraphs.
+
This is the second paragraph for term 1.

term 2:: This description includes an admonition block.
Like additional paragraphs, blocks also need to be connected with a +.
+
NOTE: An admonition block that is part of term 2's description.

term 3::
* unordered list item
.. ordered list item
... another ordered list item
----

예제 1의 결과입니다.

term 1::
This description needs two paragraphs.
To attach them both to term 1, use a list continuation (+) on the line separating the paragraphs.
+
This is the second paragraph for term 1.

term 2:: This description includes an admonition block.
Like additional paragraphs, blocks also need to be connected with a +.
+
NOTE: An admonition block that is part of term 2's description.

term 3::
* unordered list item
.. ordered list item
... another ordered list item

목록 항목에 여러 블록을 첨부하는 것에 대한 추가 복잡한 목록 예제와 정보는 순서가 지정된 목록 및 순서가 지정되지 않은 목록 페이지에 있습니다.

.*AsciiDoc 및 Asciidoctor 리소스*
- Basic and complex description lists
- List continuation



== AsciiDoc Primer - Lists - Checklists

이 페이지에서는 다음을 배웁니다:

- AsciiDoc으로 체크리스트를 마크업하는 방법.
- AsciiDoc으로 클릭 가능한 체크리스트를 만드는 방법.

=== 체크리스트 구문

작업 목록은 선택되거나 선택되지 않은 것으로 표시된 목록 항목이 있는 순서가 지정되지 않은 목록입니다.

다음은 예제입니다:
.예제 1. 체크리스트 구문
[source,asciidoc]
----
* [*] checked
* [x] also checked
* [ ] not checked
----

예제 1의 결과는 아래와 같이 렌더링됩니다.

* [*] checked
* [x] also checked
* [ ] not checked

체크박스를 클릭 가능하게 만들려면 체크리스트에 interactive 옵션을 추가하세요. 여기서는 options의 단축 구문(%)을 사용하여 표시합니다.

.예제 2. 대화형 체크리스트 구문
[source,asciidoc]
----
[%interactive]
* [ ] Binge watch Death in Paradise
* [ ] Visit a tropical island
----

예제 2의 결과는 아래와 같이 렌더링됩니다. 상자를 클릭해 보세요.

[%interactive]
* [ ] Binge watch Death in Paradise
* [ ] Visit a tropical island

.*AsciiDoc 및 Asciidoctor 리소스*
- Checklists



== AsciiDoc Primer - Embed a Video

이 페이지에서는 다음을 배웁니다:

* [*] YouTube나 Vimeo 비디오를 페이지에 삽입하는 방법.

=== YouTube 또는 Vimeo 비디오 추가

YouTube나 Vimeo에서 호스팅되는 비디오를 삽입하려면 매크로 대상에 비디오의 ID를 넣고 대괄호 사이에 호스팅 서비스의 이름(youtube, vimeo)을 넣습니다.

.예제 1. 삽입된 YouTube 비디오 구문
[source,asciidoc]
----
video::rPQoq7ThGAU[youtube]
----

[TIP]
====
애니메이션 GIF는 이미지 매크로로 삽입합니다.
====

.*AsciiDoc 및 Asciidoctor 리소스*
- 비디오 매크로
- 비디오 매크로 옵션 및 속성



== AsciiDoc Primer - UI Macros

이 페이지에서는 다음을 배웁니다:

* [*] AsciiDoc으로 버튼(btn:[Submit] 누르기)을 마크업하는 방법.
* [*] AsciiDoc으로 키 바인딩(kbd:[Ctrl+Shift+N])을 마크업하는 방법.
* [*] AsciiDoc으로 메뉴(menu:View[Zoom > Reset])를 마크업하는 방법.

=== experimental 속성 설정

참조 UI에서 UI 매크로 스타일을 활성화하려면 experimental 속성을 페이지 속성, 컴포넌트 버전 속성 또는 사이트 속성으로 설정해야 합니다.

=== 버튼 구문

사용자가 버튼을 눌러야 한다는 것을 버튼 매크로로 전달합니다.

.예제 1. 버튼 UI 매크로
[source,asciidoc]
----
Press the btn:[Submit] button when you are finished the survey.

Select a file in the file navigator and click btn:[Open].
----

예제 1의 결과는 아래와 같이 표시됩니다.

====
Press the btn:[Submit] button when you are finished the survey.

Select a file in the file navigator and click btn:[Open].
====

=== 키 바인딩 구문

키 바인딩 매크로로 키보드 단축키를 만듭니다.

.예제 2. 키 바인딩 UI 매크로
[source,asciidoc]
----
Press kbd:[esc] to exit insert mode.

Use the shortcut kbd:[Ctrl+T] to open a new tab in your browser.

kbd:[Ctrl+Shift+N] will open a new incognito window.
----

예제 2의 결과는 아래와 같이 표시됩니다.

====
Press kbd:[esc] to exit insert mode.

Use the shortcut kbd:[Ctrl+T] to open a new tab in your browser.

kbd:[Ctrl+Shift+N] will open a new incognito window.
====

=== 메뉴 구문

메뉴 매크로로 읽는 사람에게 메뉴 항목을 선택하는 방법을 보여줍니다.

.예제 3. 메뉴 UI 매크로
[source,asciidoc]
----
To save the file, select menu:File[Save].

Select menu:View[Zoom > Reset] to reset the zoom level to the default setting.
----

예제 3의 결과는 아래와 같이 표시됩니다.

====
To save the file, select menu:File[Save].

Select menu:View[Zoom > Reset] to reset the zoom level to the default setting.
====



== AsciiDoc Primer - Source Blocks

=== 이 페이지에서 배울 내용

* [*] AsciiDoc 소스 블록을 만드는 방법.
* [*] 소스 블록의 소스 언어를 지정하는 방법.
* [*] source-language를 사용하여 전역 소스 언어를 지정하는 방법.
* [*] 소스 블록의 구문 강조를 비활성화하는 방법.

=== 소스 블록이란?

**AsciiDoc 소스 코드 블록** 또는 줄여서 **소스 블록**은 주어진 프로그래밍, 데이터, 구성 또는 마크업 언어로 작성된 콘텐츠 스니펫을 표시합니다. 소스 블록의 내용은 사이트에서 렌더링될 때 구문 강조기를 사용하여 색상이 지정됩니다. 소스 블록은 블록에 source 속성과 유효한 소스 언어의 이름을 할당하여 생성됩니다.

=== source와 소스 언어 속성

source 스타일은 위치 요소 속성입니다. 속성 목록의 첫 번째 위치를 사용하여 블록에 할당됩니다.

.예제 1. 속성 목록을 사용하여 source와 소스 언어를 직접 할당
[source,adoc]
----
[source,name-of-language] <1>
----
<1> 소스 언어의 이름은 속성 목록의 두 번째 위치 또는 source-language 문서 속성을 사용하여 할당됩니다. 소스 언어는 블록의 내용이 작성된 프로그래밍, 데이터, 구성 또는 마크업 언어의 이름입니다.

소스 언어를 지정하는 것은 두 가지 목적을 제공합니다. 첫째, 사이트 방문자에게 블록에 표시된 코드를 해석하는 데 필요한 언어 런타임 또는 데이터 형식 판독기를 알려줍니다. 둘째, 구문 강조기가 언어 유형 및 키워드를 강조 표시하는 등 소스 내용을 적절하게 색상화할 수 있도록 합니다. 마지막으로 블록에 언어를 할당하면 동시에 블록에 source를 암시적으로 할당할 수 있습니다. 예제 2에서 볼 수 있듯이 유효한 소스 언어의 이름을 속성 목록의 두 번째 위치에 할당하면 첫 번째 위치에 source를 암시적으로 할당합니다.

.예제 2. 속성 목록의 두 번째 위치에 소스 언어 할당
[source,adoc]
----
[,name-of-language] <1>
----
<1> source를 직접 할당하지 않고 속성 목록의 두 번째 위치에 소스 언어를 할당하려면 여는 대괄호 바로 뒤에 쉼표(,)를 입력한 다음 소스 언어의 이름을 입력합니다.

언어 이름은 소문자로 작성되어야 하며 내용이 올바르게 색상화되려면 Antora가 사용하는 구문 강조기에서 인식하는 언어여야 합니다. 대부분의 소스 블록이 동일한 언어를 사용하는 경우 source-language 문서 속성에 언어 이름을 할당할 수 있습니다.
source가 지정되었지만 소스 블록의 속성 목록이나 source-language 문서 속성에 언어가 지정되지 않은 경우 Antora는 런타임에 none 언어를 적용합니다. 블록은 다른 소스 블록과 같은 방식으로 스타일이 지정되지만 내용에는 구문 강조가 적용되지 않습니다.

=== 소스 블록 만들기

소스 블록은 주로 구분된 목록 및 리터럴 블록뿐만 아니라 단락에서 생성됩니다. 다음 시나리오에서 블록은 소스 블록이 됩니다:

- 언어 이름이 블록의 속성 목록의 두 번째 위치에 할당되어 속성 목록의 첫 번째 위치에 source를 암시적으로 할당합니다.
- source가 블록의 속성 목록의 첫 번째 위치에 직접 할당되고 언어 이름이 두 번째 위치 또는 source-language 문서 속성에 할당됩니다.
- source-language 문서 속성이 설정되어 다른 스타일이 할당되지 않은 모든 구분된 목록 블록을 자동으로 소스 블록으로 승격시킵니다.

이러한 방법 중 하나를 사용하여 블록에 source가 할당되면 블록의 내용은 구문 강조기에 의해 할당된 소스 언어에 따라 색상이 지정됩니다.

==== source를 암시적으로 할당

source는 속성 목록의 첫 번째 위치를 사용하여 블록에 할당되므로 여는 대괄호(,) 바로 뒤에 쉼표(,)를 입력한 다음 소스 언어의 이름을 입력하여 암시적으로 할당할 수 있습니다. 쉼표는 필수입니다. 그렇지 않으면 언어가 속성 목록의 첫 번째 위치에 할당됩니다. 예제 3은 목록 블록에 source 속성을 암시적으로 적용하는 방법을 보여줍니다.

.예제 3. 목록 블록에 source를 암시적으로 적용
[source,adoc]
----
[,name-of-language] <1>
-- <2>
Content of source block <3> 
  Content of source block

Content of source block
-- <4>
----
<1> 속성 목록의 여는 대괄호([) 바로 뒤에 쉼표(,)를 입력한 다음 블록의 내용이 작성된 소스 언어의 이름을 입력합니다. 닫는 대괄호(])로 속성 목록을 완성하고 kbd:[Enter] 키를 눌러 다음 줄로 이동합니다.
<2> 속성 목록 바로 아래의 새 줄에 목록 블록의 여는 구분 기호(----)를 입력한 다음 kbd:[Enter] 키를 눌러 다음 줄로 이동합니다.
<3> 여는 구분 기호 아래의 줄에 코드 스니펫을 삽입합니다.
<4> 새 줄에 목록 블록의 닫는 구분 기호(----)를 입력합니다.

소스 블록을 만들기 위해 다른 블록 유형에 source를 암시적으로 사용할 수 있습니다. 예제 4는 단락에 source 속성을 암시적으로 적용하는 방법을 보여줍니다.

.예제 4. 단락에 source 스타일 적용
[source,asciidoc]
----
A regular paragraph.

[,name-of-language] <1>
Content of source block <2> 

A regular paragraph.
----
<1> 속성 목록의 여는 대괄호([) 뒤에 쉼표(,)를 입력한 다음 블록의 내용이 작성된 소스 언어의 이름을 입력합니다. 닫는 대괄호(])로 속성 목록을 완성하고 kbd:[Enter] 키를 눌러 다음 줄로 이동합니다.
<2> 속성 목록 바로 아래의 줄에 하나 이상의 연속 줄에 블록의 내용을 입력합니다.

예제 5에서는 source를 암시적으로 할당하고 haskell을 언어로 할당합니다.

.예제 5. 블록에 source와 haskell 언어 할당
[source,adoc]
--
[,haskell]
----
main :: IO ()
main = putStrLn "Hello, World!"
----
--

예제 6은 사이트에 표시될 때 소스 블록이 어떻게 보이는지 보여줍니다.

.예제 6. 구문 강조가 적용된 렌더링된 소스 블록
[,haskell]
----
main :: IO ()
main = putStrLn "Hello, World!"
----

예제 6의 내용은 색상이 지정되며 블록 위로 마우스를 가져가면 오른쪽 상단 모서리에 언어 이름 HASKELL이 나타납니다.

==== source를 직접 할당

경우에 따라 블록에 source를 직접 할당하는 것이 좋습니다. 블록의 속성 목록에서 source는 목록의 첫 번째 위치에 입력되고 그 뒤에 쉼표(,)와 clojure, json, xml 등과 같은 언어 이름이 옵니다. 예제 7은 구분된 리터럴 블록(....)에 source 속성을 직접 적용하는 방법을 보여줍니다.

.예제 7. 블록에 직접 source 스타일 적용
[source,asciidoc]
--
[source,name-of-language] <1>
....
Content of source block
  Content of source block

Content of source block
....
--
<1> 속성 목록에서 source를 첫 번째 위치에 할당한 다음 쉼표(,)와 블록의 내용이 작성된 소스 언어의 이름을 입력합니다.

예제 8에서는 source를 첫 번째 위치에 할당하고 sql을 두 번째 위치의 언어로 할당합니다.

.예제 8. 블록에 source와 sql 언어 할당
[source,asciidoc]
--
[source,sql]
----
IF EXISTS (SELECT name FROM myobjects WHERE name = 'hello')
----
--

예제 9는 사이트에 표시될 때 소스 블록이 어떻게 보이는지 보여줍니다.

.예제 9. 구문 강조가 적용된 렌더링된 소스 블록
[source,sql]
----
IF EXISTS (SELECT name FROM myobjects WHERE name = 'hello')
----

예제 9의 내용은 색상이 지정되며 블록 위로 마우스를 가져가면 오른쪽 상단 모서리에 언어 이름 SQL이 나타납니다.

요소 ID, 역할 또는 옵션을 해당 단축 구문을 사용하여 소스 블록에 할당하려면 source 속성을 지정하고 속성에 ID, 역할 또는 옵션을 추가합니다. 예제 10은 source 속성과 요소 ID가 목록 블록에 할당되는 방법을 보여줍니다.

.예제 10. 소스 블록에 요소 ID 할당
[source,asciidoc]
--
[#element-id,name-of-language] <1> <2>
----
Content of source block
  Content of source block
----
--
<1> 속성 목록에서 첫 번째 위치에 요소 ID를 지정합니다. 요소 ID는 해시 기호(#)와 ID 이름을 사용하여 스타일(이 경우 비어 있음)에 직접 추가됩니다. 두 번째 위치에 언어가 지정되었으므로 source 스타일이 암시됩니다.
<2> 요소 ID 바로 뒤에 쉼표(,)를 입력한 다음 블록의 내용이 작성된 소스 언어의 이름을 입력합니다.

이제 구분된 리터럴 블록으로 생성되고 단축 해시 기호(#)를 사용하여 요소 ID가 할당된 소스 블록을 살펴보겠습니다. 예제 11에서는 #와 함께 암시적 source 스타일에 요소 ID가 추가됩니다. 줄 비교 구문 diff가 두 번째 위치에 할당됩니다.

.예제 11. 블록에 source, 요소 ID 및 diff 언어 할당
[source,asciidoc]
--
[#temper-change,diff]
....
-   temperDestination(destination)
+   if (destination instanceof Boom) moderateDestination(destination)
  }
  rootLoggerHolder.set(undefined, addFailOnExitHooks(logger, failureLevel))
....
--

예제 12는 사이트에 표시될 때 소스 블록이 어떻게 보이는지 보여줍니다.

.예제 12. 구문 강조가 적용된 렌더링된 소스 블록
[#temper-change,diff]
----
-   temperDestination(destination)
+   if (destination instanceof Boom) moderateDestination(destination)
  }
  rootLoggerHolder.set(undefined, addFailOnExitHooks(logger, failureLevel))
----

예제 12의 내용은 색상이 지정되며 블록 위로 마우스를 가져가면 블록의 오른쪽 상단 모서리에 언어 이름 DIFF가 나타납니다.

==== source-language로 목록 블록 승격

페이지, 구성 요소 버전 또는 사이트 수준에서 source-language 문서 속성을 설정하여 전역적으로 소스 언어를 정의할 수 있습니다. source-language가 설정되면 스타일이 할당되지 않은 모든 구분된 목록 블록이 자동으로 소스 블록으로 승격됩니다. source-language 속성은 페이지의 문서 헤더, 구성 요소 버전 설명자 파일 또는 플레이북에서 설정되고 값이 할당됩니다. 예제 13에서는 페이지의 헤더에 source-language 속성이 설정되고 언어 이름이 할당됩니다.

.예제 13. 문서 헤더에 source-language 설정
[source,adoc]
--
= Title of Page
:source-language: name-of-language <1>

A paragraph.

-- <2>
Content of source block
-- <2>

A paragraph.

.... <3>
Content of a literal block.
.... <3>
--

<1> 페이지 헤더의 새 줄에서 내장 문서 속성 source-language를 설정하고 값으로 언어 이름을 할당합니다.
<2> source-language가 설정되었기 때문에 이 목록 블록은 자동으로 소스 블록으로 승격됩니다.
<3> 이 리터럴 블록은 리터럴 블록으로 유지됩니다. source-language가 설정되면 목록 블록만 자동으로 소스 블록으로 승격됩니다.

source-language가 설정되면 일부 목록 블록을 소스 블록으로 승격하지 않거나 일부에 다른 언어를 할당하고 싶을 수 있습니다. 예제 14는 목록 블록이 소스 블록으로 승격되지 않도록 하는 방법과 source-language 속성에 할당된 언어를 재정의하는 방법을 보여줍니다.

.예제 14. 선택한 블록에서 source-language 재정의
[source,adoc]
--
= Title of Page
:source-language: java <1>

A paragraph.

-- <2>
Content of source block
-- <2>

A paragraph.

[listing] <3>
---- 
Content of listing block
----

[,yaml] <4>
----
Content of source block
----
--

<1> 문서 속성 source-language는 페이지의 헤더에 설정되고 값 java가 할당됩니다. 이 페이지의 모든 목록 블록 중 스타일이 직접 할당되지 않은 블록은 소스 블록으로 승격되고 소스 언어가 직접 할당되지 않은 모든 소스 블록에는 언어 java가 할당됩니다.
<2> 이 목록 블록은 자동으로 소스 블록으로 승격되고 언어 java가 할당됩니다. 이 블록의 내용은 JAVA로 식별되고 그에 따라 색상이 지정됩니다.
<3> 이 목록 블록에는 스타일 listing이 할당되므로 소스 블록으로 승격되지 않으며 내용에 색상이 지정되지 않습니다.
<4> 이 소스 블록에는 언어 yaml이 직접 할당됩니다. 따라서 블록의 내용은 YAML로 식별되고 그에 따라 색상이 지정됩니다.

다음 섹션에서는 색상 지정이 어떻게 추가되는지 살펴보겠습니다.

=== 구문 강조

구문 강조는 코드를 읽기 쉽게 만들기 위해 유형, 키워드 및 기타 언어 구성을 강조하여 코드에 색상을 지정하는 기술입니다. 소스 블록의 구문 강조는 source-highlighter 속성을 사용하여 활성화됩니다. Antora는 기본적으로 사이트 전체에 source-highlighter를 설정하므로(사이트 및 구성 속성 참조) 이 기능을 활성화하기 위해 특별히 해야 할 일은 없습니다. Antora는 highlight.js를 사용하여 소스 언어를 지정하는 소스 블록에 자동으로 구문 강조를 추가합니다.

구문 강조는 UI의 기여도 필요로 합니다. 참조 Antora UI는 highlight.js 라이브러리(JavaScript와 CSS 모두)를 번들로 제공하고 각 페이지에 추가합니다. 현재 지원되는 언어의 이름은 Antora의 UI 저장소에 있는 highlight.bundle.js 파일에 나열되어 있습니다.

플레이북 또는 구성 요소 버전 설명자에서 source-highlighter 속성을 비활성화하거나 재정의할 수 있습니다. 구문 강조를 비활성화하려면 플레이북에서 source-highlighter 속성을 설정 해제합니다.

.예제 15. antora-playbook.yml에서 source-highlighter 속성 비활성화
[source,yaml]
----
asciidoc:
  attributes:
    source-highlighter: ~
----

현재 참조 UI를 사용할 때 Antora가 지원하는 유일한 source-highlighter 값은 highlight.js입니다. 값을 rouge, pygments 또는 coderay로 설정하면 Antora가 실패합니다. 이러한 내장 빌드 시간 구문 강조기는 Antora 환경(특히 Asciidoctor.js)에서 사용할 수 없기 때문입니다.

prettify 또는 prism과 같은 다른 클라이언트 측(브라우저라고도 함) 라이브러리를 사용할 수 있습니다. 그러나 이를 사용하려면 참조 UI가 highlight.js에 대해 수행하는 것처럼 UI를 수정하여 라이브러리를 번들로 제공하고 각 페이지에 추가해야 합니다.

향후에는 다른 구문 강조기를 플러그인할 수 있도록 추가 어댑터를 등록할 수 있습니다. 그러나 현재 Antora에서는 해당 기능을 사용할 수 없습니다.

=== 더 알아보기

소스 블록의 내용은 종종 include 지시문을 사용하여 삽입됩니다. 자세한 내용은 Include an Example을 참조하세요.



== AsciiDoc Primer - Admonitions

=== 이 페이지에서 배울 내용

* [*] AsciiDoc으로 경고를 마크업하는 방법.
* [*] 복잡한 내용으로 경고를 만드는 방법.

=== 경고 스타일

경고(admonition), 또는 공지(notice)라고도 알려진 것은 특별한 레이블이나 아이콘으로 콘텐츠에 주의를 끌도록 도와줍니다. 다섯 가지 내장 경고 레이블이 있습니다.

- NOTE
- TIP
- IMPORTANT
- CAUTION
- WARNING

=== 기본 경고

경고 내용이 빈 줄로 중단되지 않으면 첫 번째 줄을 스타일 레이블로 시작합니다. 레이블은 모두 대문자여야 하며 콜론(:)과 하나의 공백이 뒤에 와야 합니다.

.예제 1. 기본 경고 구문
[source,adoc]
----
CAUTION: Don't stick forks in electric sockets.

TIP: After someone sticks a fork in a socket, you'll need to reset the circuit in the dark basement.

WARNING: Never go into the basement.

IMPORTANT: A monster lives in the basement.

NOTE: If you go into the basement, see if you can find Kenny's parka.
----

예제 1의 결과는 아래에 표시되어 있습니다.

CAUTION: Don't stick forks in electric sockets.

TIP: After someone sticks a fork in a socket, you'll need to reset the circuit in the dark basement.

WARNING: Never go into the basement.

IMPORTANT: A monster lives in the basement.

NOTE: If you go into the basement, see if you can find Kenny's parka.


=== 복잡한 경고

경고 내용에 빈 줄로 구분된 요소가 포함되어 있으면 내용을 구분된 예제 블록(====)에 넣습니다. 이 동작을 마스커레이딩(masquerading)이라고 합니다. 속성 목록([])에 모두 대문자로 적절한 레이블을 블록에 배치합니다.

.예제 2. 복잡한 경고 구문
[source,adoc]
----
[IMPORTANT]
.Optional Title
====
Use an example block to create an admonition that contains complex content, such as (but not limited to):

* Lists
* Multiple paragraphs
* Source code
* Images
====
----

예제 2의 결과는 아래에 표시되어 있습니다.

[IMPORTANT]
.Optional Title
====
Use an example block to create an admonition that contains complex content, such as (but not limited to):

* Lists
* Multiple paragraphs
* Source code
* Images
====

.*AsciiDoc과 Asciidoctor 자료*

- Admonition paragraphs and blocks



== AsciiDoc Primer - Examples

=== 이 페이지에서 배울 내용

* [*] AsciiDoc의 example을 마크업 하는 방법.

=== 예제 구문

예제 단락 또는 구분된 블록은 개념을 설명하는 내용이나 작업 결과를 시각적으로 구분하는 데 유용합니다. 예제는 모든 유형의 내용과 AsciiDoc 구문을 포함할 수 있습니다. 일반적인 대체가 예제 내용에 적용됩니다.

==== 예제 단락

예제 내용이 연속적이고 빈 줄로 중단되지 않는 경우 블록 이름 example을 속성 목록([])의 텍스트 바로 위에 직접 배치할 수 있습니다.

.예제 1. 예제 단락 구문
[source,adoc]
----
.Optional title
[example]
This is an example paragraph.
----

예제 1의 결과는 다음과 같습니다.

.Optional title
[example]
This is an example paragraph.

==== 구분된 예제 블록

예제 내용에 빈 줄로 구분된 요소가 포함된 경우 내용을 네 개의 등호(====)로 구성된 구분 기호 줄 사이에 배치합니다. 구분된 블록을 사용할 때는 블록 이름을 설정할 필요가 없습니다.

.예제 2. 구분된 예제 블록 구문
[source,adoc]
----
.Onomatopoeia
====
The book hit the floor with a *thud*.

He could hear doves *cooing* in the pine trees`' branches.
====
----

예제 2의 결과는 다음과 같습니다.

.Onomatopoeia
====
The book hit the floor with a *thud*.

He could hear doves *cooing* in the pine trees`' branches.
====



== AsciiDoc Primer - Sidebars

=== 이 페이지에서 배울 내용

* [*] AsciiDoc으로 sidebar를 마크업하는 방법.

=== 사이드바 구문

사이드바는 인용문, 방정식, 이미지와 같은 모든 유형의 내용을 포함할 수 있습니다. 일반적인 대체가 사이드바 내용에 적용됩니다.

==== 사이드바 단락

사이드바 내용이 연속적이면 블록 이름 sidebar를 속성 목록([])의 텍스트 바로 위에 직접 배치할 수 있습니다.

.예제 1. 사이드바 단락 구문
[source,asciidoc]
----
[sidebar]
Sidebars are used to visually separate auxiliary bits of content
that supplement the main text.
----

예제 1의 결과는 아래에 표시되어 있습니다.

[sidebar]
Sidebars are used to visually separate auxiliary bits of content
that supplement the main text.

=== 구분된 사이드바 블록

사이드바 블록은 네 개의 연속된 별표(pass:[****])로 구분됩니다. 구분된 블록을 사용할 때는 블록 이름을 설정할 필요가 없습니다.

.예제 2. 구분된 사이드바 블록 구문
[source,asciidoc]
----
.Optional Title
****
Sidebars are used to visually separate auxiliary bits of content
that supplement the main text.

TIP: They can contain any type of content.

.Source code block in a sidebar
[,js]
----
const { expect, expectCalledWith, heredoc } = require('../../../test/test-utils')
----
****
----

예제 2의 결과는 아래에 표시되어 있습니다.

.Optional Title
****
Sidebars are used to visually separate auxiliary bits of content
that supplement the main text.

TIP: They can contain any type of content.

.Source code block in a sidebar
[,js]
----
const { expect, expectCalledWith, heredoc } = require('../../../test/test-utils')
----
****



== AsciiDoc Primer - Comments

=== 이 페이지에서 배울 내용

* [*] AsciiDoc 파일에서 주석 줄 또는 블록을 작성하는 방법.

=== 주석 구문

AsciiDoc 소스 파일에 텍스트를 추가하고 싶지만 파일이 HTML 페이지로 변환될 때 해당 텍스트가 표시되지 않기를 원할 때 주석 줄이나 주석 블록을 사용할 수 있습니다.

주석 줄은 두 개의 연속된 슬래시(//)로 표시됩니다.

.예제 1. 주석 줄 구문
[source,asciidoc]
----
// This is a line that is commented out.
----

주석 블록은 네 개의 연속된 슬래시(////)로 구분됩니다.

.예제 2. 주석 블록 구문
[source,asciidoc]
----
////
This is a comment block.

All of the text, including any AsciiDoc syntax, won't be visible when the file is converted to HTML.
////
----


== Navigation

== Navigation - Navigation Assembly

Antora를 사용하면 AsciiDoc으로 구성 요소 버전의 탐색을 만들고 소스 파일과 함께 저장할 수 있습니다.

=== 탐색 어셈블리 요구 사항

사이트 탐색에는 다음이 필요합니다:

- 적어도 하나의 정렬되지 않은 AsciiDoc 목록을 포함하는 탐색 파일이 하나 이상 있어야 합니다.
- 구성 요소 버전 설명자 파일에 등록된 탐색 파일이 하나 이상 있어야 합니다.
- Antora의 참조 UI와 같이 Antora가 생성한 메뉴에 스타일과 상호 작용 동작을 적용할 수 있는 UI 번들이 있어야 합니다.

image::img/navigation-assembly.svg[]

이 다이어그램의 번호가 매겨진 각 항목을 간단히 살펴보겠습니다.

=== 1. 탐색 파일 (소스)

구성 요소 버전의 탐색은 하나 이상의 AsciiDoc 파일로 설명됩니다. 그러나 다이어그램에서 볼 수 있듯이 여러 파일에서 구성 요소 버전의 탐색을 조립할 수 있습니다. 모듈별로 탐색 파일을 만드는 것은 일반적인 조직 구조이지만 필수는 아닙니다.

탐색 파일에는 하나 이상의 글머리 기호 목록이 포함되어 있습니다. 목록의 각 항목은 페이지에 대한 상호 참조, 사이트의 일부가 아닌 웹사이트에 대한 URL 또는 중첩된 목록 항목 세트를 그룹화하는 카테고리 제목과 같은 연결되지 않은 텍스트일 수 있습니다. 여러 파일에서 탐색을 구성할 수 있습니다.

탐색 파일의 내용을 구성 요소 버전의 페이지 메뉴에 게시하려면 해당 구성 요소 버전 설명자 파일에 파일을 등록해야 합니다.

=== 2. 탐색 등록 (소스)

탐색 파일은 구성 요소 버전 설명자 파일의 nav 키 아래에 등록됩니다. 사이트의 게시된 구성 요소 버전 페이지 메뉴에 표시하려는 순서대로 탐색 파일을 나열합니다. Antora가 실행될 때 등록된 탐색 파일만 사용하여 구성 요소 버전 페이지 메뉴를 만듭니다.

=== 3. 구성 요소 버전 페이지 메뉴 (사이트)

Antora는 각 등록된 탐색 파일의 내용을 수집하고, nav 키 아래에 나열된 파일 순서대로 내용을 배치하고, 구성 요소 버전에 대해 완전히 조립된 페이지 메뉴를 게시합니다. 구성 요소 버전 페이지 메뉴의 동작과 스타일은 플레이북에 지정된 UI 번들에 의해 결정됩니다.

image::img/component-navigation-menu.png[]

=== 4. 구성 요소 버전 선택기 (사이트)

사이트에 여러 구성 요소 또는 구성 요소 버전이 있는 경우 Antora는 구성 요소와 해당 버전의 집계된 목록을 조립합니다. 이 구성 요소와 해당 구성 요소 버전의 메뉴가 구성 요소 버전 선택기입니다. Antora는 구성 요소를 알파벳 순서로 자동 나열합니다. 각 구성 요소 버전은 가장 큰 것 또는 최신 것부터 순서대로 정렬됩니다.

image::img/component-version-selector.png[]

참조 UI에서 이 목록은 모든 구성 요소 버전 페이지 메뉴 하단에 있는 "서랍"에 표시됩니다. 방문자가 서랍을 클릭하면 위로 확장되고 독자는 보고 싶은 구성 요소 버전을 선택할 수 있습니다.

=== 5. 페이지 버전 선택기 (사이트)

페이지가 구성 요소의 여러 버전에서 사용 가능한 경우 참조 UI의 해당 페이지에 드롭다운 선택기가 표시됩니다. 이 선택기에서 방문자는 해당 페이지의 다른 버전 간에 탐색할 수 있습니다. 페이지의 여러 버전을 사용할 수 있는 경우 Antora는 이 선택기를 자동으로 채웁니다.

image::img/page-version-selector.png[]



== Navigation - Navigation Files and Lists

구성 요소 버전의 pages 패밀리에 속하는 모든 소스 파일은 Antora에 의해 자동으로 사이트에 게시됩니다. 이는 방문자가 검색 도구, 다른 사이트 페이지의 링크, 그리고 일부 시나리오에서는 페이지 버전 선택기와 같은 드롭다운 메뉴를 통해 페이지를 찾을 수 있음을 의미합니다. 방문자가 구성 요소 버전 페이지 메뉴를 사용하여 페이지를 찾고 이동하려면 해당 페이지를 대상으로 하는 상호 참조가 탐색 파일의 목록에 입력되어야 합니다.

=== 탐색 파일이란?

**탐색 파일**은 AsciiDoc으로 마크업되고 모듈 디렉터리의 기본에 저장된 페이지 상호 참조, 외부 URL 및 기타 내용의 하나 이상의 목록입니다. _antora.yml_ 파일에 등록된 경우 탐색 파일의 내용은 구성 요소 버전 페이지 메뉴에 통합되어 사이트에 게시됩니다.

==== 파일 이름 및 형식

탐색 파일은 AsciiDoc 파일 확장자(.adoc)로 끝나야 합니다. 일반적으로 __nav.adoc__로 명명되지만, 의미 있는 이름을 사용할 수 있습니다. 그것이 팀을 기쁘게 한다면 탐색 파일의 이름을 __kaboom.adoc__으로 지정하세요.

=== 목록 구조

탐색 목록은 정렬되지 않은 AsciiDoc 목록입니다. 각 최상위 목록 항목은 5레벨(pass:[*****])까지 중첩된 항목을 가질 수 있습니다.

.예제 1. 단일 목록 구조
[source,asciidoc]
----
* Top level item
** Second level item
*** Third level item
*** Third level item
** Second level item
*** Third level item
**** Fourth level item
***** Fifth level item
* Top level item
* Top level item
----

최상위 목록 항목은 점(.)으로 표시되는 목록 제목이거나, 목록 제목이 없는 경우 단일 별표(*)로 표시된 각 목록 항목입니다. 파일에 여러 목록이 포함된 경우 각 목록은 목록 제목으로 시작해야 합니다.

.예제 2. 다중 목록 구조
[source,asciidoc]
----
.List title and top level item
* List item

.List title and top level item
* List item
** List item
----

탐색 파일에 목록이 하나만 포함된 경우 목록 제목은 선택 사항입니다. 단일 목록 탐색 파일에서 단일 별표 표시(*)가 있는 각 항목은 효과적으로 최상위 항목이 됩니다.

include 지시문을 사용하여 파일을 결합하여 탐색을 구성할 수 있습니다. 포함된 각 파일은 partials 디렉터리에 있어야 합니다. 포함된 파일의 탐색 목록을 현재 항목의 하위 항목으로 추가하려면 include 지시문을 열린 블록으로 묶어야 합니다. 여러 파일과 include 지시문을 사용하여 탐색 목록을 만드는 방법을 알아보려면 Compose Navigation Files을 참조하세요.

=== 목록 제목 및 항목

탐색 파일의 목록 제목과 항목에는 페이지에 대한 상호 참조, 외부 사이트에 대한 링크, 일반 텍스트 및 서식 있는 텍스트와 같은 여러 유형의 내용이 포함될 수 있습니다. 탐색 파일에서 가장 일반적인 항목은 동일한 구성 요소 버전 및 모듈에 속하는 페이지에 대한 xref이지만, 대상 리소스 ID는 다른 모듈 및 구성 요소의 페이지에 대한 것일 수도 있습니다.

[source,asciidoc]
----
.The Special Project <1>
* xref:index.adoc[] <2>
** xref:ROOT:get-started.adoc[] <3> 
** xref:team::contributing.adoc[] <4>

._Support_ <5>
* https://support.project.com[Get Help] <6>
* xref:help.adoc[*Troubleshooting*] <7>
----
<1> 일반 텍스트(링크되지 않음).
<2> 탐색 파일과 동일한 모듈에 속하는 페이지에 대한 xref. Antora는 사이트가 생성될  때 대상 지의 기본 탐색 링크 텍스트를 적용합니다.
<3> 탐색 파일과 동일한 모듈에 속하지 않는 페이지에 대한 xref.
<4> 탐색 파일과 동일한 구성 요소에 속하지 않는 페이지에 대한 xref.
<5> 인라인 서식이 적용된 링크되지 않은 텍스트.
<6> 외부 웹사이트에 대한 링크.
<7> 서식이 적용된 링크 텍스트를 가진 xref.

목록 항목은 첨부 파일도 참조할 수 있습니다.



== Navigation - Navigation Files and Lists - Create a Navigation File with One List

=== 단일 리스트 구조

단일 목록 탐색 파일에는 하나의 정렬되지 않은 AsciiDoc 목록이 포함되어 있습니다. 정렬되지 않은 목록은 목록 항목으로 구성됩니다.

[source,adoc]
----
* List item <1>
* List item <2>
** Nested item <3>
<4>
* List item
// Comment line <5> 
* List item
** Nested item <6>
*** Nested item
----
<1> 정렬되지 않은 AsciiDoc 목록 마커(*)가 앞에 오는 목록 항목.
<2> 각 목록 항목은 고유한 줄에 입력해야 합니다.
<3> 마커의 마지막 별표와 목록 항목의 내용 사이에 공백을 입력하세요.
<4> 목록 항목은 빈 줄로 구분할 수 있습니다.
<5> 목록 항목은 주석 줄로 구분할 수 있습니다.
<6> 중첩된 목록 항목.

각 목록 항목 앞에는 마커가 옵니다. 정렬되지 않은 AsciiDoc 목록의 마커는 별표 하나(pass:[*])부터 별표 다섯 개(pass:[*****])까지 범위가 있습니다.

목록 항목을 빈 줄이나 주석 줄로 구분할 수 있습니다. 목록이 구성 요소 버전 페이지 메뉴로 게시될 때 빈 줄은 HTML에서 제거되며 주석은 사이트 방문자에게 표시되지 않습니다.

==== 최상위 목록 항목 및 중첩

단일 목록 탐색 파일의 최상위 목록 항목은 단일 별표(*) 또는 첫 번째 항목이 목록 제목일 때 점(.)으로 표시됩니다. 목록 제목은 선택 사항입니다. 목록 항목과 달리 .와 제목 내용 사이에 공백이 없어야 합니다.

[source,asciidoc]
----
.List title <1>
* List item
* Another list item
** A nested list item
----
<1> 목록 제목은 전체 목록의 최상위 항목이 됩니다.

구성 요소 버전 페이지 메뉴로 변환되면 목록 제목은 해당 파일의 다른 모든 목록 항목(pass:[*]부터 pass:[*****]까지)에 대한 최상위 항목이 됩니다. 따라서 다른 모든 목록 항목은 제목 아래에 중첩됩니다.

목록에 제목이 없으면 단일 별표 마커(*)가 있는 각 항목은 바로 아래에 중첩된 목록 항목에 대한 최상위 항목이 됩니다.

[source,asciidoc]
----
* List item <1>
** A nested list item <2> 
* Another list item <3>
----
<1> 최상위 목록 항목.
<2> 이 목록 항목은 이전 최상위 목록 항목 아래에 중첩되어 있습니다.
<3> 최상위 목록 항목.

허용되는 최대 중첩 깊이는 레벨 5(pass:[*****])입니다. 각 목록 항목은 필요한 만큼 중첩된 항목을 가질 수 있습니다.

=== 단일 목록 탐색 파일 만들기

모듈의 페이지에 대한 단일 탐색 목록을 정의하는 __nav.adoc__라는 탐색 파일을 만들어 보겠습니다. 탐색 목록에서 가장 일반적인 항목은 탐색 파일과 동일한 모듈에 속하는 페이지에 대한 xref입니다. 아래 연습에서는 탐색 파일이 참조하는 페이지와 동일한 구성 요소 버전 및 모듈에 속한다고 가정합니다. 즉, 리소스 ID에 버전, 구성 요소 또는 모듈 좌표를 지정할 필요가 없습니다.

. 선택한 텍스트 편집기 또는 IDE에서 새 파일을 엽니다.

. 첫 번째 줄에 별표(*)를 입력하고 바로 뒤에 공백을 입력합니다. 그런 다음 xref 매크로 접두사와 대상 페이지의 리소스 ID를 입력합니다.
+
[source,asciidoc]
----
* xref:get-started.adoc
----

. 리소스 ID 끝에 대괄호([]) 세트로 매크로를 완성합니다. kbd:[Enter] 키를 눌러 다음 줄로 이동합니다.
+
[source,asciidoc]
----
xref:get-started.adoc[]
----
+
대괄호 안에 지정된 링크 텍스트가 없으므로 Antora는 사이트를 생성할 때 대상 페이지의 기본 링크 텍스트 값을 사용합니다.

. 중첩된 목록 항목을 추가해 보겠습니다. 별표 두 개(**)를 입력하고 공백을 입력한 다음 xref를 입력합니다. 이번에는 대괄호([]) 세트 안에 링크 텍스트를 입력합니다.
+
[source,asciidoc]
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
----
+
링크 텍스트 "설치 설정 및 단계"가 구성 요소 버전 페이지 메뉴에 표시됩니다.

. 이제 텍스트만 있는 다른 최상위 항목을 만들어 보겠습니다. 즉, 페이지 참조가 아닙니다. 다음 줄에 별표(*), 공백, 텍스트를 차례로 입력합니다.
+
[source,asciidoc]
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
* CLI Commands and Options
----

. 이제 이전 최상위 항목 아래에 목록 항목을 중첩합니다. 이 항목은 대상 페이지의 기본 링크 텍스트를 사용하는 상호 참조입니다.
+
[source,asciidoc]
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
* CLI Commands and Options
** xref:commands.adoc[]
----

. 마지막으로 이전 항목 아래에 목록 항목을 중첩합니다. 별표 세 개(***)를 입력하고 공백을 입력한 다음 xref를 입력합니다.
+
[source,asciidoc]
----
* xref:get-started.adoc[]
** xref:install.adoc[Installation Setup and Steps]
* CLI Commands and Options
** xref:commands.adoc[]
*** xref:commands-in-action.adoc[]
----

. 목록에 참조된 페이지 소스 파일이 포함된 모듈 디렉터리에 __nav.adoc__으로 파일을 저장합니다. 탐색 파일은 __pages__ 디렉터리와 동일한 계층 수준에 있어야 합니다. __pages__ 폴더에 저장하지 마세요!
+
[source]
----
📂 modules
  📂 a-module
    📂 pages
    📄 nav.adoc
----
+
확장자가 .adoc인 한 선택한 파일 이름으로 파일을 저장할 수도 있습니다.

이제 모듈의 탐색 파일을 만들었습니다! 구성 요소 버전 페이지 메뉴의 일부가 되도록 __antora.yml__에 등록해야 합니다.



== Navigation - Navigation Files and Lists - Create a Navigation File with Multiple Lists

=== 여러 목록 구조화

탐색 파일에는 여러 개의 정렬되지 않은 AsciiDoc 목록이 포함될 수 있습니다. 탐색 파일에 여러 목록이 포함된 경우:

- 각 목록은 목록 제목으로 시작해야 하며,
- 각 목록은 하나 이상의 빈 줄로 구분되어야 합니다.

[source,adoc]
----
.List title <1>
* List item
<2>
.Second list title <3>
* List item <4>
----
<1> 필수 목록 제목. 목록 제목 앞에는 점(.)이 옵니다. .와 제목 내용 사이에 공백이 없어야 합니다.
<2> 목록 사이에 필요한 빈 줄.
<3> 필수 목록 제목.
<4> 목록 항목.

HTML로 변환되면 목록 제목은 최상위 항목이 되고 모든 목록 항목은 계단식 순서로 그 아래에 중첩됩니다. 목록 사이의 빈 줄은 게시된 메뉴에 나타나지 않습니다.
각 탐색 목록은 목록 항목으로 구성됩니다.

.예제 1. 여러 목록이 있는 탐색 파일
[source,asciidoc]
----
.List title <1>
* List item <2>
* List item <3>
** Nested item <4> 

.List title <5>
* List item
** Nested item

.List title
* List item
----
<1> 목록 제목은 목록의 최상위 목록 항목이 됩니다.
<2> 정렬되지 않은 AsciiDoc 목록 마커(*)가 앞에 오는 목록 항목.
<3> 각 목록 항목은 고유한 줄에 입력해야 합니다.
<4> 마커의 마지막 별표와 목록 항목의 내용 사이에 공백을 입력하세요.
<5> 다른 탐색 목록의 시작을 나타내는 목록 제목.

각 목록 항목 앞에는 마커가 옵니다. 정렬되지 않은 AsciiDoc 목록의 마커는 별표 하나(pass:[*])부터 별표 다섯 개(pass:[*****])까지 범위가 있습니다.

=== 두 개의 목록이 있는 탐색 파일 만들기

모듈의 페이지에 대한 두 개의 탐색 목록이 포함된 탐색 파일을 만들어 보겠습니다. 탐색 목록에서 가장 일반적인 항목은 탐색 파일과 동일한 모듈에 속하는 페이지에 대한 xref입니다. 아래 연습에서는 탐색 파일이 참조하는 페이지와 동일한 구성 요소 버전 및 모듈에 속한다고 가정합니다. 즉, 리소스 ID에 버전, 구성 요소 또는 모듈 좌표를 지정할 필요가 없습니다.

. 선택한 텍스트 편집기 또는 IDE에서 새 파일을 엽니다.
. 첫 번째 줄에 점(.)을 입력하고 바로 뒤에 xref 매크로 접두사와 대상 페이지의 리소스 ID를 입력합니다.
+
[source,asciidoc]
----
.xref:get-started.adoc
----

. 리소스 ID 끝에 대괄호([]) 세트로 매크로를 완성합니다. kbd:[Enter] 키를 눌러 다음 줄로 이동합니다.
+
[source,asciidoc]
----
.xref:get-started.adoc[]
----
+
대괄호 안에 지정된 링크 텍스트가 없으므로 Antora는 사이트를 생성할 때 대상 페이지의 기본 링크 텍스트 값을 사용합니다.

. 목록 항목을 추가해 보겠습니다. 별표(*)를 입력하고 공백을 입력한 다음 xref를 입력합니다. 이번에는 대괄호([]) 세트 안에 링크 텍스트를 입력합니다. kbd:[Enter] 키를 누릅니다.
+
[source,asciidoc]
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]

.CLI Commands and Options
----
+
링크 텍스트 __Installation Setup and Steps__가 구성 요소 버전 페이지 메뉴에 표시됩니다.

. 새 목록을 시작해 보겠습니다. kbd:[Enter] 키를 눌러 목록 사이에 빈 줄을 삽입합니다. 새 줄에 점(.)을 입력하고 바로 뒤에 일반 텍스트를 입력합니다. 이 목록 제목은 페이지를 참조하지 않습니다.
+
[source,asciidoc]
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]

.CLI Commands and Options
----

. 다음 줄에 별표(*), 공백, xref 매크로를 차례로 입력합니다. 이 항목은 대상 페이지의 기본 링크 텍스트를 사용하는 상호 참조입니다.
+
[source,asciidoc]
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]

.CLI Commands and Options
* xref:commands.adoc[]
----

. 마지막으로 이전 항목 아래에 목록 항목을 중첩합니다. 별표 두 개(**)를 입력하고 공백을 입력한 다음 xref를 입력합니다.
+
[source,asciidoc]
----
.xref:get-started.adoc[]
* xref:install.adoc[Installation Setup and Steps]

.CLI Commands and Options
* xref:commands.adoc[]
** xref:commands-in-action.adoc[]
----

. 목록에 참조된 페이지 소스 파일이 포함된 모듈 디렉터리에 __nav.adoc__으로 파일을 저장합니다. 탐색 파일은 __pages__ 디렉터리와 동일한 계층 수준에 있어야 합니다. __pages__ 폴더에 저장하지 마세요!
+
[source]
----
📂 modules
  📂 a-module
    📂 pages
    📄 nav.adoc
----
+
확장자가 .adoc인 한 선택한 파일 이름으로 파일을 저장할 수도 있습니다.

이제 모듈의 탐색 파일을 만들었습니다! 구성 요소 버전 페이지 메뉴의 일부가 되도록 __antora.yml__에 등록해야 합니다.



== Navigation - Page Xrefs and Link Text

=== 페이지 xref

탐색 목록의 페이지에 대한 상호 참조는 AsciiDoc xref 매크로와 페이지의 리소스 ID를 사용하여 구성됩니다.

탐색 파일의 목록에 있는 xref는 대부분 탐색 파일과 동일한 모듈에 속하는 페이지를 대상으로 합니다. 이러한 경우 리소스 ID에는 버전, 구성 요소 또는 모듈 좌표가 필요하지 않습니다. 그러나 탐색 파일이 어떤 구성 요소 버전에 속하든 상관없이 다른 모듈이나 구성 요소에 속하는지 여부에 관계없이 모든 탐색 목록에서 사이트의 모든 페이지에 연결할 수 있습니다.

.예제 1. nav.adoc
[source,adoc]
----
* xref:filename.adoc[Optional link text] <1>
* xref:module:filename.adoc[] <2>
* xref:version@component:module:filename.adoc[] <3>
----
<1> 동일한 모듈에 있는 페이지를 대상으로 하는 xref. xref는 링크 텍스트도 지정합니다.
<2> 동일한 구성 요소 버전이지만 다른 모듈에 있는 페이지.
<3> 다른 문서 구성 요소에 있는 페이지.

탐색 파일의 xref는 대상 페이지의 기본 탐색 링크 텍스트를 사용하거나 매크로의 대괄호([]) 안에 지정된 링크 텍스트를 가질 수 있습니다. 링크 텍스트는 구성 요소 버전의 페이지 메뉴에 표시됩니다. 방문자가 링크 텍스트를 클릭하면 xref의 리소스 ID로 지정된 대상 페이지로 이동합니다. 링크 텍스트는 기본 링크 텍스트든 xref에 지정되어 있든 상관없이 대상 페이지 상단의 브레드크럼에도 표시됩니다.

=== 기본 탐색 링크 텍스트 사용

탐색 파일의 xref는 링크 텍스트를 지정할 필요가 없습니다.

.예제 2. nav.adoc
[source,adoc]
----
* xref:get-started.adoc[] <1>
----
<1> 매크로의 대괄호([]) 안에 링크 텍스트가 지정되지 않은 xref.

링크 텍스트가 지정되지 않은 경우 Antora는 대상 페이지의 선택적 navtitle 속성에 할당된 값을 사용합니다. navtitle이 대상 페이지의 헤더에 설정되어 있지 않으면 Antora는 자동으로 페이지의 참조 텍스트 값을 할당합니다. 이는 대상 페이지의 기본 참조 텍스트이거나 reftext 속성에 할당된 텍스트일 수 있습니다.

NOTE: 페이지의 리소스 ID에 프래그먼트가 추가되면 Antora는 xref의 링크 텍스트를 채우지 않습니다. 이러한 경우에는 여전히 링크 텍스트를 명시적으로 지정해야 합니다.

=== xref에서 링크 텍스트 지정

xref 매크로에 링크 텍스트를 직접 입력하고 대상 페이지에서 제공하는 기본 링크 텍스트를 재정의할 수 있습니다.

.예제 3. nav.adoc
[source,adoc]
----
.The Special Project
* xref:index.adoc[What's Silver Leaf] <1>
** xref:ROOT:get-started.adoc#prereqs[Installation Prerequisites] <2> 
** xref:team::contributing.adoc[] <3>

.Support
* xref:help.adoc[*Troubleshooting*] <4>
----
<1> xref 매크로의 대괄호([]) 사이에 링크 텍스트를 입력합니다.
<2> 대상 페이지의 리소스 ID에 프래그먼트가 추가된 xref는 링크 텍스트를 지정해야 합니다.
<3> 이 xref는 대상 페이지의 기본 탐색 링크 텍스트를 사용합니다.
<4> 지정된 링크 텍스트는 인라인 서식 구문으로 마크업될 수 있습니다.

xref 매크로에 지정된 링크 텍스트는 구성 요소 버전 페이지 메뉴에 표시됩니다.



== Navigation - Attachment Xrefs and Link Text

첨부 파일을 참조하려면 AsciiDoc xref 매크로와 첨부 파일의 리소스 ID를 사용하세요. attachment$ 패밀리 좌표는 첨부 파일의 리소스 ID에 지정되어야 합니다.

.예제 1. nav.adoc
[source,adoc]
----
 xref:attachment$filename.pdf[Our Brochure] <1>
* xref:version@component:module:attachment$filename.epub[Our Book] <2> 
----
<1> 탐색 파일과 동일한 구성 요소 버전 및 모듈에 속하는 첨부 파일을 대상으로 하는 xref.
<2> 리소스 ID가 탐색 파일과 다른 구성 요소 버전에 있는 첨부 파일을 지정하는 xref.

첨부 파일을 대상으로 하는 xref 매크로에 링크 텍스트를 지정하지 않으면 Antora는 구성 요소 버전의 페이지 메뉴에 첨부 파일의 URL을 링크로 표시합니다.

.예제 2. nav.adoc
[source,adoc]
----
* xref:attachment$sample-project.zip[]
----

예제 2에서 계산된 URL __pass:[+https://docs.example.com/component/version/module/_attachments/sample-project.zip+]__은 페이지 메뉴에 링크로 표시됩니다.
xref 매크로의 대괄호 사이에 링크 텍스트를 입력하여 지정할 수 있습니다.

.예제 3. nav.adoc
[source,adoc]
----
* xref:attachment$sample-project.zip[Practice Project]
----

예제 3을 사용하면 Antora는 Practice Project 텍스트를 페이지 메뉴의 링크로 표시합니다. 방문자가 링크를 클릭하면 브라우저는 첨부 파일의 파일 형식과 브라우저 설정에 따라 게시된 첨부 파일을 다운로드하거나 표시합니다.



== Navigation - Add Links to External Sites

탐색 목록에는 외부 웹사이트에 대한 링크가 포함될 수 있습니다. 외부 링크는 사이트의 Antora 파이프라인의 일부로 구축되지 않은 웹사이트 또는 자료에 대한 링크입니다. 즉, 대상은 구성 요소 버전에 속하지 않습니다.

=== 외부 링크

외부 웹사이트 및 자료에 대한 링크는 AsciiDoc URL 구문을 사용하여 만듭니다. AsciiDoc의 URL 구문은 대상에 유효한 URI 체계(예: pass:[https://])와 주소가 있어야 합니다.

[source,asciidoc]
----
* xref:get-started.adoc[]
** xref:install.adoc[]
* Support
** https://external-website.com[Link text]
** https://another-external-website.com
----

URL 끝에 대괄호([]) 세트를 직접 추가하고 링크 텍스트를 삽입하지 않으면 사이트가 생성될 때 원시 URL이 구성 요소 버전 페이지 메뉴에 표시됩니다.



== Navigation - Format List Content

링크 텍스트와 링크되지 않은 텍스트는 AsciiDoc의 인라인 서식 구문으로 서식을 지정할 수 있습니다.

=== 링크되지 않은 텍스트

탐색 목록의 모든 내용을 페이지, 리소스 또는 외부 사이트에 연결할 필요는 없습니다.

.예제 1. nav.adoc
[source,asciidoc]
----
* Unlinked Text
** xref:a-page.adoc[Linked Text]
* _Formatted Unlinked Text_
----

링크되지 않은 텍스트는 AsciiDoc의 인라인 서식 구문을 사용하여 서식을 지정할 수 있습니다.

=== 링크 텍스트

xref, link 또는 URL 매크로에 입력된 링크 텍스트는 인라인 AsciiDoc 구문을 사용하여 서식을 지정할 수 있습니다.

.예제 2. nav.adoc
[source,asciidoc]
----
* xref:index.adoc[*Bold link text*]
* https://external-website.com[Some __ita__lic letters]
----

페이지의 기본 링크 텍스트에 서식을 지정하려면 navtitle에 할당된 값을 마크업해야 합니다.



== Navigation - Navigation File Locations

=== 파일 위치

각 모듈 디렉터리에 자체 탐색 파일이 포함되는 것이 일반적인 패턴입니다. 모듈은 이미 개념이나 목표의 논리적 그룹을 나타내므로 해당 모듈 페이지에 대한 xref를 연속적이고 계층적인 탐색 메뉴 항목의 흐름으로 정렬할 가능성이 있습니다. 이렇게 하면 탐색 파일에 페이지를 추가할 때 xref의 리소스 ID에 필요한 좌표 수도 줄어듭니다.

탐색 파일은 모듈 디렉터리의 기본 위치, 즉 pages 패밀리 디렉터리와 동일한 수준에 저장해야 합니다. **탐색 파일을 pages 폴더 안에 저장하지 마세요**. 그렇지 않으면 탐색 파일이 페이지로 변환되고 페이지로 게시됩니다.

=== 모듈당 여러 파일

모듈 디렉터리에는 둘 이상의 탐색 파일이 포함될 수 있습니다. 이 기능은 antora.yml 파일에 탐색 파일을 등록할 때 탐색 목록 순서를 세밀하게 조정하는 데 도움이 됩니다.

=== 대체 저장 패턴

참조하는 모듈에 탐색 파일을 저장하면 입력된 페이지 상호 참조가 단순해집니다. 또한 작성자가 모듈에 페이지를 추가하거나 제거할 때 영향을 받는 탐색을 찾는 데 도움이 됩니다. 그러나 다른 모듈의 페이지(심지어 다른 구성 요소 버전의 페이지)에 대한 xref는 모든 모듈의 탐색 파일에 입력할 수 있습니다. 탐색 파일에서 만드는 상호 참조에 모듈 좌표(또는 구성 요소 이름 및 버전 좌표)를 추가하기만 하면 됩니다. 예를 들어, 구성 요소 버전의 ROOT 모듈에 단일 탐색 파일을 저장할 수 있으며 구성 요소 버전의 각 모듈에 탐색 파일을 두는 대신 ROOT 모듈의 탐색 파일에 해당 다른 모듈의 페이지에 대한 상호 참조를 직접 추가할 수 있습니다.



== Navigation - Compose Navigation Files

여러 파일에서 탐색 목록을 작성하려는 경우 목록을 재사용하거나, 여러 사람이 유지 관리할 수 있도록 구성하거나, 단순히 분할하려면 include 지시문을 사용할 수 있습니다.

=== 탐색 파일을 다른 파일에 포함

AsciiDoc include 지시문을 사용하여 한 탐색 파일을 다른 파일에 포함할 수 있습니다. include 지시문의 대상은 Antora가 분류하는 파일이어야 합니다. 즉, 페이지 또는 부분이어야 합니다. (Antora는 모듈의 루트 또는 modules 폴더에 있는 파일을 분류하지 않습니다).

탐색 목록 중 하나가 __modules/ROOT/partials/getting-started.adoc__ 파일에 정의되어 있다고 가정해 보겠습니다.

.예제 1. modules/ROOT/partials/getting-started.adoc
[source,asciidoc]
----
.Getting Started
* xref:download.adoc[]
* xref:install.adoc[]
* xref:run.adoc[]
----

이 부분 탐색 파일을 메인 탐색 파일 modules/ROOT/nav.adoc에 다음과 같이 포함할 수 있습니다:
.예제 2. modules/ROOT/nav.adoc
[source,asciidoc]
----
.Overview
* xref:index.adoc[]
* xref:contribute.adoc[]

\include::partial$getting-started.adoc[]
----

Getting Started 목록은 부분 파일에서 읽혀 Overview 목록 다음에 탐색에 포함됩니다.

=== 중첩된 목록 포함

경우에 따라 부분 목록이 탐색 트리의 어디에 포함될지 확실하지 않고 최상위 수준에 추가된다고 가정할 수 없습니다. 원하는 것은 포함된 목록에서 가져온 탐색 목록이 현재 목록 항목보다 한 수준 아래에 있는 것입니다.

이러한 레이아웃을 구현하려면 포함된 목록을 열린 블록으로 감싸세요:

[source,asciidoc]
----
* xref:parent.adoc[]
+
--
\include::partial$children.adoc[]
--
----

Antora는 이 관계를 인식하고 포함된 목록을 연결된 목록 항목의 하위 항목으로 융합합니다. (열린 블록 컨테이너는 버려집니다).

시작 항목이 익명 목록으로 __modules/ROOT/partials/getting-started.adoc__ 파일에 정의되어 있다고 가정해 보겠습니다.

.예제 3. modules/ROOT/partials/getting-started.adoc
[source,asciidoc]
----
* xref:download.adoc[]
* xref:install.adoc[]
* xref:run.adoc[]
----

이제 이 목록을 메인 탐색 파일의 Getting Started 항목의 하위 항목으로 포함할 수 있습니다.

.예제 4. modules/ROOT/nav.adoc
[source,asciidoc]
----
* xref:index.adoc[]
* xref:contribute.adoc[]
* Getting Started
+
--
\include::partial$getting-started.adoc[]
--
* xref:reference.adoc[]
----

부분 파일의 목록 항목은 Getting Started 항목의 하위 항목이 됩니다.



== Navigation - Register Navigation Files

=== nav 키

nav 키는 구성 요소 버전 설명자 파일(__antora.yml__)에 설정됩니다. 값으로 탐색 파일 목록을 받아들입니다. 각 값은 __antora.yml__을 기준으로 개별 탐색 파일의 경로를 지정합니다. nav 키를 설정하고 값을 할당하는 방법에 익숙하지 않은 경우 구성 요소 버전에 탐색 파일 할당을 참조하세요.

=== 탐색 파일 등록

탐색 파일이 nav 키에 할당되면 이 파일은 등록됩니다. 등록된 탐색 파일의 내용만 구성 요소 버전 페이지 메뉴로 조립되고 게시됩니다.
예제 1에서는 두 개의 탐색 파일이 등록되었습니다.

.예제 1. antora.yml 파일에서 두 개의 탐색 파일 등록
[source,yaml]
----
name: component-b
title: Component B
version: '1.0'
nav:
- modules/ROOT/nav.adoc <1> 
- modules/module-one/nav.adoc <2> 
----
<1> ROOT 디렉터리에 있는 탐색 파일을 등록하는 값.
<2> module-one 디렉터리에 있는 탐색 파일을 등록하는 값.

등록된 두 파일의 탐색 목록은 Component B 1.0의 단일 구성 요소 버전 페이지 메뉴로 게시됩니다.

=== 등록 순서

nav 키 값의 순서는 등록된 탐색 파일의 내용이 게시된 구성 요소 버전 페이지 메뉴에 조립되는 순서를 결정합니다. 예제 1에서 ROOT 모듈의 탐색 파일 내용은 구성 요소 버전 페이지 메뉴의 맨 위에 있고 Module One의 탐색 파일 내용은 ROOT 탐색 목록의 끝에 추가됩니다.



== Configure Your Site

== Configure Your Site - The Antora Playbook

이 페이지에서 다음을 배울 수 있습니다:

* [*] Antora 플레이북의 목적.
* [*] 플레이북 파일의 위치.
* [*] Antora가 허용하는 플레이북 파일 형식.

=== Antora 플레이북이란?

Antora 플레이북을 사용하면 기술 작가가 플레이북 파일을 사용하여 사이트에 포함된 콘텐츠, 적용된 사용자 인터페이스(UI) 및 사이트가 게시되는 위치를 쉽게 제어할 수 있습니다. 플레이북 파일의 설정은 CLI 옵션 및 환경 변수와 결합하여 Antora에 작동 방법을 알려줍니다.

특히, 플레이북은 Antora에 다음을 알려줍니다:

* [*] 제목 및 URL과 같이 사이트에 전체적으로 적용해야 하는 정보.
* [*] 사이트의 루트에 있는 페이지(예: 홈 또는 랜딩 페이지 콘텐츠).
* [*] Antora에 공급할 콘텐츠 리포지토리, 브랜치 및 태그.
* [*] 사이트 전체에 적용해야 하는 AsciiDoc 속성 및 Asciidoctor 확장.
* [*] 페이지의 시각적 레이아웃, 스타일 및 동작을 제어하는 데 사용할 UI 번들.
* [*] 사이트를 게시해야 하는 위치와 출력 형식.
* [*] Antora가 소스 리포지토리 업데이트, 아티팩트 업데이트 및 캐시를 처리하는 방법과 시기.

또한 플레이북 파일의 특정 설정은 CLI 옵션 또는 환경 변수를 사용하여 재정의할 수 있으므로 운영 팀이 프로덕션과 같은 특정 환경에 맞게 동작을 조정할 수 있습니다.

=== 플레이북은 어디에 저장되나요?

플레이북은 일반적으로 플레이북 프로젝트에 있습니다. 플레이북 프로젝트 리포지토리는 문서 사이트 생성을 담당합니다. 이것은 엄격히 코드로서의 구성 리포지토리입니다. 콘텐츠를 포함하지 않습니다. 대신 플레이북 파일과 특정 상황에서 추가 UI 파일 및 확장 코드를 포함합니다.

=== 플레이북 파일 형식

플레이북은 YAML, JSON 및 TOML로 작성할 수 있습니다. YAML은 자동화된 작업을 정의하는 데 일반적으로 사용되는 구성 언어이며 이 문서의 대부분의 플레이북 예제는 YAML을 사용합니다. 하지만 이러한 형식 중 어떤 것이든 자유롭게 사용할 수 있습니다.

형식에 관계없이 플레이북에는 일반 사이트 속성, 콘텐츠 및 UI 입력 소스, 게시된 출력 대상 및 제공자를 지정하기 위한 구조화된 키-값 쌍이 포함되어 있습니다.

=== 플레이북의 상대 경로

기본적으로 Antora는 현재 작업 디렉터리에서 플레이북의 상대 경로를 해석합니다. 예를 들어 경로 public은 실제로 $PWD/public입니다. 대신 Antora가 플레이북 파일이 있는 디렉터리에서 상대 경로를 해석하려면 경로 앞에 ./를 붙이세요(예: ./public).

상대 경로를 ./로 시작하면 플레이북을 더 이식 가능하게 만들 수 있습니다. 파일 시스템의 어떤 디렉터리에서든 antora 명령을 실행할 수 있으며 동작은 동일합니다.

상대 경로를 ./로 시작하지 않으면 Antora가 해석하는 경로는 현재 작업 디렉터리에 따라 달라집니다. 이식 가능한 동작을 얻으려면 antora 명령을 실행하기 전에 플레이북 파일이 있는 디렉터리로 전환해야 합니다.

경로를 현재 작업 디렉터리에 연결하려는 경우에만 일반 상대 경로를 사용하세요.



== Configure Your Site - Set Up a Playbook

YAML 형식으로 기본 플레이북 파일을 만들어 보겠습니다. 다음 섹션의 단계에서는 사이트 제목과 URL을 구성하고, Demo Component A 및 Demo Component B 리포지토리에서 소스 파일을 가져오고, 변환된 페이지에 Antora의 참조 UI를 적용하는 플레이북을 설정하는 과정을 안내합니다.

=== 사이트 속성 구성

먼저 사이트의 제목과 URL을 구성해 보겠습니다.

. 선택한 텍스트 편집기 또는 IDE에서 새 파일을 엽니다. 일반적으로 이 파일의 이름은 __antora-playbook.yml__입니다.

. 첫 번째 줄에 site:를 입력하고 kbd:[Enter]를 눌러 다음 줄로 이동합니다.
+
[source,yaml]
----
site:
----
+
site 키는 전역 사이트 속성을 정의하는 키-값 쌍의 맵을 허용합니다.

. title 키는 site의 하위 키입니다. title:을 입력한 다음 사이트의 제목이 될 텍스트를 입력합니다. kbd:[Enter]를 누릅니다.
+
[source,yaml]
----
site:
  title: My Demo Site
----

. url:을 입력한 다음 사이트의 기본 URL을 입력합니다.
+
[source,yaml]
----
site:
  title: My Demo Site
  url: https://docs.demo.com
----
+
url 키에 절대 URL을 할당하면 사이트맵과 같은 보조 기능이 활성화됩니다.

. 다음 줄에 start_page:를 입력하고 Antora가 사이트의 홈 페이지로 사용해야 하는 페이지의 페이지 ID를 입력합니다.
+
[source,yaml]
----
site:
  title: My Demo Site
  url: https://docs.demo.com
  start_page: component-b::index.adoc
----
+
위 예제의 start_page 값은 Component B에 속하는 파일 index.adoc의 최신 버전에 대한 페이지 ID입니다. Antora가 이 페이지를 사용하려면 Component B에 속하는 소스 파일을 찾을 위치를 Antora에 알려줘야 합니다.

다음 섹션에서는 콘텐츠 소스 URL, 브랜치 및 시작 경로를 정의해 보겠습니다.

=== 사이트의 콘텐츠 소스 구성

Antora는 소스 파일을 찾아 가져와야 하는 git 리포지토리, 브랜치 및 태그와 리포지토리의 루트에 있지 않은 콘텐츠 소스 루트의 위치를 알아야 합니다. 이전 섹션에서 시작한 플레이북 파일에서 이러한 키를 정의해 보겠습니다.

. 파일의 왼쪽에 붙여서 content:를 입력합니다. kbd:[Enter]를 눌러 다음 줄로 이동합니다.
+
[source,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
----

. sources 키는 content의 하위 키입니다. sources:를 입력하고 kbd:[Enter]를 누릅니다.
+
[source,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
----
+
sources 키에는 최소한 하나의 url 키에 원격 리포지토리 URL 또는 파일 시스템 경로가 할당되어야 합니다. 다음 단계에서 Demo Component A라는 원격 리포지토리의 URL을 url에 할당해 보겠습니다.

. 하이픈(-)과 공백을 입력합니다. 그런 다음 url:을 입력하고 콘텐츠 소스 리포지토리의 URL을 입력합니다.
+
[source,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
----
+
이제 Antora는 Demo Component A 리포지토리를 찾을 수 있습니다. 하지만 가져와야 할 브랜치와 태그도 알아야 합니다.
+
url 키에 branches 또는 tags 키가 설정되어 있지 않으면 런타임에 기본 브랜치 필터가 적용됩니다. Demo Component A 리포지토리에는 브랜치가 하나뿐이고 해당 브랜치의 이름(main)이 기본 필터의 매개변수 내에 있으므로 이 url 키에 명시적으로 branches를 설정할 필요가 없습니다.

. Demo Component B 리포지토리의 URL을 추가해 보겠습니다. 새 줄에 - url:과 리포지토리의 URL을 입력합니다.
+
[source,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
----
+
Demo Component B 리포지토리는 버전 관리에 브랜치를 사용합니다. 브랜치 v1.0과 v2.0의 콘텐츠 소스 파일은 게시할 준비가 되었습니다. 그러나 main 브랜치의 파일은 사이트에 게시해서는 안 되므로 이 url에 기본 브랜치 필터를 사용할 수 없습니다. 대신 Demo Component B 리포지토리에서 가져와야 할 브랜치를 Antora에 알려줘야 합니다.

. 다음 줄에 branches:와 여는 대괄호([)를 입력합니다. [내에 Antora가 가져와야 할 각 브랜치 이름을 입력합니다. 값을 쉼표로 구분합니다. 브랜치 이름을 나열하는 순서는 중요하지 않습니다. 목록 끝에 닫는 대괄호(])를 입력합니다. kbd:[Enter]를 누릅니다.
+
[source,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
----
+
TIP: branches를 충분히 들여쓰기하여 url의 u와 branches의 b가 정렬되도록 합니다.
branches 키는 셸 글로브 패턴(Shell Glob Pattern)도 허용합니다. 예를 들어 Demo Component B의 url 키에 branches: v*를 정의하여 Antora가 이름이 v1.0 및 v2.0인 브랜치를 가져오도록 지정할 수 있습니다.
+
Demo Component B 리포지토리의 키 구성이 아직 끝나지 않았습니다. 각 브랜치의 콘텐츠 소스 루트는 리포지토리의 루트에 있지 않고 docs에 있습니다. Antora가 콘텐츠 소스 루트를 찾을 수 있도록 url에 start_path 키를 설정해야 합니다.

. start_path:를 입력하고 리포지토리 루트 상대 경로를 입력합니다.
+
[source,yaml]
----
# ...
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
    start_path: docs
----
+
경로에 선행 슬래시나 후행 슬래시를 추가하지 마세요.

이제 Antora에 사이트에 적용해야 할 UI를 알려줄 필수 키 집합을 구성할 준비가 되었습니다.

=== 사이트의 UI 번들 구성

Antora는 사이트를 생성하려면 UI 번들이 필요합니다. 이전 섹션에서 작업한 플레이북 파일에 필요한 키를 정의하여 Antora에 참조 UI 번들을 사용하도록 지시해 보겠습니다.

. 파일의 왼쪽에 붙여서 ui:를 입력합니다. kbd:[Enter]를 눌러 다음 줄로 이동합니다.
+
[source,yaml]
----
# ...
    start_path: docs
ui:
----

. bundle 키는 ui의 하위 키입니다. bundle:을 입력하고 kbd:[Enter]를 누릅니다.
+
[source,yaml]
----
# ...
    start_path: docs
ui:
  bundle:
----

. url 키는 bundle의 하위 키입니다. url:을 입력한 다음 Antora의 참조 UI 번들 URL을 입력합니다.
+
[source,yaml]
----
# ...
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
----
+
Antora의 참조 UI 아카이브는 시간이 지남에 따라 변경되지만 URL은 변경되지 않으므로 snapshot 키를 활성화해야 합니다.

. 다음 줄에 snapshot:과 값 true를 입력합니다.
+
[source,yaml]
----
# ...
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----
+
snapshot이 true로 설정되면 플레이북 또는 CLI에서 fetch가 활성화될 때마다 Antora는 UI 번들을 다운로드합니다.

거의 다 왔습니다! 지금까지 작성한 전체 플레이북 파일은 다음과 같습니다.

[source,yaml]
----
site:
  title: My Demo Site
  url: https://docs.demo.com
  start_page: component-b::index.adoc
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-a.git
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.0, v1.0]
    start_path: docs
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
----


이 플레이북은 지정된 리포지토리 브랜치의 콘텐츠 파일과 지정된 UI 번들의 UI 파일을 사용하여 My Demo Site라는 사이트를 생성합니다.

이 플레이북에서 Antora를 실행하기 전에 해야 할 일은 저장하는 것뿐입니다. 플레이북 파일은 종종 __antora-playbook.yml__ 또는 사용되는 컨텍스트에 따라 __local-antora-playbook.yml__과 같은 관련 파일 이름으로 저장됩니다.

플레이북 파일을 저장하면 Antora를 실행할 준비가 된 것입니다.

TIP: Demo Docs Site 리포지토리에서도 이 플레이북을 얻을 수 있습니다.



== Configure Your Site - Site Keys

site 아래에 구성된 플레이북 키는 사이트가 게시된 후 사이트의 게시된 ID와 특정 애플리케이션과의 상호 작용 방식을 관리합니다.

=== site 키

전역적으로 생성된 사이트 파일, 서비스 계정 및 기타 공통 속성은 플레이북 파일의 site 키 아래에 정의됩니다. 이러한 설정은 사이트가 생성될 때 전체 사이트에 적용됩니다.

[source,yaml]
----
site: <1>
  title: Docs Site <2> 
  url: https://docs.example.org <3> 
  start_page: component-b::index.adoc <4> 
  robots: allow <5>
  keys: <6>
    google_analytics: XX-123456 <7>
----
<1> 필수 site 키
<2> 필수 title 키
<3> 선택적 url 키
<4> 선택적 start_page 키
<5> 선택적 robots 키
<6> 선택적 keys 키
<7> 예제 google_analytics 키

site 범주의 title 키는 필수입니다. url 키는 선택 사항이지만 권장됩니다. 자세한 내용은 사이트 URL을 설정해야 하는 경우를 참조하세요. 다른 키는 선택 사항입니다. 지정하지 않으면 Antora는 기본값을 사용합니다. 또는 title, start_page 및 keys를 CLI에서 할당할 수 있습니다. url 키는 CLI 또는 환경 변수를 사용하여 할당할 수 있습니다.

=== 사용 가능한 사이트 키
[cols="1,3,1", options="header"]
|===
| 사이트 키 | 설명 | 필수

| keys
| UI 템플릿 또는 확장에서 참조할 계정 및 API 키. Google Analytics와 같은 서비스 통합을 위한 계정 식별자를 지정하는 이름-값 쌍의 맵을 받아들입니다.
| 아니오

| robots
| Antora가 robots.txt 파일을 생성할지 여부를 지정합니다. allow, disallow 값과 사용자 정의 다중 행 문자열을 받아들입니다. 형제 url 키가 설정되지 않은 경우 무시됩니다.
| 아니오

| start_page
| 사이트의 시작 페이지를 지정하는 페이지의 리소스 ID를 받아들입니다.
| 아니오

| title
| 사이트의 제목을 지정합니다.
| 예

| url
| 사이트의 기본 URL을 지정합니다.
| 아니오
|===


== Configure Your Site - Site Keys - Site URL

=== url 키

플레이북의 site 키 아래에 정의된 사이트의 url 키는 선택 사항이지만 권장됩니다. 이 키가 설정되지 않으면 사이트 URL이 필요한 사이트의 특정 기능이 자동으로 비활성화됩니다. 자세한 내용은 사이트 URL을 설정해야 하는 경우를 참조하세요.

.예제 1. antora-playbook.yml
[source,yaml]
----
site:
  title: Site Title
  url: https://docs.example.com
----

url 키는 사이트가 게시된 후 액세스할 수 있는 위치를 정의합니다. url 키의 값은 절대 URL(pass:[https://docs.example.com, https://example.com/docs]) 또는 루트 상대 URL(/products)일 수 있습니다. 값이 단일 슬래시(/)가 아닌 한 **url 값의 끝에 후행 슬래시를 포함하지 마세요**.

사이트 URL은 절대 URL 또는 루트 상대 URL이 필요한 생성된 사이트의 모든 곳에 나타납니다. 자세한 내용은 How Antora Builds URLs을 참조하세요.

또는 --url 옵션을 사용하거나 URL 환경 변수를 사용하여 CLI에서 url 키를 할당할 수 있습니다.

=== 절대 사이트 URL 구성

절대 URL 값은 URL 체계 다음에 콜론과 두 개의 슬래시(pass:[https://])와 도메인(docs.example.org)이 바로 따라옵니다. URL 끝에 후행 슬래시를 넣지 마세요.

.예제 2. antora-playbook.yml
[source,yaml]
----
site:
  title: Docs for Example Site
  url: https://docs.example.com
----

절대 사이트 URL에는 하위 경로(예: pass:[https://example.com/docs, https://example.com/path/to/subfolder])가 포함될 수 있습니다. **경로 세그먼트** 또는 **경로 이름**이라고도 하는 **하위 경로**는 Antora에서 관리하는 사이트가 게시되는 도메인 루트에서의 위치를 나타냅니다. 사이트가 도메인의 하위 폴더에 게시되는 경우 절대 사이트 URL에는 이 경로가 포함되어야 합니다. 하위 경로는 루트 상대 URL과 동일한 구문을 갖습니다.

.예제 3. antora-playbook.yml
[source,yaml]
----
site:
  title: Docs for Example Site
  url: https://example.com/docs
----

절대 사이트 URL에 하위 경로가 있는 경우 Antora는 하위 경로를 추출하여 도메인 상대 URL이 필요한 모든 곳에서 사용할 수 있도록 사이트 경로 이름(/docs, /path/to/subfolder)에 할당합니다.

사이트를 도메인 하위 폴더에 게시하는 것에 대한 자세한 내용은 사이트 URL에 하위 경로를 포함해야 하는 경우를 참조하세요.

=== 루트 상대 사이트 URL 구성

루트 상대 URL은 도메인 자체를 지정하지 않고도 도메인을 기준으로 하는 URL입니다. 루트 상대 URL은 슬래시(/products)로 시작해야 합니다.

.예제 4. antora-playbook.yml
[source,yaml]
----
site:
  title: Docs Hosted Somewhere
  url: /products
----

동일한 사이트를 여러 도메인에 게시하거나 여러 도메인을 통해 액세스할 수 있어야 하는 경우 절대 URL 대신 루트 상대 URL을 사용할 수 있습니다. 루트 상대 URL을 사용하면 사이트 URL 할당의 많은 이점을 활용할 수 있습니다. 그러나 url에 할당된 값이 절대값이 아닌 경우 Antora는 절대 사이트 URL에 의존하는 모든 기능을 비활성화합니다.

Antora는 루트 상대 URL을 도메인 상대 URL을 계산하기 위한 사이트 경로 이름에 직접 할당합니다. url을 루트 상대 URL로 설정하되 사이트 경로 이름을 비워 두려면 값을 단일 슬래시로 설정하세요.

.예제 5. antora-playbook.yml
[source,yaml]
----
site:
  title: The Docs
  url: /
----

=== 사이트 URL을 설정해야 하는 경우

Antora 사이트는 오프라인에서 로컬 파일 시스템에서 볼 수 있도록 설계되었습니다. 이러한 이유로 사이트를 구축하는 데 사이트 URL이 필요하지 않습니다.

그러나 사이트 URL, 심지어 절대 URL까지도 필요로 하는 게시와 관련된 특정 기능들이 있습니다. 사이트 URL이 설정되지 않으면 이러한 기능은 알림 없이 자동으로 비활성화됩니다. 이 섹션에서는 이러한 기능과 필요한 사이트 URL의 종류를 식별합니다.

==== 사이트 URL에 의존하는 기능

사이트 URL이 허용 가능한 값으로 설정되면 다음 기능이 활성화됩니다:

- site-url 속성이 모든 AsciiDoc 문서에 설정됩니다.
- site.url 속성이 UI 모델에 설정됩니다(플레이북의 site.url 키 값 사용).
- 사이트 경로 이름 속성 site.path가 UI 모델에 설정됩니다(플레이북의 site.url 키에서 파생).
- 404 페이지가 생성됩니다.
- site.robots가 플레이북에도 정의된 경우 robots.txt 파일이 생성됩니다.
- 리디렉션에는 사이트 경로 이름(site.path)이 포함됩니다(비어 있지 않은 경우). 이는 - 상대 URL을 사용하는 정적 리디렉션 기능에는 영향을 미치지 않습니다.
- 탐색 막대의 왼쪽 상단 모서리에 있는 링크는 상대 경로 대신 사이트 URL을 가리킵니다(기본 UI에 특정한 동작).

사이트 URL이 절대 URL로 설정되면 다음과 같은 추가 기능이 활성화됩니다:

- 사이트맵 파일이 생성됩니다.
- page.canonicalUrl이 UI 모델에 설정되며, 이는 참조 UI에서 헤드에 정식 링크 태그를 생성하는 데 사용됩니다.

사이트 URL이 설정되지 않으면 앞서 언급한 모든 기능이 비활성화됩니다.

==== 사이트 URL에 하위 경로를 포함해야 하는 경우

사이트 URL의 하위 경로는 Antora에서 관리하는 사이트가 위치한 도메인의 루트에서의 위치를 나타냅니다. 즉, 사이트 URL은 방문자를 사이트 시작 페이지에 대한 리디렉션이 위치한 URL로 안내합니다. 사이트가 도메인의 하위 폴더에 게시되는 경우 사이트 URL에는 이 경로(/path/to/subfolder)가 포함되어야 합니다.

필요한 경우 Antora는 사이트 URL을 사용하여 사이트의 페이지에 대한 절대 및 도메인 상대 URL을 구성하며, 이는 항상 지정된 경우 하위 경로를 포함합니다. 여기에는 사이트맵(절대 URL)의 URL과 재작성 규칙(도메인 상대 URL)이 포함됩니다.

서버 리디렉션 규칙을 만들 때 하위 경로가 사용되는 방법의 예를 살펴보겠습니다. 다음 조건이 참이라고 가정해 보겠습니다:

- 사이트가 example.com 도메인의 docs 하위 폴더에 게시됩니다.
- 버전 없는 component-a 구성 요소의 ROOT 모듈에 있는 new-page.adoc 페이지는 페이지 별칭 old-page.adoc을 정의합니다(즉, old-page.adoc의 이름이 new-page.adoc으로 변경되었음).
- 리디렉션 기능이 nginx로 설정됩니다.
- 플레이북에서 사이트 url 키를 pass:[https://example.com(잘못된 값)]으로 설정합니다.

Antora를 실행하면 다음과 같은 리디렉션 규칙이 생성됩니다:

.예제 6. 하위 경로를 포함하지 않는 리디렉션 항목
[source,text]
----
/component-a/old-page.html /component-a/new-page.html 301!
----

리디렉션 규칙의 도메인 상대 URL에 /docs 세그먼트가 포함되어 있지 않습니다. 즉, pass:[https://example.com/docs/component-a/old-page.html]을 방문하면 규칙이 일치하지 않으므로 새 페이지로 리디렉션되지 않습니다. 이를 수정해 보겠습니다.
플레이북을 편집하고 url 키를 pass:[https://example.com/docs]로 설정합니다. 이제 Antora를 실행하면 올바른 리디렉션 규칙이 생성됩니다:

.예제 7. 하위 경로를 포함하는 리디렉션 항목
[source,text]
----
/docs/component-a/old-page.html /docs/component-a/new-page.html 301!
----

도메인 상대 URL에 /docs 세그먼트가 포함되어 있습니다. 이제 pass:[https://example.com/docs/component-a/old-page.html]을 방문하면 새 페이지로 리디렉션됩니다.

사이트를 도메인의 하위 폴더에 게시하는 경우 절대 사이트 URL에 경로를 포함하는 것이 중요합니다. 사이트를 특정 도메인에 연결하지 않으려면 루트 상대 사이트 URL을 대신 할당하세요. 어느 쪽이든 사이트를 도메인의 하위 폴더에 게시하는 경우 사이트의 url 키에 할당하는 값에 하위 경로를 포함해야 합니다.

=== 정식 URL

Antora는 정식 URL에 대한 기본 지원을 제공합니다. **정식 URL**은 페이지의 선호 버전에 대한 절대 URL입니다. 검색 엔진이 색인하기를 원하는 페이지입니다.

사이트 URL에 절대 URL을 할당하면 Antora는 정식 URL을 계산하여 해당 페이지에 대한 UI 모델의 page.canonicalUrl 속성에 할당합니다. 해당 페이지는 적어도 하나의 사전 릴리스가 아닌 버전이 있는 구성 요소의 모든 게시 가능한 페이지입니다. 사이트 URL이 절대 URL로 설정되지 않았거나 페이지가 적어도 하나의 사전 릴리스가 아닌 버전이 있는 구성 요소에 없는 경우 Antora는 정식 URL을 채우지 않습니다.

정식 URL은 페이지의 최신 사전 릴리스가 아닌 버전의 절대 URL입니다. 정식 URL은 사이트 URL(하위 경로 포함)을 해당 페이지의 (루트 상대) URL 앞에 추가하여 계산됩니다.
정식 URL은 현재 페이지가 최신 사전 릴리스가 아닌 버전인 경우에만 현재 페이지를 가리킵니다. 그렇지 않으면 정식 URL은 현재 페이지의 최신 사전 릴리스가 아닌 버전을 가리킵니다.

CAUTION: 페이지가 삭제된 경우 페이지의 최신 버전이 구성 요소의 최신 버전에 없을 수 있습니다.

==== 정식 URL 링크 태그

정식 URL이 검색 크롤러에 의해 선택되려면 UI 템플릿에 페이지에 포함되어야 합니다. 정식 URL은 페이지의 <head> 태그 내에 있는 <link rel="canonical"> 태그의 href 속성 값으로 선언되어야 합니다. Antora의 기본 UI는 이를 자동으로 처리합니다. 다음은 이 <link> 태그를 생성하는 Antora의 기본 UI에서 가져온 템플릿 로직입니다:

[source,hbs]
----
{{#with page.canonicalUrl}}
<link rel="canonical" href="{{{this}}}">
{{/with}}
----

생성된 페이지에서 정식 URL은 다음과 같이 나타납니다:

[source,html]
----
<link ref="canonical" href="https://docs.example.org/component-name/2.0/page-name.html">
----

정식 URL이 참조하는 페이지가 구성 요소의 모든 버전에 존재한다고 가정하면, 페이지의 모든 버전에 동일한 <link> 태그가 포함됩니다. 페이지가 사전 릴리스 버전에 있는 경우 최신(사전 릴리스가 아닌) 버전의 페이지를 참조합니다.

사용자 정의 UI의 작성자가 페이지 템플릿에 정식 URL을 포함할지 여부를 결정합니다. Antora는 단순히 UI 페이지 모델을 통해 정보를 사용할 수 있게 합니다. Antora의 기본 UI는 페이지 템플릿에 필요한 태그를 포함합니다.

==== 정식 URL의 작동 방식

정식 URL의 목적은 검색 엔진이 동일한 페이지의 버전을 상호 연관시키고 페이지의 선호 버전(즉, 색인할 버전)을 제안하는 데 도움을 주는 것입니다. 검색 엔진이 현재 URL과 다른 정식 URL이 있는 페이지를 발견하면 해당 페이지를 색인하지 않고 정식 URL이 가리키는 페이지를 색인해야 합니다. 정식 URL을 정의함으로써 페이지의 이전 버전이 검색 결과에 표시되지 않도록 해야 합니다.

한 가지 주의할 점은, 페이지가 구성 요소의 이전 버전에는 존재하지만 최신 버전에는 없는 경우, 정식 URL(canonical URL)이 이전 버전의 페이지를 가리키게 되어 그 페이지가 색인될 수 있다는 것입니다. 이를 방지하려면, 구성 요소의 최신 버전에서 다른 페이지가 해당 페이지를 페이지 별칭(page alias)을 사용하여 대신 참조하도록 해야 합니다. 이렇게 하면 Antora가 정식 URL이 최신 버전의 해당 페이지를 가리키도록 구성하여, 이전 버전의 페이지가 색인되는 것을 방지할 수 있습니다.

URL 검사 도구를 사용하여 Google이 페이지에 대해 감지한 정식 URL을 확인하고 페이지가 색인되었는지 확인하세요. 중복 URL 통합 및 정식 URL을 참조하여 정식 URL에 대해 자세히 알아보고 Google과 같은 검색 엔진이 이를 어떻게 해석하는지 확인하세요.



== Configure Your Site - Site Keys - Site Title

=== title 키

title 키는 필수입니다. 플레이북의 site 키 아래에 구성됩니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
site:
  title: Site Title
  url: https://example.org
----

title 키는 UI가 사이트의 제목을 호출하는 곳마다 표시되는 문자열을 받아들입니다. title 키는 CLI에서도 할당할 수 있습니다.

=== 사이트 제목 추가

title 키를 사용하여 사이트에 제목을 추가하세요.

.예제 2. antora-playbook.yml
[source,yaml]
----
site:
  title: Demo Docs Site
----

제목은 사이트의 UI가 이 키를 호출하는 곳마다 표시됩니다. Antora의 참조 UI는 전역 탐색 막대의 왼쪽 상단 모서리에 사이트 제목을 표시합니다.



== Configure Your Site - Site Keys - Site Start Page

플레이북의 start_page 키에 페이지의 유효한 리소스 ID를 할당하면 사이트 방문자는 사이트 URL의 사이트 인덱스 페이지에서 시작 페이지의 URL로 리디렉션됩니다.

=== start_page 키

start_page 키는 선택 사항입니다. 플레이북의 site 키 아래에 구성됩니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
site:
  title: Site Title
  url: https://example.org
  start_page: component:module:file-coordinate-of-page.adoc
----

구성 요소 버전에 속하는 모든 페이지를 사이트의 인덱스 페이지로 사용할 수 있습니다. start_page 키는 페이지의 리소스 ID를 값으로 받아들입니다. **리소스 ID에는 구성 요소, 모듈 및 파일 좌표가 포함되어야 합니다**. 최신 버전 대신 특정 버전의 페이지를 사용하려면 버전 좌표를 지정할 수 있습니다. 또는 CLI에서 start_page를 할당할 수 있습니다.

사이트에 버전 없는 ROOT라는 이름의 구성 요소(즉, name: ROOT, version: ~)가 있는 경우 해당 구성 요소는 사이트의 루트에 게시됩니다. 구성 요소 이름은 해당 페이지의 URL에 나타나지 않습니다. 즉, 버전 없는 ROOT 구성 요소의 __ROOT__ 모듈(즉, __modules/ROOT/pages/index.adoc__)의 __index.adoc__ 페이지는 플레이북에서 지정하지 않아도 암시적으로 사이트 시작 페이지 역할을 합니다. 즉, 사이트 시작 페이지는 ROOT::index.adoc입니다. 이 경우 다른 사이트 시작 페이지를 지정하면 사이트에 이미 시작 페이지가 있으므로 무시됩니다.

=== 페이지의 최신 버전 사용

start_page 키가 항상 지정된 페이지의 최신 버전을 가리키게 하려면 페이지의 리소스 ID에 버전 좌표를 입력하지 마세요.

.예제 2. antora-playbook.yml
[source,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  start_page: component-b::index.adoc
----

이 예에서는 버전 2.0이 구성 요소 B의 최신 버전이라고 가정해 보겠습니다. 이 경우 __pass:[https://demo.antora.org/index.html]__은 __pass:[https://demo.antora.org/component-b/2.0/index.html]__로 리디렉션됩니다.

=== 페이지의 특정 버전 사용

사이트의 시작 페이지를 지정된 페이지의 특정 버전으로 만들려면 리소스 ID에 버전 좌표를 포함하세요.

.예제 3. antora-playbook.yml
[source,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  start_page: 1.0@component-b::index.adoc
----
이 예에서 __pass:[https://demo.antora.org/index.html]__은 __pass:[https://demo.antora.org/component-b/1.0/index.html]__로 리디렉션됩니다.

NOTE: 구성 요소 버전의 시작 페이지를 구성하려면 Choose a Start Page을 참조하세요.



== Configure Your Site - Site Keys - Robots

Antora는 사이트 크롤러가 방문할 수 있는 경로를 제어하기 위해 __robots.txt__ 파일을 생성할 수 있습니다.

=== robots 키
robots 키는 선택 사항입니다. 플레이북의 site 키 아래에 구성됩니다. 허용되는 값은 다음과 같습니다:

allow::
게시된 사이트의 모든 경로에 대한 액세스를 모든 사용자 에이전트에 허용합니다.

disallow::
게시된 사이트의 모든 경로에 대한 액세스를 모든 사용자 에이전트에 허용하지 않습니다.

사용자 정의 여러 줄 문자열::
생성된 __robots.txt__ 파일의 내용으로 사용되는 비어 있지 않은 사용자 지정 문자열입니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
site:
  title: Site Title
  url: https://example.org
  robots: disallow
----

Antora는 사이트의 루트에 __robots.txt__ 파일을 생성합니다.

robots 키는 형제 url 키에 의존합니다. url 키에 값이 할당되지 않으면 robots가 허용되는 값으로 설정되어 있더라도 Antora는 __robots.txt__ 파일을 생성하지 않습니다.

=== robots에 allow 또는 disallow 할당

url과 robots 키가 다음과 같이 정의되어 있다고 가정해 보겠습니다:

.예제 2. antora-playbook.yml
[source,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  robots: allow
----

이렇게 하면 사용자 에이전트에게 사이트의 모든 경로에 대한 액세스를 허용하는 __robots.txt__ 파일이 생성됩니다.

.생성된 robots.txt
[source,text]
----
User-agent: *
Allow: /
----

유사하게, url과 robots 키가 다음과 같이 정의된 경우:
.예제 3. antora-playbook.yml
[source,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  robots: disallow
----

이렇게 하면 모든 경로에 대한 액세스를 허용하지 않는 __robots.txt__ 파일이 생성됩니다.
.생성된 robots.txt

[source,text]
----
User-agent: *
Disallow: /
----

=== 사용자 정의 내용으로 robots.txt 생성

robots에 할당된 다른 모든 비어 있지 않은 값은 __robots.txt__ 파일의 내용으로 사용됩니다. 예를 들어, robots 키가 다음과 같이 선언되었다고 가정해 보겠습니다:

.예제 4. antora-playbook.yml
[source,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  robots: |
    User-agent: *
    Disallow: /private/
----

이렇게 하면 다음과 같은 __robots.txt__ 파일이 생성됩니다.

.생성된 robots.txt
[source,text]
----
User-agent: *
Disallow: /private/
----



== Configure Your Site - Site Keys - Account and API Keys

keys 키는 Google Analytics 또는 검색 도구와 같은 서비스 통합에 사용되는 계정 식별자를 지정하는 이름-값 쌍의 맵을 받아들입니다.

=== keys 키

keys 키는 선택 사항입니다. 플레이북의 site 키 아래에 keys 키를 정의합니다. keys는 계정 식별자를 지정하는 이름-값 쌍(하위 키라고도 함) 목록을 받아들입니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
site:
  title: Site Title
  url: https://example.org
  keys:
    name-of-account-key: 'identifier'
    google_analytics: 'XX-123456'

----

이러한 키의 값은 UI 모델의 site.keys 속성에서 UI 템플릿으로 액세스할 수 있습니다. UI 모델에 할당되면 이름은 camelCase로 변환됩니다(이름의 단어가 하이픈 또는 밑줄로 구분되는지 여부에 관계없이). 예를 들어, 위의 예제에 정의된 키는 각각 site.keys.nameOfAccountKey와 site.keys.googleAnalytics로 액세스할 수 있습니다.

사이트 키는 CLI에서도 구성할 수 있습니다.

=== Google Analytics 계정 추가

google_analytics 키는 사이트에 Google Analytics 계정을 할당합니다. 이 옵션을 설정하면 기본 UI를 사용할 때 Google Analytics / Tag Manager 임베드 코드가 암시적으로 활성화됩니다.

.예제 2. antora-playbook.yml
[source,yaml]
----
site:
  title: Demo Docs Site
  url: https://demo.antora.org
  keys:
    google_analytics: 'XX-123456'
----

YAML 파서에 의해 훼손되지 않도록 값을 작은따옴표(')로 묶는 것이 좋습니다. google_analytics 키는 CLI와 GOOGLE_ANALYTICS_KEY 환경 변수를 사용하여 구성할 수도 있습니다.



== Configure Your Site - Content Keys

content 및 sources 아래에 구성된 플레이북 키는 콘텐츠 소스 저장소의 위치와 처리 방법을 정의합니다.

=== content 키

content 카테고리 키는 Antora 사이트의 콘텐츠 소스(즉, git 저장소) 목록을 캡슐화합니다. 콘텐츠 소스는 sources 키를 사용하여 정의됩니다. branches, tags 및 edit_url 키는 모든 콘텐츠 소스에 대한 기본값을 정의하는 데 사용할 수 있습니다. 이러한 키는 콘텐츠 소스별로 다른 키와 함께 재정의할 수 있습니다.

[source, yaml]
----
content: <1>
  branches: [v2.0, v2.5, v3.0] <2> 
  tags: [release/*, '!release/*-patch'] <3> 
  edit_url: '{web_url}/blob/{refname}/{path}' <4> 
  sources: <5>
  - url: https://git-service.com/org/repo-z.git <6> 
    start_path: path-to/content-source-root <7>
  - url: https://git-service.com/org/repo-y.git <8> 
----
<1> 필수 content 키
<2> 선택적 branches 키
<3> 선택적 tags 키
<4> 선택적 edit_url 키
<5> 필수 sources 키
<6> 필수 url 키
<7> 선택적 start_path 키
<8> 다른 url 키

content 및 sources 키는 필수입니다. sources 키에는 url 키가 정의된 항목이 하나 이상 포함되어야 합니다. 다른 모든 키는 선택 사항입니다. branches 및 edit_url 키에는 플레이북에서 명시적으로 설정되지 않은 경우 Antora가 런타임에 자동으로 적용하는 내장 값이 있습니다.

content 바로 아래에 지정된 키-값 쌍은 키가 특정 url에도 지정되지 않는 한 sources 아래의 모든 url 키 항목에 적용됩니다.

=== sources 키

sources 키는 필수이며 content 키 아래에 중첩됩니다. sources 키에는 소스 항목 목록이 포함됩니다. 하이픈으로 지정된 각 항목은 git 저장소 위치(URL 또는 파일 시스템 경로), 브랜치 및/또는 태그와 일치하는 패턴, 선택적 시작 경로 또는 경로 및 Antora가 사이트 콘텐츠를 집계할 때 사용하는 기타 저장소 속성으로 구성됩니다.

[source,yaml]
----
content: <1>
  sources: <2>
  - url: https://git-service.com/org/repo-z.git <3>
    branches: [v1.*, v2.*, \!v1.2] <4>
    start_paths: path-to/content-source-root-{item..item} <5> 
  - url: https://git-service.com/org/repo-y.git  <6>
    branches: [] <7>
    tags: [release/*, '!release/*-patch'] <8> 
    start_path: path-to/content-source-root <9>
    edit_url: '{web_url}/blob/{refname}/{path}' <10> 
  - url: https://git-service.com/org/repo-x.git <11>
    branches: v* <12>
    version: true <13>
----
<1> 필수 content 키
<2> 필수 sources 키
<3> 필수 url 키
<4> 선택적 branches 키
<5> 선택적 start_paths 키
<6> 다른 url 키
<7> 선택적 branches 키
<8> 선택적 tags 키
<9> 선택적 start_path 키
<10> 선택적 edit_url 키
<11> 다른 url 키
<12> 선택적 branches 키
<13> 선택적 version 키

sources 키에는 url 키가 정의된 항목이 하나 이상 포함되어야 합니다. 다른 모든 키는 선택 사항입니다. branches 및 edit_url 키에는 플레이북에서 명시적으로 정의되지 않은 경우 Antora가 런타임에 자동으로 적용하는 내장 값이 있습니다.

NOTE: 콘텐츠 소스 항목에 대해 일치하는 git 참조(브랜치 또는 태그)가 없으면 Antora는 정보 수준에서 메시지를 기록합니다. 이 메시지를 보려면 로그 심각도 수준을 적어도 정보로 설정해야 합니다. 디버깅에 도움이 되도록 Antora의 로거를 적절하게 구성하는 것이 좋습니다.

version 키는 구성 요소 버전 설명자(__antora.yml__)의 version 키에 대한 대체 값을 제공합니다. 단일 참조를 일치시키거나 값이 refname에서 파생되기를 원하는 경우에만 사용해야 합니다.

=== 사용 가능한 content 키

다음 키는 content 키 아래에 정의할 수 있습니다. 소스 항목 자체를 포함하는 sources 키를 제외하고 이러한 키는 각 소스 항목에 대한 기본값을 제공하는 데 사용됩니다.

[cols="1,4,1", options="header"]
|===
| 콘텐츠 키 | 설명 | 필수
// 구분선
| branches
| 콘텐츠 소스에 지정된 저장소에서 사용할 정확한 브랜치 이름 및 이름 패턴 목록을 받아들입니다.
| 아니오
// 구분선
| edit_url
| 현재 페이지의 소스 보기에 매핑되는 URL을 작성하기 위한 URL 패턴을 받아들입니다. 다음 플레이스홀더 세그먼트를 수용합니다: {web_url}, {refname}, {refhash} 및 {path}.
| 아니오
// 구분선
| sources
| 콘텐츠로 사용할 저장소와 저장소 참조를 지정하는 콘텐츠 소스 항목 목록을 받아들입니다.
| 예
// 구분선
| tags
| 콘텐츠 소스에 지정된 저장소에서 사용할 정확한 태그 이름 및 이름 패턴 목록을 받아들입니다.
| 아니오
|===

=== 사용 가능한 콘텐츠 소스 키

[cols="1,4,1", options="header"]
|===
| 콘텐츠 키 | 설명 | 필수
// 구분선
| branches
| 콘텐츠 소스에 지정된 저장소에서 사용할 정확한 브랜치 이름 및 이름 패턴 목록을 받아들입니다. 지정되지 않은 경우 content 키에 정의된 branches 키의 값으로 기본 설정됩니다.
| 아니오
// 구분선
| edit_url
| 현재 페이지의 소스 보기에 매핑되는 URL을 작성하기 위한 URL 패턴을 받아들입니다. 다음 플레이스홀더 세그먼트를 수용합니다: {web_url}, {refname}, {refhash} 및 {path}.
| 아니오
// 구분선
| start_path
| 콘텐츠 소스 루트의 위치에 대한 저장소의 상대 경로를 지정합니다.
| 아니오
// 구분선
| start_paths
| 정확한 경로 또는 셸 글로브 패턴으로 콘텐츠 소스 루트 위치에 대한 저장소 상대 경로 패턴 목록을 받아들입니다. 단일 값은 배열로 변환됩니다.
| 아니오
// 구분선
| tags
| 콘텐츠 소스에 지정된 저장소에서 사용할 정확한 태그 이름 및 이름 패턴 목록을 받아들입니다.
| 아니오
// 구분선
| url
| HTTPS URL 또는 로컬 파일 시스템 경로일 수 있는 git 저장소의 URL을 받아들입니다.
| 예
// 구분선
| version
| 일치하는 모든 참조에 대한 구성 요소 버전 설명자의 version 키에 대한 대체 값을 제공합니다.
| 아니오
// 구분선
| worktrees
| Antora가 사용해야 하는 해당 작업 트리를 제어하기 위해 키워드 또는 정확한 브랜치 이름 또는 이름 패턴 목록을 받아들입니다.
| 아니오
|===



== Configure Your Site - Content Keys - URLs for Content Sources

url 키는 Antora에게 콘텐츠 소스 저장소를 찾을 위치를 알려줍니다.

=== url 키

Antora는 플레이북의 url 키로 정의된 공개 및 비공개 git 저장소에 연결할 수 있습니다. sources 키 아래에 하나 이상의 url 키를 지정해야 합니다. 필요한 만큼 url 키를 추가할 수 있습니다. 각 url 키는 Antora에게 콘텐츠 소스 파일을 포함하는 git 저장소를 찾을 위치를 알려줍니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo.git
  - url: /absolute/path/to/local-repo
----

url 키는 로컬 파일 시스템 경로를 포함하여 git이 지원하는 모든 URI를 받아들입니다.

git과 마찬가지로 Antora는 값의 특정 문자를 기반으로 로컬 파일 시스템 경로와 원격 URI를 구분합니다. 값이 아래 나열된 두 규칙 중 하나와 일치하면 값은 항상 로컬 파일 시스템 경로가 아닌 원격 URI로 처리됩니다.

- 값에 슬래시 또는 백슬래시 뒤에 오지 않는 콜론이 포함되어 있습니다(host:repo).
- 값에 두 개의 슬래시(://) 뒤에 오는 콜론이 포함되어 있습니다.

=== 원격 콘텐츠 저장소 사용

모든 원격 콘텐츠 저장소는 URL(기본 또는 암호화된 HTTP 프로토콜을 사용하여 가져오는 웹 주소, 즉 http:// 또는 pass:[https://])을 통해 액세스할 수 있어야 합니다. 저장소 위치는 URL, SSH URI 또는 git URI를 사용하여 표현할 수 있습니다. 내부적으로 해당 위치는 항상 URL로 변환됩니다.

[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
  - url: git@git-service.com:org/repo-y.git
  - url: git://git-service.com/org/repo-x.git
----

pass:[.git] 확장자가 필요한지 여부는 git 호스트의 설정에 따라 다릅니다. GitHub에서 호스팅되는 저장소에는 필요하지 않고, GitLab에서 호스팅되는 저장소에는 필요하며, Team Foundation Server(TFS) 또는 Azure DevOps에서 호스팅되는 저장소에는 금지되어 있습니다(몇 가지 시나리오를 인용하고 문제의 특성을 보여주기 위해). 이것이 ensure_git_suffix 키가 제공되는 이유이며, 기본적으로 활성화되어 있습니다.

Antora는 지원되는 인증 방법이 비공개 콘텐츠 소스 저장소에 지정된 경우 비공개 git 저장소에 연결할 수 있습니다.

=== 로컬 콘텐츠 저장소 사용

Antora는 url의 값이 최소한 하나의 커밋이 있는 로컬 저장소에 대한 상대 또는 절대 파일 시스템 경로일 수 있도록 허용합니다.

[source,yaml]
----
content:
  sources:
  - url: /absolute/path/to/local-repo <1>
  - url: https://git-service.com/org/repo-z.git
  - url: ./another-local-repo <2>
----
<1> git 저장소에 대한 절대 경로
<2> git 저장소에 대한 상대 경로(플레이북 디렉터리에서 시작)

IMPORTANT: Antora에서 로컬 콘텐츠 저장소를 사용하려면 작업 트리(HEAD)를 사용할 때에도 저장소에 **최소한 하나의 커밋이 있어야 합니다**. 아직 파일을 커밋할 준비가 되지 않았다면 저장소를 초기화하고 빈 커밋을 만들 수 있습니다(예: git init . && git commit --allow-empty -m init).

상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

- 첫 번째 경로 세그먼트가 틸드(~)인 경우 나머지 경로는 사용자의 홈 디렉터리를 기준으로 확인됩니다.
- 첫 번째 경로 세그먼트가 점(.)인 경우 나머지 경로는 플레이북 파일의 위치를 기준으로 확인됩니다.
- 첫 번째 경로 세그먼트가 틸드 다음에 바로 더하기 기호(~+)이거나 앞서 언급한 접두사로 시작하지 않는 경우 나머지 경로는 현재 작업 디렉터리를 기준으로 확인됩니다.

=== git 작업 트리 사용

콘텐츠 소스의 URL이 로컬 저장소(최소한 하나의 커밋이 있어야 함)이고 branches 필터가 현재 체크아웃된 브랜치(즉, 작업 트리 브랜치)와 일치하면 Antora는 git 인덱스에서가 아니라 작업 트리(즉, 로컬 파일 시스템의 작업 디렉터리)에서 파일을 읽습니다. 이 동작은 Antora의 작성자 모드의 중심입니다. 이는 Antora가 파일을 사용하기 전에 로컬에서 커밋할 필요가 없음을 의미합니다.

.예제 2. 작업 트리에서 파일 사용
[source,yaml]
----
content:
  sources:
  - url: ./demo-component-b
    branches: main
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

현재 브랜치의 이름을 명시적으로 지정하는 대신 현재 브랜치 이름에 대한 별칭으로 기호 이름 HEAD를 사용할 수 있습니다. 이렇게 하면 브랜치를 전환할 때 플레이북을 업데이트해야 하는 번거로움을 줄일 수 있습니다.

.예제 3. 작업 트리에서 파일 사용
[source,yaml]
----
content:
  sources:
  - url: ./demo-component-b
    branches: HEAD
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

CAUTION: branches 필터가 작업 트리 브랜치와 동일한 구성 요소 버전에 대해 동일한 파일을 포함하는 다른 브랜치와 일치하면 Antora는 중복 파일을 허용하지 않기 때문에 실행에 실패합니다.

=== git 작업 트리 우회

브랜치 필터가 작업 트리 브랜치와 일치하더라도 Antora가 작업 트리의 파일을 사용하지 않도록 하려면 URL을 .git 디렉터리로 직접 가리킬 수 있습니다. 이렇게 하면 Antora에서 작업 트리를 효과적으로 숨겨서 사용되지 않습니다.

.예제 4. 작업 트리의 파일을 우회하기 위해 .git 폴더를 직접 참조
[source,yaml]
----
content:
  sources:
  - url: ./demo-component-b/.git
    branches: HEAD
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

git 작업 트리를 우회하는 더 좋은 방법은 worktrees 키를 false로 설정하는 것입니다.

.예제 5. 작업 트리의 파일을 우회하기 위해 worktrees를 false로 설정
[source,yaml]
----
content:
  sources:
  - url: ./demo-component-b
    branches: HEAD
    worktrees: false
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: v1.0, v2.0
----

이 경우 Antora가 파일을 사용하려면 모든 파일이 로컬에서 커밋되어야 한다는 점을 명심하세요.



== Configure Your Site - Content Keys - URLs for Content Sources - Private Repository Authentication

Antora가 비공개 저장소에 액세스하려면 플레이북에서 사용하는 모든 비공개 저장소 URL에 대한 인증 자격 증명을 제공해야 합니다. 이러한 자격 증명은 외부화할 수 있으므로 플레이북에 하드 코딩할 필요가 없습니다. 이 페이지에서는 내장 git 자격 증명 저장소, 사용자 정의 자격 증명 저장소, 심지어 자신의 자격 증명 관리자를 포함하여 Antora에 자격 증명을 전달하는 다양한 방법을 다룹니다.

먼저 Antora가 기본적으로 허용하는 인증 자격 증명 유형을 살펴보고, 그 다음 이를 설정하고 사용하는 방법으로 넘어가겠습니다.

=== 자격 증명 유형

Antora는 HTTP 기본 인증을 사용하여 비공개 저장소에서 인증할 수 있습니다. HTTP 기본 인증은 사용자의 신원을 확인하기 위해 자격 증명을 서버로 전송(HTTPS를 통해)해야 합니다. 인증 자격 증명은 사용자 이름/비밀번호 쌍 또는 액세스(OAuth 2.0) 토큰으로 구성됩니다.

사용자 이름/비밀번호 쌍은 일반적으로 저장소가 호스팅되는 서비스(GitHub, GitLab 등)에 로그인하는 데 사용합니다. 사용자 이름이나 비밀번호에 /, #, : 등 URL에서 특별한 의미를 갖는 문자가 포함된 경우 URL 파서에 의해 잘못 해석되지 않도록 이러한 문자를 URL 인코딩(즉, 퍼센트 인코딩)해야 합니다. 일부 git 호스트는 이 인증 수단을 지원하지만 다른 호스트는 지원하지 않는다는 점에 유의하세요. 액세스 토큰을 사용하는 것이 더 나을 수 있습니다.

계정에서 2단계 인증(2FA)이 활성화된 경우 사용자 이름/비밀번호 쌍을 사용하여 비공개 저장소에서 인증할 수 없습니다. 시도하면 401 HTTP Basic: Access Denied 오류가 발생합니다.

이유와 상관없이 git 호스트가 사용자 이름/비밀번호 쌍을 사용한 인증을 허용하지 않는 경우 대신 액세스 토큰을 사용해야 합니다.

액세스 토큰에는 개인 액세스 토큰과 배포 토큰의 두 가지 유형이 있습니다.

- 개인 액세스 토큰은 사용자에게 바인딩되며 계정이 액세스할 수 있는 모든 비공개 저장소에 대한 액세스 권한을 부여합니다(토큰 자체의 범위 설정에 따라 다름).
- 배포 토큰(배포 키가 아님)은 프로젝트(즉, 저장소)에 바인딩되며 단일 저장소에 대한 액세스 권한을 부여합니다(토큰 자체의 범위 설정에 따라 다름).

배포 키는 Antora의 git 클라이언트에서 지원하지 않는 SSH 인증을 사용해야 하므로 Antora에서 사용할 수 없습니다.

일반적으로 자신의 머신에서는 단일 개인 액세스 토큰을 사용하고 CI 서버에서는 하나 이상의 배포 토큰을 사용합니다.

==== GitHub

**GitHub**에 대한 액세스 토큰을 만들려면 명령줄용 개인 액세스 토큰(PAT) 만들기를 참조하세요. GitHub에는 세분화된 토큰과 클래식 토큰의 두 가지 유형의 액세스 토큰이 있습니다. 두 가지 모두 Antora에서 지원되지만 세분화된 토큰에는 사용하려는 저장소에 대한 콘텐츠 권한이 부여되어야 합니다.

GitHub는 또한 사용자 대신 애플리케이션에 바인딩되는 설치 액세스 토큰(IAT)도 지원합니다. 이러한 액세스 토큰은 조직에서 사용하기에 더 적합합니다.
GitHub는 현재 배포 토큰을 지원하지 않습니다.

GitHub에서 사용할 액세스 토큰을 만드는 방법에 대해 자세히 알아보려면 Antora with GitHub PAT 및 GitHub IAT와 함께 Antora with GitHub IAT를 참조하세요.

==== GitLab

**GitLab**에 대한 액세스 토큰을 만들려면 Personal Access Tokens 및 Deploy Tokens을 참조하세요.

==== Bitbucket

**Bitbucket**의 경우 저장소에 대한 읽기 액세스 권한이 있는 앱 비밀번호를 만들어야 합니다. 앱 비밀번호는 사용자 기반 액세스 토큰입니다.

이제 기본 git 자격 증명 저장소를 통해 Antora의 내장 자격 증명 관리자에 이러한 자격 증명을 제공하는 방법을 살펴보겠습니다.

=== 기본 git 자격 증명 저장소를 사용하여 자격 증명 제공

기본적으로 Antora의 내장 자격 증명 관리자는 자동으로 git 자격 증명 저장소(데이터베이스 파일)에서 자격 증명을 확인합니다. git 자격 증명 저장소의 기본 경로는 $HOME/.git-credentials이며, 첫 번째 위치가 존재하지 않는 경우 $XDG_CONFIG_HOME/git/credentials입니다. 이 경로는 디렉터리가 아니라 파일임에 유의하세요.

Antora는 git 호스트(일명 주문형)에서 자격 증명을 요청할 때 자동으로 자격 증명 관리자와 상담하므로 플레이북에 자격 증명을 직접 지정할 필요가 없습니다. 실제로 플레이북의 비공개 콘텐츠 소스는 공개 콘텐츠 소스와 동일하게 보입니다. 플레이북에서 비공개 콘텐츠 소스의 모습은 다음과 같습니다:

[source,yaml]
----
content:
  sources:
  - url: https://hostname/your-org/private-repository
----

Antora가 git 호스트로부터 URL에 인증이 필요하다는 알림을 받으면 자격 증명 저장소에서 일치하는 항목을 찾습니다. Antora는 URL을 키로 사용하여 일치 항목을 찾습니다. 프로토콜(예: https)과 호스트 이름(선택적으로 저장소 경로)이 자격 증명 저장소에서 발견되면 해당 자격 증명이 Antora의 자격 증명 관리자에 반환되고 git 서버로 전달됩니다.

자격 증명 저장소에는 0개 이상의 행 기반 항목이 포함되어 있습니다. 단일 호스트 이름(예: 여러 배포 토큰)에 대해 여러 자격 증명을 지정해야 하는 경우 각 항목을 별도의 행에 배치하세요. 각 항목의 구조는 다음과 같습니다:

[source]
----
https://<credentials>@<hostname>
----

[IMPORTANT]
====
<credentials>는 사용자 이름/비밀번호 쌍(username:password) 또는 액세스 토큰(token:)입니다. <hostname>은 git 서버의 주소(예: github.com)입니다.
사용자 이름이나 비밀번호에 /, # 또는 : 등 URL에서 특별한 의미를 갖는 문자가 포함된 경우 이러한 문자를 URL 인코딩해야 합니다. (@는 사용자 이름이나 비밀번호에서 특별한 의미를 갖지 않습니다). URL에서 사용자 이름과 비밀번호 구성 요소를 항상 URL 인코딩하는 것이 안전합니다. 이 요구 사항은 git 자격 증명 저장소에 정의된 URL에만 적용됩니다.

구성 요소를 URL 인코딩하려면 브라우저의 JavaScript 콘솔을 열고 encodeURIComponent('<component>')를 실행하세요. 여기서 <component>는 사용자 이름 또는 비밀번호 값입니다. 인쇄된 결과가 다른 경우 사용자 이름 또는 비밀번호 대신 사용하세요. 예를 들어 my#password의 URL 인코딩된 버전은 my%23password입니다.
시스템 git 명령을 사용하거나 자격 증명 저장소를 직접 편집하여 자격 증명 저장소를 대화형으로 채울 수 있습니다. 대화형 접근 방식부터 시작해 보겠습니다.
====

==== 자격 증명 저장소를 대화형으로 채우기

git 명령을 사용하여 자격 증명 저장소를 대화형으로 채울 수 있습니다. 이 접근 방식은 git 서버에서 자격 증명이 수락되었는지 확인할 수 있다는 점에서 특히 유용합니다.
먼저 Antora에서 사용할 비공개 저장소의 URL을 선택하세요. 다음으로 터미널에서 액세스해야 하는 각 비공개 저장소에 대해 다음 명령을 실행하세요:

[source,bash]
----
$ echo -n 'Repository URL: ' && read REPLY && \
  git -c credential.helper=store ls-remote -h $REPLY > /dev/null
----

이 명령은 다음 단계를 수행합니다:

. 비공개 저장소의 URL을 입력하라는 메시지를 표시합니다.

. 비공개 저장소와 통신하여 자격 증명 입력을 트리거합니다.
+
NOTE: 자격 증명 입력 메시지가 표시되지 않으면 자격 증명이 이미 저장되어 있음을 의미합니다.

. 자격 증명을 __$HOME/.git-credentials__ 파일에 저장하고 적절한 권한을 할당합니다.
이 스크립트가 성공하면 추가 구성 없이 Antora에서 해당 비공개 저장소를 사용할 수 있습니다.

대화형 접근 방식이 작동하지 않으면 자격 증명 저장소를 직접 채울 수 있습니다. 그것을 시도해 보겠습니다.

==== 자격 증명 저장소를 직접 채우기

git 자격 증명 저장소에 자격 증명을 직접 추가하려면 __$HOME/.git-credentials__ 파일(디렉터리가 아님)을 만들고 편집기에서 엽니다. 고유한 자격 증명 세트(즉, 사용자 이름/비밀번호 쌍 또는 액세스 토큰과 호스트 이름 및 선택적 저장소 경로)를 각각 별도의 행에 배치하세요. 단일 git 호스트와 개인 액세스 토큰을 사용하는 경우 하나의 항목만 필요합니다. 여러 git 호스트 또는 여러 배포 토큰을 사용하는 경우 둘 이상의 항목이 필요합니다.

사용자 이름/비밀번호 쌍을 사용하는 항목의 예는 다음과 같습니다:

[source]
----
https://octocat:ilovegit@github.com
----

토큰을 사용하는 예(토큰 뒤의 :에 주의하세요):

[source]
----
https://abcdefg0123456:@github.com
----

동일한 git 호스트의 특정 저장소에 대해 다른 자격 증명을 사용하려면 일치 항목을 더 엄격하게 만들기 위해 저장소 경로(즉, <repo>)를 항목에 추가할 수 있습니다. (저장소 경로의 .git 파일 확장자는 선택 사항입니다).

[source]
----
https://<credentials>@<hostname>/<repo>
----

특정 저장소 경로에 대한 항목의 예는 다음과 같습니다:

[source]
----
https://octocat:ilovegit@github.com/octocat/Hello-World
----

몇 가지 인기 있는 git 호스트에 대한 예는 다음과 같습니다(굵은 글씨의 자리 표시자를 실제 값으로 대체해야 함):

[source]
----
https://TOKEN:@github.com/org/project-docs
https://oauth2:TOKEN@gitlab.com/org/project-docs.git
https://gitlab+deploy-token-TOKEN_ID:TOKEN@gitlab.com/org/project-docs.git
https://x-oauth-token:TOKEN@bitbucket.org/org/project-docs.git
https://USERNAME:APP_PASSWORD@bitbucket.org/org/project-docs.git
----

NOTE: URL에 저장소 경로를 지정하는 것은 선택 사항입니다. 포함하지 않으면 해당 자격 증명 쌍이 동일한 git 호스트를 공유하는 모든 URL에 사용됩니다.

CAUTION: 콘텐츠 소스에 사용하는 URL 형식과 플레이북에서 ensure_git_suffix 키를 구성했는지 여부에 따라 .git 파일 확장자를 추가해야 할 수 있습니다.

NOTE: git 호스트에 따라 URL의 다른 위치에 토큰이 위치함에 주의하세요. 자세한 내용은 OAuth2 형식을 참조하세요. Bitbucket 앱 비밀번호를 사용하는 경우 사용자 이름(USERNAME:APP_PASSWORD 형식 사용)을 포함해야 한다는 점에 주의하세요.

자격 증명 파일을 보호하려면 다른 사용자가 읽을 수 없도록 즉시 파일 권한을 설정하세요.

[source,bash]
----
$ chmod 600 $HOME/.git-credentials
----

=== 사용자 정의 git 자격 증명 저장소 경로 지정

기본 경로의 자격 증명 저장소를 사용하는 대신 --git-credentials-path CLI 옵션 또는 GIT_CREDENTIALS_PATH 환경 변수를 사용하여 Antora에 파일을 다른 위치에서 찾도록 지시할 수 있습니다. 두 옵션 모두 런타임에 git.credentials.path 플레이북 키를 설정합니다.

다음은 CLI 옵션을 사용하여 플레이북 파일을 기준으로 상대 경로를 지정하는 예입니다:

[source,bash]
----
$ antora --git-credentials-path=./.git-credentials antora-playbook.yml
----

git.credentials.path 플레이북 키를 사용하는 방법에 대해 자세히 알아보려면 플레이북에 직접 설정하는 방법을 포함하여 git.credentials.path 키에 대한 참조를 참조하세요.

=== 환경 변수를 통해 자격 증명 전달

파일에서 자격 증명을 읽는 대신 GIT_CREDENTIALS라는 환경 변수에서 자격 증명을 직접 읽도록 Antora에 지시할 수 있습니다. 이 변수는 런타임에 git.credentials.contents 플레이북 키를 설정합니다.

다음은 개념을 보여주는 예입니다:

[source,bash]
----
$ export GIT_CREDENTIALS='https://octocat:ilovegit@github.com'
$ antora antora-playbook.yml
----

이를 한 줄로 줄일 수도 있습니다(명령 범위에 대해서만 환경 변수를 정의함):

[source,bash]
----
$ GIT_CREDENTIALS='https://octocat:ilovegit@github.com' antora antora-playbook.yml
----

Windows 명령 프롬프트를 사용할 때는 set 명령을 사용하여 환경 변수를 정의해야 합니다:

[source,bash]
----
C:\> set "GIT_CREDENTIALS=https://octocat:ilovegit@github.com" && antora antora-playbook.yml
----

이 전략은 환경 변수를 보호할 수 있는 CI 환경에서 가장 유용합니다. 또한 자신의 머신에서 사이트를 생성할 때 Antora에 자격 증명을 전달하는 빠르고 비공식적인 방법이기도 합니다.

환경 변수를 사용할 때 여러 항목은 쉼표 또는 줄 바꿈 문자로 구분할 수 있습니다. 예를 들면:

[source,bash]
----
$ GIT_CREDENTIALS='https://my-github-token:@github.com,https://oauth2:my-gitlab-token@gitlab.com' antora antora-playbook.yml
----

환경 변수를 내보내면 Antora를 실행할 때마다 입력할 필요가 없습니다.

git.credentials.contents 플레이북 키를 사용하는 방법에 대해 자세히 알아보려면 플레이북에 직접 설정하는 방법을 포함하여 git.credentials.contents 키에 대한 참조를 참조하세요.

=== URL에 자격 증명 인코딩(권장하지 않음)

자격 증명 관리자에 자격 증명을 전달하는 또 다른 옵션은 플레이북에 나열된 URL에 자격 증명을 직접 인코딩하는 것입니다. 이 옵션은 챌린지-응답 워크플로를 트리거하지 않으므로 Antora는 자동으로 저장소가 비공개라고 가정합니다.

WARNING: 이 전략은 이 섹션의 끝 부분에 설명된 대로 실제 자격 증명을 주입하는 데 자리 표시자를 사용하지 않는 한 권장되지 않습니다.

Antora는 호스트 이름 앞에 오는 자격 증명(즉, username:password@ 또는 token@)을 추출하여 서버에서 요청한 경우 사용자를 대신하여 인증을 수행하는 데 사용합니다.
몇 가지 인기 있는 git 호스트에 대한 예는 다음과 같습니다(굵은 글씨의 자리 표시자를 실제 값으로 대체해야 함):

.예제 1. antora-playbook.yml (일부)
[source,yaml]
----
content:
  sources:
  - url: https://TOKEN:@github.com/org/project-docs
  - url: https://oauth2:TOKEN@gitlab.com/org/project-docs.git
  - url: https://gitlab+deploy-token-TOKEN_ID:TOKEN@gitlab.com/org/project-docs.git
  - url: https://x-oauth-token:TOKEN@bitbucket.org/org/project-docs.git
  - url: https://USERNAME:APP_PASSWORD@bitbucket.org/org/project-docs.git
----

NOTE: git 호스트에 따라 URL의 다른 위치에 토큰이 위치함에 주의하세요. 자세한 내용은 OAuth2 형식을 참조하세요. Bitbucket 앱 비밀번호를 사용하는 경우 사용자 이름(USERNAME:APP_PASSWORD 형식 사용)을 포함해야 한다는 점에 주의하세요.

이 접근 방식의 단점은 자격 증명을 플레이북 파일에 직접 넣어야 한다는 것입니다. 안타깝게도 Antora는 아직 플레이북 파일에 있는 환경 변수 확인을 지원하지 않습니다. 그러나 스크립트를 사용하여 플레이북 파일의 환경 변수 참조를 해당 값으로 대체할 수 있습니다.

플레이북 파일에 다음과 같은 소스가 정의되어 있다고 가정해 보겠습니다:

.예제 2. antora-playbook.yml (일부)
[source,yaml]
----
content:
  sources:
  - url: https://$GITHUB_TOKEN:@github.com/org-name/project-docs
----

동일한 자격 증명이 필요한 여러 개의 비공개 저장소를 사용하는 경우 대신 git 키 아래에 자격 증명을 한 번 정의할 수 있습니다:

.예제 3. antora-playbook.yml (일부)
[source,yaml]
----
git:
  credentials:
    contents: https://$GITHUB_TOKEN:@github.com
----

그런 다음 다음 스크립트를 사용하여 환경 변수에 대한 참조를 확장할 수 있습니다. Antora를 호출하기 전에 CI에서 실행할 수 있습니다:

[source,bash]
----
$ sed -i s/\$GITHUB_TOKEN/$GITHUB_TOKEN/ antora-playbook.yml
$ antora antora-playbook.yml
----

이러한 해결 방법에도 불구하고 이전에 설명한 자격 증명 저장소 통합을 사용하는 것이 좋습니다.

=== 사용자 정의 자격 증명 관리자 구성

Antora에서 사용하는 git 클라이언트인 isomorphic-git은 인증 자격 증명을 조회하기 위한 플러그형 자격 증명 관리자를 제공합니다. Antora는 이 플러그인의 기본 구현을 제공합니다. 이전 섹션에서 보았듯이 이 구현은 Antora가 파일 또는 환경 변수를 통해 일반 텍스트로 자격 증명에 직접 액세스할 수 있다고 가정합니다. 이 배열이 보안 요구 사항을 충족하지 않는 경우 기본 제공 자격 증명 관리자를 자신의 관리자로 교체할 수 있습니다.

사용자 정의 자격 증명 관리자를 작성하려면 다음 메서드를 구현하는 JavaScript 객체를 내보냅니다:

.예제 4. 사용자 정의 git 자격 증명 관리자를 위한 API
[source,js]
----
configure ({ config, startDir })
async fill ({ url })
async approved ({ url })
async rejected ({ url, auth })
status ({ url })
----

자격 증명을 조회하는 메서드는 fill입니다. { username, password } 또는 { token } 데이터 객체 중 하나를 반환해야 합니다. approved 및 rejected 메서드는 자격 증명이 서버에 의해 각각 승인되거나 거부될 때 호출됩니다.

선택적 configure 및 status 메서드는 Antora에만 해당되며, isomorphic-git의 자격 증명 관리자가 일반적으로 제공하는 기능을 확장합니다. 정의된 경우 configure 메서드는 Antora가 시작될 때마다 호출되어 속성 정의와 같은 초기화 단계를 수행할 수 있는 기회를 제공합니다. status 메서드(사용 가능한 경우)는 Antora에서 주어진 URL에 대해 인증이 요청되었는지 여부를 조회하는 데 사용됩니다.

사용자 정의 자격 증명 관리자를 활성화하려면 먼저 전용 JavaScript 파일에 구현을 작성하고 기본 내보내기로 구성합니다:

.예제 5. custom-git-credential-manager.js
[source,js]
----
module.exports = {
  async fill ({ url }) { ... },
  async approved ({ url }) { ... },
  async rejected ({ url, auth }) { ... },
}
----

그런 다음 다음과 같이 플레이북에 자격 증명 관리자를 등록합니다:

[source,yaml]
----
git:
  plugins:
    credential_manager: ./custom-git-credential-manager.js
----

또는 플러그인을 자체 등록하도록 구성할 수 있습니다:

.예제 6. custom-git-credential-manager.js
[source,js]
----
'use strict'

const git = require('isomorphic-git')

if (!git.cores) git.cores = new Map()
git.cores.set('antora', new Map().set('credentialManager', {
  async fill ({ url }) { ... },
  async approved ({ url }) { ... },
  async rejected ({ url, auth }) { ... },
}))
----

이 경우 플러그인 이름은 credential_manager가 아니라 credentialManager임에 주의하세요. 플레이북 빌더가 자동으로 키 이름을 camelCase로 변환해 주기 때문입니다. 이는 git 클라이언트가 예상하는 키 이름입니다.
자체 등록자격 증명 관리자를 사용할 때는 -r 옵션을 사용하여 Antora에 전달하는 대신 플레이북에 등록합니다:

[source,bash]
----
$ antora -r ./custom-git-credential-manager.js antora-playbook.yml
----

npm을 사용하여 Antora를 전역적으로 설치한 경우 자체 등록 자격 증명 관리자가 작동하도록 하는 데 문제가 있을 수 있습니다. Cannot find module 'isomorphic-git' 오류가 발생하거나 사용자 정의 자격 증명 관리자가 호출되지 않습니다. 이 문제를 해결하려면 NODE_PATH 환경 변수를 설정하여 Node.js에 Antora의 종속성을 찾을 위치를 알려줍니다:

[source,bash]
----
$ NODE_PATH=$(npm -g list --parseable=true @antora/site-generator)/node_modules antora -r ./custom-git-credential-manager.js antora-playbook.yml
----

대체 솔루션은 Antora를 로컬로 설치하는 것입니다(즉, package.json 파일의 dependencies에 Antora 패키지를 추가하고 npm i 실행).

플러그인을 자체 등록하는 것이 더 복잡하므로 플레이북에 플러그인을 등록하는 예제로 진행하겠습니다.

==== git에서 자격 증명 가져오기

Git은 git credential이라는 명령을 제공하며, 이는 git 자체와 동일한 방식으로 시스템 특정 도우미에서 자격 증명을 저장하고 검색하기 위한 간단한 인터페이스 역할을 합니다. 또한 사용자 이름과 비밀번호를 입력하라는 메시지를 표시할 수 있습니다. 사용자 정의 자격 증명 관리자에서 이 명령을 사용하여 Antora가 git에 위임하여 자격 증명을 조회하도록 할 수 있습니다(따라서 사용자 자신의 git 설정과 통합).

먼저 git credentials fill을 통해 시스템 git와 인터페이스하여 URL에 대한 자격 증명을 검색하는 도우미 함수를 만들어 보겠습니다:

.예제 7. system-git-credential-manager.js
[source,js]
----
'use strict'

const { spawn } = require('child_process')

function callGitCredentialFill (url) {
  const { protocol, host } = new URL(url)
  return new Promise((resolve, reject) => {
    const output = []
    const process = spawn('git', ['credential', 'fill'])
    process.on('close', (code) => {
      if (code) return reject(code)
      const { username, password } = output.join('\n').split('\n').reduce((acc, line) => {
        if (line.startsWith('username') || line.startsWith('password')) {
          const [key, val] = line.split('=')
          acc[key] = val
        }
        return acc
      }, {})
      resolve(password ? { username, password } : username ? { token: username } : undefined)
    })
    process.stdout.on('data', (data) => output.push(data.toString().trim()))
    process.stdin.write(`protocol=${protocol.slice(0, -1)}\nhost=${host}\n\n`)
  })
}
----

다음으로 이 함수를 사용하여 URL에 대한 자격 증명을 채우는 자격 증명 관리자를 만들어 보겠습니다:
[source,js]
----
// ...

module.exports = {
  configure () {
    this.urls = {}
  },
  async fill ({ url }) {
    this.urls[url] = 'requested'
    return callGitCredentialFill(url)
  },
  async approved ({ url }) {
    this.urls[url] = 'approved'
  },
  async rejected ({ url, auth }) {
    this.urls[url] = 'rejected'
    const data = { statusCode: 401, statusMessage: 'HTTP Basic: Access Denied' }
    const err = new Error(`HTTP Error: ${data.statusCode} ${data.statusMessage}`)
    err.name = err.code = 'HttpError'
    err.data = data
    if (auth) err.rejected = true
    throw err
  },
  status ({ url }) {
    return this.urls[url]
  },
}
----

마지막으로 플레이북에 자격 증명 관리자를 등록해야 합니다:

[source,yaml]
----
git:
  plugins:
    credential_manager: ./system-git-credential-manager.js
----

이제 Antora는 시스템 git에 위임하여 URL에 대한 자격 증명을 채웁니다:

[source,bash]
----
$ antora antora-playbook.yml
----

자격 증명이 서버에 의해 승인되었는지 거부되었는지에 따라 자격 증명을 저장하거나 지우는 것은 독자의 연습 과제로 남겨두겠습니다(힌트: approved 및 rejected 메서드를 사용하여 git credential을 다시 호출).

=== SSH 인증

Antora 2.0 이후로는 SSH 에이전트를 사용한 공개/개인 키 인증을 더 이상 지원하지 않습니다. 대신 Antora는 플레이북의 git SSH URL을 HTTPS URL로 투명하게 변환하고 인증을 위해 자격 증명 관리자를 사용합니다. 즉, 플레이북 파일에서 SSH URL과 HTTPS URL을 상호 교환적으로 사용할 수 있지만 궁극적으로 git 클라이언트는 HTTPS를 통해 통신합니다. 어떤 이유로 이 자동 변환이 작동하지 않으면 플레이북 파일을 업데이트하여 올바른 HTTPS URL을 사용해야 합니다.



== Configure Your Site - Content Keys - Branches

branches 키는 정확한 브랜치 이름과 브랜치 이름을 일치시키기 위한 패턴 목록을 받아들입니다. branches 키가 전역적으로 또는 콘텐츠 소스에 지정되지 않은 경우 Antora는 기본 브랜치 필터를 적용합니다.

=== branches 키

branches 키는 선택 사항입니다. content 키에 직접 지정할 수 있습니다(이는 모든 콘텐츠 소스에 대한 기본값을 변경함). 또는 콘텐츠 소스에 지정할 수 있습니다(이는 기본값을 재정의함). branches 키는 지정된 url에서 사용할 브랜치 이름 패턴 목록을 받아들입니다. 각 값은 정확한 브랜치 이름(예: v2.3, main 등) 또는 패턴(예: v2.*, v@({1..9})*({0..9}).+({0..9}).x 등)일 수 있습니다. 브랜치 목록은 이러한 값 유형의 조합일 수도 있습니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
    branches: [rawhide, 90.0, 93.0, dev] <1>
  - url: https://git-service.com/org/repo-y.git
    branches: main <2>
  - url: https://git-service.com/org/repo-x.git
    branches: [edge, v*, '!v1.*'] <3> 
----
<1> 여러 값을 대괄호([])로 묶습니다. 각 값을 쉼표(,)로 구분합니다. 값이 기호(예: *)로 시작하는 경우 YAML 규칙에 따라 작은따옴표(')로 묶습니다.
<2> 단일 값은 대괄호로 묶을 필요가 없지만, 숫자(예: 2.0)로 시작하는 경우 작은따옴표(')로 묶습니다. 값이 기호(예: *)로 시작하는 경우 YAML 규칙에 따라 작은따옴표(')로 묶습니다.
<3> 정확한 브랜치 이름과 브랜치 이름 패턴을 branches 키에 할당할 수 있습니다.

이러한 값 패턴은 대소문자를 구분하지 않습니다. 즉, 문자의 대소문자에 관계없이 일치합니다. 값은 쉼표로 구분된 목록 또는 개별 줄의 단일 항목으로 지정할 수 있습니다.
YAML을 사용할 때의 일반적인 규칙은 항상 값을 작은따옴표로 묶는 것이 가장 좋습니다.

.예제 2. 개별 줄에 나열된 branches 값
[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-x.git
    branches:
    - edge <1>
    - '2.0' <2>
    - v*
    - '!v1.*' <3>
----
<1> 각 값을 하이픈과 공백을 앞에 붙여 개별 줄에 입력합니다.
<2> 숫자로 시작하는 값은 작은따옴표(')로 묶어야 합니다.
<3> 느낌표 기호(!)로 시작하는 부정 값은 작은따옴표(')로 묶어야 합니다.

=== 기본 브랜치 필터

content 키 또는 콘텐츠 소스에서 branches 키가 설정되지 않은 경우 Antora는 기본 브랜치 필터 [HEAD, v{0..9}*]를 상속합니다. 즉, Antora는 현재(로컬의 경우) 또는 기본(원격의 경우) 브랜치(예: main)의 파일과 문자 v 다음에 바로 숫자가 오는 모든 브랜치(예: v2.0.x)의 파일을 사용합니다. branches 키를 설정하여 콘텐츠 소스별로 이 상속된 값을 재정의할 수 있습니다.

.예제 3. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
    branches: [rawhide, 90.0, 93.0, dev] <1>
  - url: https://git-service.com/org/repo-y.git <2> 
  - url: https://git-service.com/org/repo-x.git
    branches: [edge, v*, '!v1.*'] <3>
----
<1> 이 콘텐츠 소스는 지정된 정확한 브랜치 이름을 사용합니다.
<2> 이 콘텐츠 소스는 기본 브랜치 필터를 사용합니다.
<3> 이 콘텐츠 소스는 edge 브랜치 이름과 함께 참조 이름 패턴과 일치하는 v로 시작하는 브랜치 이름을 사용합니다.


==== 기본 브랜치 필터 수정

기본 브랜치 필터를 수정하려면 content 키에 직접 branches 키에 값을 할당하세요.

.예제 4. 기본 브랜치 필터 변경
[source,yaml]
----
content:
  branches: v* <1>
  sources:
  - url: https://git-service.com/org/repo-z.git <2> 
  - url: https://git-service.com/org/repo-x.git
    branches: [edge, v*, '!v1.*'] <3>
  - url: https://git-service.com/org/repo-y.git <4>
----
<1> 기본 브랜치 필터를 변경하려면 content 키 아래에 branches를 지정하세요.
<2> 이 콘텐츠 소스는 사용자 정의 기본 브랜치 필터, 즉 branches: v*를 사용합니다.
<3> 이 콘텐츠 소스는 기본 브랜치 필터 대신 지정된 브랜치 필터를 사용합니다.
<4> 이 콘텐츠 소스도 사용자 정의 기본 브랜치 필터를 사용합니다.

새로운 기본 브랜치 필터는 branches 키가 명시적으로 정의되지 않은 모든 url 항목에 적용됩니다.

=== 이름으로 브랜치 지정

브랜치는 정확한 이름으로 지정할 수 있습니다.

[source,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [main, sneaky-chinchilla, 1.0, 1.5]
----


=== 패턴으로 브랜치 지정

Antora는 패턴 일치를 사용하여 브랜치 이름을 대량으로 포함하고 제외할 수 있는 기능을 제공합니다. 예를 들어, 와일드카드 연산자(*)를 사용하여 브랜치를 지정할 수 있습니다.

.예제 5. 와일드카드를 사용하여 브랜치 선택
[source,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v2.*, v3.*, v4.*]
----


와일드카드(*) 사용에 대한 자세한 내용은 와일드카드를 참조하세요. Antora는 또한 제외, 중괄호, 대안, 범위 및 반복 패턴을 사용하여 브랜치 이름을 일치시키는 것을 지원합니다. 콘텐츠 소스의 참조 이름 일치를 참조하세요.

=== 패턴으로 브랜치 제외

값 앞에 !를 붙여 이전 패턴과 일치하는 브랜치를 선택 해제할 수 있습니다. 다음은 v로 시작하고 -beta로 끝나는 모든 브랜치를 제외하는 방법입니다:

.예제 6. 와일드카드를 사용하여 브랜치 제외
[source,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: [v*, '!v*-beta']
----


부정 패턴이 목록의 첫 번째에 나타나면 의미가 약간 변경됩니다. 이 위치의 부정 패턴은 앞에 * 항목이 있음을 의미합니다(예: '*', '!main').

.예제 7. 이름으로 제외되지 않은 모든 브랜치 포함
[source,yaml]
----
content:
  sources:
  - url: https://gitlab.com/antora/demo/demo-component-b.git
    branches: ['!main']
----


이 역 선택을 사용하지 않는 것이 좋습니다. 원하지 않는 브랜치를 가져올 수 있기 때문입니다. 일치시키려는 브랜치를 명확히 지정한 다음 제외를 사용하여 해당 목록을 줄이는 것이 가장 좋습니다.

=== 현재 로컬 브랜치 사용

로컬 저장소로 작업할 때 자주 브랜치를 전환할 수 있습니다. 현재 브랜치를 가리키도록 플레이북 파일을 업데이트해야 하는 것을 기억하지 않아도 되도록 예약된 값 HEAD를 사용할 수 있습니다.

[source,yaml]
----
content:
  sources:
  - url: ./workspace/project-a
    branches: HEAD
----

HEAD 값은 현재 브랜치의 이름을 사용하는 것과 동일합니다.



== Configure Your Site - Content Keys - Worktrees

branches를 보완하기 위해 Antora는 로컬 저장소에서 발견한 각 브랜치에 연결된 작업 트리를 사용할 수 있습니다. 이 동작은 worktrees 키를 사용하여 제어됩니다. worktrees 키는 키워드 또는 정확한 브랜치 이름이나 glob 패턴의 목록을 받아들입니다.

작업 트리는 태그가 아닌 브랜치와 관련이 있습니다.

=== worktrees 키

worktrees 키는 선택 사항입니다. 지정하지 않으면 Antora는 해당 저장소의 현재 브랜치가 branches 키와 일치하는 브랜치 중 하나인 경우 로컬 저장소의 메인(즉, 기본) 작업 트리를 자동으로 사용합니다. 이러한 일치가 이루어지면 Antora는 해당 브랜치의 git 트리에서 파일을 가져오는 대신 작업 트리에서 파일을 가져옵니다.

기본적으로 Antora는 연결된 작업 트리가 아닌 메인 작업 트리(메인 브랜치와 혼동하지 마세요)만 사용합니다. 이 동작을 사용자 정의하려면 worktrees 키를 설정할 수 있습니다.

NOTE: 메인 작업 트리는 반드시 메인 브랜치에 연결되는 것은 아니라 로컬 저장소의 현재 브랜치에 연결됩니다.

worktrees 키는 콘텐츠 소스의 항목에 지정됩니다. 이 키는 키워드 또는 브랜치 이름 패턴의 목록을 받아들입니다. 각 브랜치 이름 패턴은 정확한 브랜치 이름이거나 긍정 또는 부정 glob 패턴일 수 있습니다.

모든 작업 트리의 사용을 활성화하려면 worktrees 키를 키워드 값 true로 설정하면 됩니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: /path/to/repo-a/main
    branches: [v1.0, v2.0, main]
    worktrees: true
----

Antora가 연결된 작업 트리를 발견하려면 url 키가 메인 작업 트리의 위치(.git 폴더가 있는 곳)를 가리켜야 합니다. url이 연결된 작업 트리를 직접 가리키면 Antora는 이를 유효한 git 저장소로 인식하지 않습니다.

==== 콘텐츠 소스로 연결된 작업 트리

확장 기능을 사용하여 Antora가 연결된 작업 트리를 콘텐츠 소스로 사용하도록 지원할 수 있습니다. 다음 Antora 확장은 콘텐츠 소스의 url 키가 연결된 작업 트리를 가리킬 때 이를 감지한 다음 콘텐츠 소스를 재구성하여 메인 작업 트리를 가리키도록 합니다.

[source,js]
----
'use strict'

/* Copyright (c) 2022 OpenDevise, Inc.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License Version 2.0. If a copy of this license was not distributed
 * with this file, you can obtain one at http://mozilla.org/MPL/2.0/.
 */
const { promises: fsp } = require('fs')
const ospath = require('path')

/**
 * Rewrites local content sources to support the use of linked worktrees.
 *
 * @author Dan Allen <dan@opendevise.com>
 */
module.exports.register = function () {
  this.once('playbookBuilt', async ({ playbook }) => {
    const expandPath = this.require('@antora/expand-path-helper')
    for (const contentSource of playbook.content.sources) {
      const { url, branches } = contentSource
      if (url.charAt() !== '.') continue
      const absdir = expandPath(url, { dot: playbook.dir })
      const gitfile = ospath.join(absdir, '.git')
      if (await fsp.stat(gitfile).then((stat) => !stat.isDirectory(), () => false)) {
        const worktreeGitdir = await fsp.readFile(gitfile, 'utf8')
          .then((contents) => contents.trimRight().substr(8))
        const worktreeBranch = await fsp.readFile(ospath.join(worktreeGitdir, 'HEAD'), 'utf8')
          .then((contents) => contents.trimRight().replace(/^ref: (?:refs\/heads\/)?/, ''))
        const reldir = ospath.relative(
          playbook.dir,
          await fsp.readFile(ospath.join(worktreeGitdir, 'commondir'), 'utf8')
            .then((contents) => {
              const gitdir = ospath.join(worktreeGitdir, contents.trimRight())
              return ospath.basename(gitdir) === '.git' ? ospath.dirname(gitdir) : gitdir
            })
        )
        contentSource.url = reldir ? `.${ospath.sep}${reldir}` : '.'
        if (!branches) continue
        contentSource.branches = (branches.constructor === Array ? branches : [branches])
          .map((pattern) => pattern.replaceAll('HEAD', worktreeBranch))
      }
    }
  })
}
----

이 파일을 플레이북 파일 옆에 저장하고 Antora를 호출할 때 --extension ./linked-worktree-as-content-source.js를 사용하여 로드하세요. #535가 해결되면 이 패치는 더 이상 필요하지 않습니다.

=== 키워드로 작업 트리 지정

worktrees 키는 다음 키워드 값을 받아들입니다:

true::
모든 작업 트리(메인 작업 트리 및 모든 연결된 작업 트리)를 사용합니다.

false (또는 ~)::
작업 트리를 사용하지 않습니다(메인 작업 트리도 연결된 작업 트리도 사용하지 않음).

.::
메인 작업 트리만 사용합니다. (기본값)

*::
연결된 작업 트리만 사용합니다.

모든 작업 트리를 우회하려면 worktrees 키의 값을 키워드 false로 설정하세요.

.예제 2. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: /path/to/repo-a/main
    branches: [v1.0, v2.0, main]
    worktrees: false
----

=== glob 패턴으로 작업 트리 지정

Antora가 사용하는 작업 트리를 더 세밀하게 제어하려면 glob 패턴 목록을 지정할 수 있습니다. 작업 트리는 연결된 브랜치 이름으로 참조합니다. 따라서 glob 패턴은 브랜치 페이지에 설명된 것과 동일하게 작동합니다. 현재 브랜치를 참조하려면 . 키워드를 사용합니다. 있는 경우 해당 항목이 목록의 첫 번째에 나타나야 합니다.

메인 작업 트리와 v2.0 브랜치에 대해 연결된 작업 트리를 사용하도록 Antora를 구성해 보겠습니다. v1.0 브랜치의 파일은 해당 브랜치와 연결된 작업 트리가 있더라도 git 트리에서 읽습니다.

.예제 3. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: /path/to/repo-a/main
    branches: [v1.0, v2.0, main]
    worktrees: [., v2.0]
----

=== 여러 작업 트리 구성

여러 작업 트리를 구성하는 방법을 알아보려면 작성자 모드 페이지의 이 가이드를 참조하세요.



== Configure Your Site - Content Keys - Tags

tags 키는 정확한 태그 이름과 태그 이름을 일치시키기 위한 패턴 목록을 받아들입니다.

WARNING: 태그에서 문서를 가져오는 것은 일반적으로 권장하지 않습니다. 태그를 사용하는 경우 소프트웨어 릴리스를 위해 태그를 재사용하는 대신 전용 문서 태그를 사용하는 것이 좋습니다. 문서 버전 관리에 대한 철학에 대해 더 자세히 알아보려면 콘텐츠 소스 버전 관리 방법 페이지를 읽어보세요.

=== tags 키

tags 키는 선택 사항이며 content 키 또는 url 키에 직접 지정할 수 있습니다. 태그 이름 패턴 목록을 받아들입니다. 각 값은 정확한 태그 이름(예: v2.3.1, v3.9.4 등) 또는 패턴(예: v2.*, v@({1..9})*({0..9}).+({0..9}).x 등)일 수 있습니다. 태그 목록은 이러한 값 유형의 조합일 수도 있습니다.
.예제 1. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-z.git
    tags: [90.0, 93.0] <1>
  - url: https://git-service.com/org/repo-x.git
    tags: [95.0, releases/*, '!v1.*'] <2>
    branches: ~ <3>
----
<1> 여러 값을 대괄호([])로 묶습니다. 각 값을 쉼표(,)로 구분합니다.
<2> 정확한 태그 이름과 glob 패턴을 tags 키에 할당할 수 있습니다.
<3> branches를 설정하고 틸드(~) 값을 할당하여 기본 브랜치 필터를 비활성화합니다.

NOTE: tags 키를 설정해도 기본 브랜치 필터가 자동으로 비활성화되지는 않습니다!

이러한 값 패턴은 대소문자를 구분하지 않습니다. 즉, 문자의 대소문자에 관계없이 일치합니다. 값은 쉼표로 구분된 목록 또는 개별 줄의 단일 항목으로 지정할 수 있습니다.

=== 기본 태그 필터 추가

tags 키는 기본적으로 사용되지 않습니다(branches 키와 해당 기본 필터와 달리). tags 키를 명시적으로 선언하지 않는 모든 url 항목에 동일한 태그 필터를 적용하려면 content 키에 직접 tags 키를 지정하세요.

.예제 2. 기본 태그 필터 할당
[source,yaml]
----
content:
  tags: v* <1>
  branches: ~ <2> 
  sources:
  - url: https://git-service.com/org/repo-z.git <3> 
  - url: https://git-service.com/org/repo-x.git
    tags: [v*, '!v1.*'] <4>
  - url: https://git-service.com/org/repo-y.git <5>
----
<1> 기본 태그 필터를 만들려면 content 키 아래에 tags를 지정하세요.
<2> 모든 url 키에서 기본 브랜치 필터를 비활성화합니다.
<3> 이 url은 기본 태그 필터를 사용합니다.
<4> 이 tags 키에 할당된 값은 지정된 url에 적용되어 기본 태그 필터를 재정의합니다.
<5> 이 url은 기본 태그 필터를 사용합니다.

기본 태그 필터를 생성하면 Antora는 이제 tags 키를 명시적으로 선언하지 않는 모든 콘텐츠 소스에 대해 문자 v로 시작하는 태그를 발견하고 사용합니다.

=== 동일한 저장소에서 태그와 브랜치 사용

이 예제에서는 콘텐츠 저장소의 main 브랜치와 문자 v로 시작하는 태그를 로드합니다.

[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo-x.git
    branches: [main, sneaky-chinchilla]
    tags: v*
----

와일드카드(*) 사용에 대한 자세한 내용은 와일드카드를 참조하세요. Antora는 또한 제외, 중괄호, 대안, 범위 및 반복 패턴을 사용하여 태그 이름을 일치시키는 것을 지원합니다. 콘텐츠 소스의 참조 이름 일치를 참조하세요.



== Configure Your Site - Content Keys - Single Start Path

start_path 키는 저장소 또는 로컬 작업 트리의 루트를 기준으로 __antora.yml__ 파일이 위치한 곳을 식별합니다. 콘텐츠 소스 루트와 저장소의 루트가 동일한 경우 url에 이 키를 설정할 필요가 없습니다.

=== 기본 시작 경로

기본적으로 Antora는 콘텐츠 소스 저장소 또는 로컬 작업 트리의 루트(즉, url 키의 값)가 콘텐츠 소스 루트와 동일하다고 가정합니다. __antora.yml__이 콘텐츠 소스 저장소의 루트에 저장되어 있는 경우 구성 중인 url에 대해 start_path 키를 설정할 필요가 없습니다.

=== start_path 키

antora.yml이 url 키에 할당된 콘텐츠 소스 저장소의 루트에 저장되어 있지 않은 경우 start_path 키를 사용하여 Antora에게 콘텐츠 소스 루트를 찾을 위치를 알려줍니다. start_path 키는 url 키당 하나만 구성할 수 있습니다(content에 직접 설정할 수 없음).

.예제 1. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://git-service.com/org/repo.git
    branches: [main, v1.0]
    start_path: path/to/content-source-root
----

start_path 키는 저장소 루트를 기준으로 하는 상대 경로를 받아들입니다. **경로에 선행 슬래시나 후행 슬래시를 추가하지 마세요**.

=== url 키에 start_path 지정

start_path 키의 값은 콘텐츠 소스 루트에 대한 저장소 상대 경로입니다. 예제 2에 표시된 저장소에 대한 start_path 값을 정의해 보겠습니다.

.예제 2. 콘텐츠 소스 루트가 저장소 루트에 위치하지 않음
[source,text]
----
📒 repository <1>
  📂 packages
    📂 docs <2>
      📄 antora.yml <3>
      📂 modules
        📂 a-named-module
        📂 ROOT
----
<1> 콘텐츠 소스 저장소의 루트
<2> 콘텐츠 소스 루트
<3> 콘텐츠 소스 루트에 저장된 antora.yml 파일

Antora가 예제 2의 콘텐츠 소스 루트를 찾으려면 start_path 키의 값이 __antora.yml__이 위치한 디렉터리를 가리켜야 합니다.

.예제 3. start_path 값 할당

[source,yaml]
----
content:
  sources:
  - url: https://gitlab.com/org/repo.git
    branches: [v1.0, v2.6]
    start_path: packages/docs <1>
----
<1> 콘텐츠 소스 루트에 대한 저장소 상대 경로

예제 3에 지정된 start_path를 사용하면 Antora는 브랜치별로 pass:[https://gitlab.com/org/repo/-/tree/vx.x/packages/docs] 경로를 사용하여 콘텐츠 소스 루트를 찾습니다.



== Configure Your Site - Content Keys - Multiple Start Paths

=== 이 페이지에서 배울 내용

* [*] 단일 콘텐츠 소스 url의 브랜치에 대해 여러 시작 경로를 지정하는 데 start_paths 키를 사용하는 방법.
* [*] start_paths 키가 디렉터리 일치를 위해 지원하는 패턴.
* [*] 이전 패턴과 일치하는 디렉터리를 제외하는 방법.

=== start_paths 키

start_paths 키를 사용하면 단일 저장소 참조에 대해 여러 개의 콘텐츠 소스 루트를 지정할 수 있습니다. 즉, 각각 고유한 __antora.yml__ 파일을 가진 여러 구성 요소 버전, 구성 요소 또는 분산 구성 요소를 저장소의 단일 브랜치에 넣은 다음 동일한 콘텐츠 소스 항목을 사용하여 모든 해당 콘텐츠 소스 루트를 참조할 수 있습니다. 이러한 방식으로 콘텐츠를 구성하면 이 기능을 사용하여 플레이북의 콘텐츠 소스 장황함을 크게 줄일 수 있습니다.

==== start_path 키와의 관계

start_path 키는 주어진 콘텐츠 소스에 대해 플레이북에 단일 경로만 지정할 수 있습니다. 반대로 start_paths 키를 사용하면 여러 경로를 지정할 수 있습니다. 여러 경로는 와일드카드, 제외, 중괄호, 대안, 범위 및 반복 패턴을 사용하여 더욱 통합될 수 있습니다. Antora는 패턴을 하나 이상의 고정 경로로 해석합니다.

start_paths 키는 start_path 키와 상호 배타적입니다. 콘텐츠 소스에 start_path와 start_paths 키가 모두 있는 경우 start_paths 키만 사용됩니다.

==== git 참조와의 관계

단일 시작 경로와 마찬가지로 시작 경로는 git 참조(즉, 브랜치, 태그 및 작업 트리)별로 검색됩니다. 즉, 각 참조에 대해 각 시작 경로에서 구성 요소 버전 설명자를 찾아야 합니다.

일반적으로 여러 시작 경로를 사용할 때는 단일 참조(예: main)만 사용하게 됩니다. 이 시나리오에서 여러 참조를 사용하는 경우 각 참조가 동일한 레이아웃을 공유한다고 가정합니다.

=== 사용 사례

여러 시작 경로는 주로 두 가지 사용 사례를 수용하도록 설계되었습니다:

- 브랜치 대신 폴더를 사용하여 버전이 지정된 문서.
- 단일 저장소 브랜치(예: 모노레포)의 여러 제품에 대한 문서.

==== 폴더로 구성 요소 버전 지정

start_paths를 사용하여 여러 브랜치를 사용하는 대신 폴더를 사용하여 단일 저장소 브랜치에 구성 요소의 모든 버전을 저장할 수 있습니다. 버전 제어 시스템의 일부 이점을 놓칠 수 있지만 이 배열은 작성자가 한 번에 문서의 여러 버전을 자주 업데이트하는 경우 더 쉽게 만들 수 있습니다.

이 시나리오에서는 branches 키에 단일 값을 제공하고 start_paths 키를 사용하여 Antora에게 브랜치의 어떤 디렉터리를 콘텐츠 루트로 사용할지 알려줍니다. 버전 폴더의 이름이 일관되게 지정된 경우 패턴을 사용하여 쉽게 일치시킬 수 있습니다.

다음은 폴더를 사용하여 문서 버전을 저장하는 저장소 레이아웃의 예입니다:

[source,text]
----
📒 repository
  📂 docs
    📂 v1.0
      📄 antora.yml
    📂 v1.1
      📄 antora.yml
    📂 v2.0
      📄 antora.yml
----

==== 폴더로 구성 요소 지정

한 단계 더 나아가 여러 저장소를 사용하는 대신 폴더를 사용하여 단일 저장소 브랜치에 모든 구성 요소를 저장할 수 있습니다. 해당 구성 요소에 버전이 있는 경우 하위 폴더를 사용하여 버전도 저장할 가능성이 있습니다. 이 배열은 모든 문서가 동일한 팀이나 개인에 의해 유지 관리되고 git의 분산 특성이 방해가 되는 경우 가장 적합합니다. 또한 소스 코드가 동일한 저장소에 저장되는 여러 제품에 대해 모노레포에 사용할 수 있습니다. Antora는 해당 구조 내에서 시작되는 위치에 관계없이 문서를 발견할 수 있습니다.

이 시나리오에서는 branches 키에 단일 값을 다시 제공하고 start_paths 키를 사용하여 Antora에게 브랜치의 어떤 디렉터리를 콘텐츠 루트로 사용할지 알려줍니다. 단, 이번에는 콘텐츠 소스 루트가 단일 구성 요소의 버전뿐만 아니라 서로 다른 구성 요소(및 가능한 버전)와 일치합니다.

다음은 폴더를 사용하여 구성 요소를 저장하는 저장소 레이아웃의 예입니다:

[source,text]
----
📒 repository
  📂 product-a
    📂 docs
      📄 antora.yml
  📂 product-b
    📂 docs
      📄 antora.yml
  📂 product-c
    📂 docs
      📄 antora.yml
----

당연히 저장소에는 문서와 관련이 없는 다른 많은 파일과 폴더가 있을 수 있습니다.

=== 정확한 경로

등록할 경로가 몇 개뿐이라면 정확한 경로 패턴을 사용하는 것이 적합할 수 있습니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    start_paths: docs <1>
  - url: https://github.com/org/repo2
    start_paths: docs, more-docs <2> 
  - url: https://github.com/org/repo3
    start_paths: [docs, more-docs] <3>
  - url: https://github.com/org/repo4
    start_paths:
    - docs <4>
    - more-docs
----
<1> 단일 경로(start_path 사용과 동일).
<2> 쉼표로 구분된 정확한 경로 값 목록.
<3> 대괄호([])로 구분된 단일 행의 배열.
<4> 각각 선행 -로 구분된 여러 행의 배열.

=== 경로 글로빙

정확한 경로에 설명된 방법과 함께 패턴 일치를 구현하기 위해 기본 및 고급 경로 글로빙 기능의 많은 부분(전부는 아님)을 사용할 수 있습니다. 와일드카드, 중괄호 및 부정 패턴의 다양한 조합이 지원됩니다. Antora는 이러한 글로브 패턴을 사용하여 콘텐츠를 읽을 정확한 경로를 해석합니다.

==== 글로빙 제한 사항

Antora가 지원되는 전체 기본 및 고급 글로빙 규칙에 대해 경로 글로빙을 구현하는 방법에는 다음과 같은 제한 사항이 적용됩니다:

- 표현식의 와일드카드는 파일이 아닌 디렉터리하고만 일치합니다. 예를 들어 product-a/docs/*/index.adoc와 같은 표현식은 지원되지 않습니다.
- 와일드카드가 있더라도 중괄호 표현식에는 최소한 두 개의 항목이 있어야 합니다. 예를 들어 docs/product-{a*,b}는 중괄호 표현식으로 인식되지만 docs/product-{a*}는 그렇지 않습니다.
- 와일드카드가 포함된 세그먼트 다음에 오는 여러 문자와 일치하는 단일 중괄호 표현식은 작동하지 않습니다. pass:[예를 들어 */v{0..99}는 시작 경로 product-a/v2와 일치하지만 product-a/v99와는 일치하지 않습니다. 대신 반복 연산(*/v+({0..9}) 등)을 사용하거나 각 길이 순열에 대해 중첩된 중괄호 표현식(*/v{{1..9},{1..9}{0..9}} 등)을 사용하세요.]
- **/docs와 같은 이중 글로브스타 패턴은 지원되지 않습니다. 글로브는 계층 구조에서 단일 수준과 일치합니다.

==== 와일드카드

와일드카드 일치를 사용하면 start_paths 키에 할당해야 하는 값의 수를 줄일 수 있습니다. 예를 들어 브랜치에 여러 구성 요소가 저장되어 있는 경우 예제 2에 표시된 것과 같이 쉼표로 구분된 목록에 모두 나열할 수 있습니다.

.예제 2. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/product-a, docs/product-b, docs/product-c
----

또는 예제 3과 같이 와일드카드 세그먼트를 사용하고 선언해야 하는 값의 수를 줄일 수 있습니다.

.예제 3. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/product-*
----

와일드카드 일치는 패턴을 일관되게 유지하면서 콘텐츠 소스 루트를 추가할 때 새로운 콘텐츠 소스 루트를 등록할 가능성을 제공합니다.

==== 중괄호

중괄호 표현식은 확장할 항목의 쉼표로 구분된 명시적 목록(docs/product-{a,b,c,f})이나 확장할 항목의 범위(docs/product-{a..f})를 지정할 수 있습니다. 중괄호 표현식은 와일드카드가 포함되어 있더라도 단일 항목으로만 구성될 수 없습니다(예: docs/product-{a}와 docs/product-{a*}는 중괄호 표현식이 아님).

중괄호 표현식은 중첩될 수 있습니다(예: docs-*/v{{1..9},{1..9}{0..9}는 docs-*와 일치하는 루트 폴더의 하위 폴더 v1부터 v99까지 일치). 이 경우 각 중첩된 중괄호 표현식에 대한 각 순열이 테스트됩니다.

start_paths 값에 중괄호를 사용하면 확장 시 중괄호 내의 모든 항목이 존재해야 합니다(세그먼트 앞에 와일드카드 세그먼트가 없는 경우).

start_paths 값으로 docs/product-{a,b}를 지정하면 저장소 내에 다음 경로가 있어야 합니다:

- docs/product-a
- docs/product-b

중괄호 표현식 앞에 파일 경로에 접두사를 사용하여 Antora가 표현식에서 확인해야 하는 내용을 단순화할 수 있습니다.

.예제 4. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/v{1..9}
----

중괄호 표현식에 와일드카드를 사용하여 값을 확장하는 데 도움을 줄 수도 있습니다.

.예제 5. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    branches: main
    start_paths: docs/product-v{1*,2*} 
----

예제 5의 start_paths 패턴은 다음 경로와 일치합니다:

- docs/product-v1.1
- docs/product-v1.2
- docs/product-v1.2.1
- docs/product-v2.0
- docs/product-v2.1.1

==== 부정 글로브

이전에 일치한 패턴을 제외하려면 부정 패턴을 사용하세요. 이 접근 방식은 특정 패턴과 일치하는 디렉터리를 제외한 모든 디렉터리와 일치시키려는 경우에 유용합니다.

.예제 6. antora-playbook.yml
[source,yaml]
----
content:
  sources:
  - url: https://github.com/org/repo1
    start_paths:
    - docs/user/*
    - docs/dev/*
    - !**/*-beta.* <1>
----
<1> 부정 경로 글로빙 패턴은 경로 포함 뒤에 와야 하며 이미 일치한 위치 뒤에 선언되어야 합니다.

=== 무시되는 디렉터리

숨겨진 디렉터리(즉, .으로 시작하는 디렉터리)는 기본적으로 무시됩니다. start_paths 경로 글로빙 패턴에 포함하려면 패턴에 pass:[.*를 사용하세요. 예를 들어 -a 또는 -b 접미사가 있는 모든 숨겨진 디렉터리를 포함하려면 docs/.*-{a,b}를 사용하세요.]

=== 선택적 일치

와일드카드 세그먼트 다음에 오는 비와일드카드 세그먼트는 선택적으로 간주됩니다. 이 예외는 디렉터리 일치 로직을 단순화하기 위한 것입니다.

예를 들어 docs/product-*/client는 product-a/client와 일치하지만 product-b에 client 폴더가 없으면 무시합니다.

또 다른 유효한 예는 docs/product/*/client입니다. 여기서 *는 클라이언트 문서의 다른 버전 디렉터리(v1.0, v1.1 등)를 나타냅니다. 버전 디렉터리 중 하나에 client 폴더가 없으면 Antora는 유효성 검사 관점에서 이를 무시합니다.

파일 경로 패턴의 마지막 세그먼트에 일치하지 않는 중괄호 패턴이 포함된 경우 Antora는 유효성 검사 관점에서 이를 선택적으로 처리합니다.

예를 들어 docs/product-*/{client,b2b}는 docs/product-a/b2b가 없더라도 유효성 검사에 실패하지 않습니다.



== Configure Your Site - Content Keys - Fallback Version

version 키는 플레이북에서 직접 콘텐츠 소스에 해당하는 구성 요소 버전을 제어하는 방법을 제공합니다. 콘텐츠 소스의 version 키는 대체 값입니다. 구성 요소 버전 설명자(antora.yml 파일)가 구성 요소 버전에 대한 version 키를 정의하는 경우 해당 키의 값이 우선합니다.
=== version 키
version 키는 선택 사항입니다. version 키는 jesse와 같은 명명된 식별자, '1.5'와 같은 의미 있는 식별자, 버전 없음을 나타내는 예약된 값 ~, 예약된 값 true 또는 v/(?<version>*): $<version>과 같은 참조 이름 투영의 맵을 받아들입니다.
콘텐츠 소스는 여러 git 참조와 일치할 수 있습니다. 따라서 고정 값은 콘텐츠 소스가 단일 참조와 일치하도록 구성된 경우 또는 일치하는 모든 참조가 동일한 구성 요소 버전에 파일을 제공하는 경우에만 사용해야 합니다. 그렇지 않으면 이 키의 값은 true 또는 참조 이름 투영의 맵이어야 합니다.
플레이북이 version 키의 값을 제어할 수 있게 하려면 구성 요소 버전 설명자(antora.yml 파일)에서 version 키를 설정하지 마세요.
==== 버전으로 고정 값
다음 예제는 version 키에 고정 대체 값을 할당하는 방법을 보여줍니다. 고정 값은 명명된 식별자, 의미 있는 식별자 또는 버전 없음을 나타내는 값 ~일 수 있습니다.
.예제 1. version에 고정 값이 할당된 콘텐츠 소스
[source,yaml]
----
content:
sources:

url: https://git-service.com/org/repo-a.git
branches: v2.0.x
version: '2.0'


<1> 고정 값을 사용할 때는 단일 참조와만 일치시킵니다.
<2> 명명된 식별자, 의미 있는 식별자 또는 값 ~와 같은 고정 값을 할당합니다.
----

Antora가 지정된 브랜치(즉, v2.0)에서 구성 요소 버전 설명자를 찾을 때 해당 파일에 version 키가 정의되어 있을 것으로 예상하지 않습니다. 대신 콘텐츠 소스에 지정된 version 키의 고정 값(즉, 2.0)을 사용합니다.
==== 버전으로 참조 이름
Antora의 콘텐츠는 git 저장소에서 가져오므로 콘텐츠 소스(구성 요소 버전 설명자가 저장되는 위치)의 git 참조 이름(브랜치 또는 태그 이름)을 버전으로 사용하려고 할 수 있습니다. 이렇게 하려면 version 키에 예약된 값 true를 할당하세요. Antora는 값 true를 참조 이름으로 자동 대체합니다.
다음 예제는 참조 이름을 version 키의 대체 값으로 사용하는 방법을 보여줍니다.
.예제 2. 참조 이름을 버전으로 사용하는 콘텐츠 소스
[source,yaml]
----
content:
sources:

url: https://git-service.com/org/repo-b.git
branches: v*
version: true


<1> 임의의 수의 참조와 일치시킵니다.
<2> 값 true는 Antora에게 일치하는 참조 이름을 값으로 사용하도록 지시합니다.
----

Antora가 지정된 브랜치(즉, v2.0)에서 구성 요소 버전 설명자를 찾을 때 해당 파일에 version 키가 정의되어 있을 것으로 예상하지 않습니다. 대신 참조 이름을 사용합니다. Antora가 사용하는 값은 항상 전체 참조 이름(예: refs/heads/v1.0)이 아닌 짧은 참조 이름(예: v1.0)입니다.
==== 버전으로 참조 이름 투영
참조 이름이 대체 버전으로 사용하기에 충분히 세분화되지 않을 수 있습니다. 더욱이 동일한 git 트리가 기능 브랜치와 같이 서로 다른 명명 체계를 가진 git 참조를 통과할 수 있습니다. 이러한 경우에는 값을 있는 그대로 사용하는 것이 아니라 참조 이름에서 버전을 추출하거나 파생시키려고 합니다. 그럴 때는 참조 이름 투영을 사용하여 대체 버전을 정의하면 됩니다.
참조 이름 투영은 패턴(키)과 대체(값)의 맵으로 표현됩니다. 참조 이름 투영을 사용하면 패턴을 사용하여 참조 이름을 일치시킨 다음 해당 일치를 기반으로 버전을 작성할 수 있습니다. 패턴은 Antora에게 사용할 항목과 추출할 부분을 알려줍니다. 대체는 Antora에게 일치하는 참조 이름에서 버전을 파생시키는 방법을 알려줍니다.
다음 예제는 투영을 사용하여 참조 이름에서 version 키의 값을 계산하는 방법을 보여줍니다.
.예제 3. 참조 이름에서 버전을 파생시키는 콘텐츠 소스
[source,yaml]
----
content:
sources:

url: https://git-service.com/org/repo-c.git
branches: [v*, feature/]
version:
v(?<version>+({0..9}).+({0..9})).x: $<version>
feature/()/*: $1


<1> 서로 다른 명명 패턴을 가진 임의의 수의 참조와 일치시킵니다.
<2> v2.0.x와 같은 참조 이름의 의미 있는 식별자를 일치시키고 추출합니다.
<3> feature/로 시작하는 참조 이름의 경우 첫 번째 슬래시와 두 번째 슬래시 사이의 값을 추출합니다.
----

투영의 키는 glob 패턴입니다(extglob, 범위 및 일부 정규식 구성의 조합). 패턴은 플레이북의 콘텐츠 소스에 대한 브랜치나 태그를 일치시키는 데 사용되는 패턴과 동일한 일치 기능을 가지고 있습니다.
패턴의 괄호(즉, 소괄호) 사이의 문자는 일치 그룹을 정의합니다. 여는 중괄호가 ?<name>으로 시작하면 해당 그룹은 꺾쇠 괄호 사이에 지정된 이름에 할당됩니다. 그렇지 않으면 그룹은 패턴에서의 위치에 따라 1부터 시작하는 인덱스에 할당됩니다.
일치 그룹은 대체에서 참조할 수 있습니다. 일치 그룹 참조 앞에는 달러 기호($)가 옵니다. 명명된 그룹은 $<name> 형식으로 참조할 수 있으며, 여기서 이름은 다시 꺾쇠 괄호 사이에 지정됩니다. 인덱싱된 그룹은 $1과 같이 번호로 참조할 수 있습니다. 전체 참조 이름은 $&를 사용하여 참조할 수 있습니다.
일치 그룹에 슬래시가 포함된 경우 Antora는 각 슬래시를 하이픈으로 대체합니다.
Antora는 일치하는 첫 번째 패턴의 값을 사용합니다. 패턴 중 어느 것도 참조 이름과 일치하지 않으면 Antora는 참조 이름을 버전으로 사용하는 것으로 대체합니다.
Antora는 와일드카드, 제외, 중괄호, 대안, 범위 및 반복 패턴을 사용하여 참조 이름을 일치시키는 것을 지원합니다. 콘텐츠 소스의 참조 이름 일치를 참조하세요.



== Configure Your Site - Content Keys - Edit URL

=== 이 페이지에서 배울 내용

Antora가 각 페이지의 편집 URL을 구축하는 방법.
편집 URL을 사용자 정의하는 방법.
편집 URL을 비활성화하는 방법.

=== Antora의 기본 편집 URL 할당
Antora는 호스팅된 GitLab(gitlab.com), GitHub(github.com), Bitbucket(bitbucket.org) 및 Pagure(pagure.io) 서비스(SAAS)에서 소싱된 모든 파일에 대해 자동으로 편집 URL을 파생시킵니다. 이를 위해 먼저 콘텐츠 소스 URL을 웹 URL로 변환한 다음 현재 파일의 참조 및 경로 정보를 사용하여 호스팅된 저장소의 해당 파일 편집 모드에 대한 URL을 구성합니다.
기본 UI에서 Antora는 이 값(설정된 경우)을 사용하여 각 페이지의 오른쪽 상단에 "이 페이지 편집" 링크를 만듭니다. 해당 링크는 방문자를 호스팅된 git 서비스에서 제공하는 해당 파일의 편집 인터페이스로 안내합니다. 예를 들어 이 페이지의 "이 페이지 편집" 링크를 클릭하면 브라우저가 GitLab의 파일 편집 인터페이스(gitlab.com에서)로 이동하여 이 페이지를 만드는 데 사용된 AsciiDoc 소스를 로드합니다.
한 가지 예외는 저장소가 비공개인 경우입니다. 이 경우 기본 UI에는 "이 페이지 편집" 링크가 표시되지 않습니다. 그러나 사이트를 빌드할 때 FORCE_SHOW_EDIT_PAGE_LINK 환경 변수(예: FORCE_SHOW_EDIT_PAGE_LINK=true)를 설정하여 기본 UI에 링크를 강제로 표시할 수 있습니다. 또는 UI 템플릿을 사용자 정의하여 로직을 변경할 수 있습니다.
또 다른 예외는 페이지가 로컬 파일 시스템(즉, 작업 트리)에서 시작되는 경우입니다. 이 경우 기본 UI는 "이 페이지 편집" 링크에 로컬 file:// URI를 사용합니다. 사이트를 빌드할 때 CI 환경 변수(예: CI=true)를 설정하여 기본 UI에서 항상 편집 URL을 사용하도록 강제할 수 있습니다. (이 환경 변수는 대부분의 CI 환경에서 이미 설정되어 있습니다). CI 환경 변수가 설정된 경우 사이트가 file:// URI에 액세스할 수 없는 원격 서버에 게시되고 있다고 가정합니다. 이 환경 변수를 설정하는 대신 UI 템플릿을 사용자 정의하여 로직을 변경할 수 있습니다.
이것은 편집 URL이 사용되는 방법을 다룹니다. 이제 값을 사용자 정의하는 방법을 살펴보겠습니다.
=== 편집 URL 사용자 정의
edit_url 키는 인식되지 않는 git 솔루션을 사용하거나 "이 페이지 편집"을 페이지 소스 파일의 원시 또는 렌더링된 보기와 같은 대체 보기에 연결하려는 경우에 유용합니다.
edit_url 키는 플레이북에 설정되며 모든 콘텐츠 소스에 적용되거나 개별 소스별로 사용자 정의될 수 있습니다. 이 키는 git 솔루션 또는 소스 파일 보기의 URL 세그먼트와 {web_url}, {refname}, {reftype}, {refhash} 및 {path}의 여러 자리 표시자 세그먼트를 포함하는 URL 패턴을 받아들입니다. Antora는 처리 시점에 파일의 출처 정보를 사용하여 이러한 자리 표시자를 자동으로 충족합니다.
.예제 1. edit_url 키와 값
[source,yaml]
edit_url: '{web_url}/blob/{refname}/{path}'
<1> edit_url의 값이 중괄호({)로 시작하는 경우 작은따옴표(')로 묶습니다.
예제 1은 여러 자리 표시자를 포함하는 가상의 편집 URL 패턴을 보여줍니다. blob라는 단어는 자리 표시자로 표시되지 않는 URL 세그먼트의 예입니다. 다음 섹션에서는 이러한 자리 표시자의 역할을 설명합니다.
==== Antora는 페이지에 대한 편집 URL을 어떻게 조립하나요?
edit_url이 기본적으로 또는 명시적으로 설정된 경우 Antora는 콘텐츠 소스 및 파일 출처 정보에 따라 각 페이지에 대해 {web_url}, {refname}, {reftype}, {refhash} 및 {path} 자리 표시자의 값을 계산합니다. 그런 다음 edit_url 키에 할당된 패턴을 사용하여 각 페이지의 고유한 편집 URL을 조립합니다.
web_url::
{web_url} 자리 표시자는 Antora가 git URL에서 자동으로 계산하는 콘텐츠 소스 저장소에 해당하는 웹 URL입니다. 예를 들어 https://gitlab.com/cave/sneaky.git는 https://gitlab.com/cave/sneaky로 변환됩니다. Antora가 계산하는 웹 URL과 다른 웹 URL을 사용하는 경우 이 자리 표시자를 생략할 수 있습니다.
refname::
{refname}은 git 참조의 이름입니다(예: v2.1.x, main, rawhide).
reftype::
{reftype}은 git 참조의 유형입니다(즉, tag 또는 branch).
refhash::
{refhash}는 git 참조의 커밋 해시입니다(예: aab0e5684afe0d4e05955fbef72b6e5538bb1ec5).
path::
{path}는 저장소의 루트에 상대적인 소스 파일의 경로입니다. start_path가 지정된 경우 이를 포함합니다.
자리 표시자에 대해 Antora가 계산할 값의 예를 보려면 예제 2에 표시된 콘텐츠 소스, 브랜치 및 편집 URL 패턴 입력을 사용하겠습니다.
.예제 2. edit_url 자리 표시자
[source,yaml]
content:
sources:

url: https://app.company.com/the-group/zap.git
branches: v1.2.5, next
edit_url: '{web_url}/_src/{refname}/u890/{path}'


index.adoc라는 파일에서 생성된 페이지의 편집 URL이 어떻게 되는지 결정해 보겠습니다. 이 index.adoc 파일은 zap 저장소의 v1.2.5 브랜치에 있는 ROOT 모듈의 pages 디렉터리에 저장되어 있습니다. 예제 2의 edit_url에 할당된 패턴을 사용하여 Antora는 예제 3에 표시된 대로 index.adoc에 대한 편집 URL을 계산합니다.
.예제 3. 예제 2의 입력을 사용한 index.adoc의 편집 URL
[source,text]
https://app.company.com/the-group/zap/_src/v1.2.5/u890/modules/ROOT/pages/index.adoc
Antora는 {web_url}을 콘텐츠 소스의 웹 URL로 대체합니다. 이 경우 .git은 url 값의 끝에서 제거됩니다. {refname}은 v1.2.5 git 브랜치 참조로 대체됩니다. 마지막으로 {path}는 저장소의 루트를 기준으로 소스 파일의 경로로 대체됩니다. 이 소스에는 지정된 시작 경로가 없으므로 결과 경로는 modules/ROOT/pages/index.adoc입니다.
콘텐츠 소스에 할당된 start_path가 있으면 Antora는 이를 {path} 앞에 추가합니다.
.예제 4. start_path와 edit_url이 설정된 콘텐츠 소스
[source,yaml]
content:
sources:

url: https://app.company.com/the-group/zap.git
branches: v1.2.5, next
start_path: learn/docs
edit_url: '{web_url}/_src/{refname}/u890/{path}'


예제 4의 입력을 사용하면 index.adoc의 편집 URL은 다음과 같습니다:
.예제 5. 예제 4의 입력을 사용한 index.adoc의 편집 URL
[source,text]
https://app.company.com/the-group/zap/_src/v1.2.5/u890/learn/docs/modules/ROOT/pages/index.adoc
=== 여러 콘텐츠 소스에 동일한 edit_url 적용
모든 콘텐츠 소스 또는 대부분의 콘텐츠 소스가 동일한 edit_url을 사용하는 경우 content 키에 직접 설정할 수 있습니다.
.예제 6. content 키에 edit_url 설정

[source,yaml]
----
content:
edit_url: '{web_url}/_src/{refname}/u890/{path}'
sources:

url: https://app.company.com/the-group/zap.git
branches: v1.2.5, next
url: https://app.company.com/city/team-l/zonk.git
branches: v2.*


<1> edit_url이 content 키에 직접 설정된 경우 개별 콘텐츠 소스에서 키가 재설정되거나 비활성화되지 않는 한 해당 값이 모든 콘텐츠 소스에 적용됩니다.
----

예제 7에서 볼 수 있듯이 edit_url 키는 content 키에 설정된 경우에도 개별 콘텐츠 소스에 설정할 수 있습니다.
.예제 7. content 키와 개별 소스에 edit_url 설정

[source,yaml]
----
content:
edit_url: '{web_url}/_src/{refname}/u890/{path}'
sources:

url: https://app.company.com/the-group/zap.git
branches: v1.2.5, next
url: https://git.secretbase.org/ack/boom
branches: dev
edit_url: '{web_url}/{refname}/ping/0/{path}'
url: https://app.company.com/city/team-l/zonk.git
branches: v2.*


<1> 이 edit_url 키는 content 키에 직접 설정됩니다. 개별 콘텐츠 소스에서 키가 재설정되거나 비활성화되지 않는 한 해당 값이 모든 콘텐츠 소스에 적용됩니다.
<2> 이 콘텐츠 소스는 content 키에 직접 설정된 edit_url 키의 값을 상속합니다.
<3> edit_url이 개별 콘텐츠 소스에 설정된 경우 해당 값은 content 키에 설정된 edit_url 키에 할당된 값 대신 사용됩니다.
<4> 이 콘텐츠 소스는 content 키에 직접 설정된 edit_url 키의 값을 상속합니다.
----

=== "이 페이지 편집"에 연결된 소스 파일 보기 변경
기본적으로 페이지의 편집 URL은 저장소가 호스팅된 git 서비스의 파일 편집 인터페이스로 연결됩니다. 이는 콘텐츠 소스가 Antora가 인식하는 호스팅된 git 서비스 중 하나에
저장되어 있는 한 작동합니다. 여기에는 GitLab(gitlab.com), GitHub(github.com), Bitbucket(bitbucket.org) 및 Pagure(pagure.io)가 포함됩니다. 저장소가 이러한 호스팅된 서비스 중 하나에 저장되어 있지 않은 경우(예: 자체 호스팅된 GitLab 또는 Bitbucket 인스턴스) edit_url 키를 사용하여 이 URL이 구성되는 방식을 구성할 수 있습니다. 예를 들어 예제 8에서는 각 페이지의 계산된 편집 URL이 이제 해당 소스 파일의 GitLab 렌더링된 파일 보기에 대한 URL이 됩니다.
.예제 8. 편집 URL을 대체 소스 파일 보기로 라우팅
----
[source,yaml]
content:
edit_url: '{web_url}/blob/{refname}/{path}'
sources:

url: https://gitlab.com/cave/sneaky.git
branches: v2.0, v1.0


<1> edit_url 키에는 GitLab의 렌더링된 파일 보기에 대한 URL 패턴이 할당됩니다.
----

예제 8의 입력을 사용하면 https://gitlab.com/cave/sneaky.git 저장소에서 소싱된 각 페이지의 "이 페이지 편집" 링크가 GitLab의 해당 소스 파일의 렌더링된 보기로 연결됩니다.
"이 페이지 편집"의 링크 텍스트를 변경하거나 이미지로 대체하려면 UI를 업데이트해야 합니다.
=== 편집 URL 비활성화
저장소가 비공개인 경우 편집 URL이 정의되어 있더라도 기본 UI에는 현재 페이지에 대한 "이 페이지 편집" 링크가 표시되지 않습니다. 그러나 저장소가 공개되어 있고 링크를 비활성화하거나 다른 이유로 편집 URL을 무효화하려는 경우 플레이북을 사용하여 이를 수행할 수 있습니다.
edit_url 키는 모든 콘텐츠 소스 또는 개별 콘텐츠 소스에 대해 편집 URL 기능을 끌 수 있습니다. 편집 URL을 비활성화하려면 edit_url 키에 틸드(~) 또는 단어 false를 할당하세요.
[source,yaml]
----
content:
branches: v*
edit_url: ~
sources:

url: https://app.company.com/the-group/zap.git
url: https://gitlab.com/cave/sneaky.git


<1> content 키에 edit_url을 설정하고 값 ~를 할당하여 모든 콘텐츠 소스에 대해 편집 URL 기능을 비활성화합니다. 틸드(~)는 편집 URL 기능을 비활성화합니다. 개별 콘텐츠 소스에서 edit_url이 재설정되지 않는 한 콘텐츠 소스에서 소싱된 페이지에 대해 편집 URL이 생성되지 않습니다.
----

edit_url은 개별 콘텐츠 소스에서도 비활성화할 수 있습니다.

[source,yaml]
----
content:
branches: v*
sources:

url: https://app.company.com/the-group/zap.git
edit_url: ~
url: https://gitlab.com/cave/sneaky.git


<1> edit_url 키는 이 개별 콘텐츠 소스에 설정되고 값 ~가 할당됩니다.
<2> edit_url이 content 키 또는 이 콘텐츠 소스에 명시적으로 설정되지 않았으므로 Antora에 내장된 기본 편집 URL 동작을 사용합니다.
----

=== 콘텐츠 소스를 기본 편집 URL 동작으로 되돌리기
content 키 수준에서 edit_url 키를 설정하거나 비활성화한 경우에도 개별 콘텐츠 소스에 대해 기본 편집 URL 동작으로 되돌릴 수 있습니다. 소스에서 edit_url을 설정하고 값 true를 할당하세요.
.예제 9. edit_url을 기본 동작으로 재설정
[source,yaml]
----
content:
branches: v*
edit_url: '{web_url}/_src/{refname}/u890/{path}'
sources:

url: https://app.company.com/the-group/zap.git
url: https://gitlab.com/cave/sneaky.git
edit_url: true
url: https://app.company.com/city/team-l/zonk.git


<1> edit_url이 content 키에 직접 설정된 경우 개별 콘텐츠 소스에서 키가 재설정되거나 비활성화되지 않는 한 해당 값이 모든 콘텐츠 소스에 적용됩니다.
<2> edit_url 키에 값 true를 할당하여 콘텐츠 소스를 기본 편집 URL 동작으로 되돌립니다.
----

예제 9에서 zap 및 zonk 콘텐츠 소스는 content 키에 설정된 edit_url을 사용하는 반면 sneaky 소스는 Antora에 내장된 기본 편집 URL 동작을 사용합니다.



== Configure Your Site - Content Keys - Refname Matching in Content Sources

Antora의 핵심은 다양한 git 저장소의 참조에 저장된 콘텐츠를 수집하는 것입니다. 플레이북은 브랜치, 태그 및 작업 트리를 포함하여 Antora가 고려할 참조 이름(즉, 참조 이름)과 해당 참조 내에서 검색할 시작 경로를 지시하는 여러 키를 제공합니다. 이 필터를 구성하는 한 가지 방법은 각 참조 이름을 개별적으로 나열하는 것입니다. 그러나 콘텐츠는 매우 빠르게 이동하는 경우가 많기 때문에 이 접근 방식은 번거롭고 정적일 수 있습니다. 이것이 Antora가 패턴 매칭을 사용하여 참조 이름을 대량으로 포함하고 제외할 수 있는 기능을 제공하는 이유입니다. 패턴 매칭 접근 방식은 구성을 단순화하고 새로운 참조 이름이 사용 가능해짐에 따라 자동으로 검색할 수 있다는 이점이 있습니다.
이 페이지에서는 콘텐츠 소스의 참조 이름을 일치시키는 데 사용할 수 있는 값 유형과 구문에 대해 설명합니다.
=== 값 유형
이 페이지에서 다루는 키는 두 가지 유형의 값을 받아들입니다:

문자열(즉, 문자 시퀀스)
문자열 배열

문자열 값은 쉼표로 분리되며 가능하면 공백이 뒤따릅니다. 예를 들어 문자열 v1.0.x, v2.0.x는 두 개의 문자열 v1.0.x와 v2.0.x의 배열이 됩니다.
일반적으로 값의 문자와 YAML(또는 선택한 구성 언어)의 특수 구문 간의 충돌을 피하기 위해 문자열 값을 작은따옴표로 묶는 것이 가장 좋습니다.
패턴을 사용하여 참조 이름을 일치시키는 경우 배열 구문을 사용하는 것이 좋습니다. 단일 또는 쉼표로 구분된 문자열 구문은 정확히 일치하는 경우에만 사용하기 위한 것입니다. 그렇지 않으면 예상치 못한 동작이 발생할 수 있습니다.
=== 정확한 일치
참조 이름을 일치시키는 가장 간단한 방법은 정확한 이름으로 지정하는 것입니다. 예를 들어 main이라는 단일 브랜치를 다음과 같이 일치시킬 수 있습니다:
[source,yaml]
branches: main
이전 릴리스 라인에 대한 브랜치 이름도 추가하려면 쉼표로 구분할 수 있습니다:
[source,yaml]
branches: v1.0.x, v2.0.x, main
또한 값을 명시적으로 표현하기 위해 배열로 표현할 수도 있습니다:
[source,yaml]
branches: [v1.0.x, v2.0.x, main]
"정확한 일치"라고 할 때는 참조의 짧은 이름과 일치하는 것을 의미합니다. 예를 들어 remotes/origin/v1.0.x 또는 heads/v1.0.x와 일치하는 것이 아니라 v1.0.x와 일치합니다. 그 이유는 Antora가 원격 및 로컬 참조를 모두 찾아 로컬 참조를 선호하고 고유한 짧은 이름당 하나만 선택하기 때문입니다.
정확한 일치가 리터럴 값처럼 보이지만 사실은 패턴입니다. 그리고 패턴은 항상 참조 이름의 처음부터 끝까지 일치합니다. 그러나 대부분의 참조 이름에는 패턴 일치 구문에서 의미가 있는 문자(.도 없음)가 포함되어 있지 않습니다. 따라서 정확히 일치하는 참조 이름을 찾는 리터럴 값처럼 작동합니다. 그러나 예상한 참조 이름과 일치하지 않는 경우 패턴이라는 사실을 염두에 두십시오.
=== 와일드카드(기본 글로빙)
플레이북에서 정확한 참조 이름 목록을 유지 관리하는 것은 지루하고 번거로울 수 있습니다. 이것이 Antora가 패턴 매칭을 사용하여 참조 이름을 대량으로 일치시킬 수 있도록 하는 이유입니다.
가장 기본적인 패턴 매칭 도구는 와일드카드(*)입니다. 이 패턴의 사용을 종종 글로빙이라고 합니다. 항목의 글로브를 캡처하는 데 사용하기 때문입니다.
단독 와일드카드를 사용하여 존재하는 모든 참조 이름을 글로브할 수 있습니다:
[source,yaml]
branches: '*'
그러나 그렇게 하고 싶은 경우는 거의 없을 것입니다. 대신 v로 시작하는 모든 참조 이름을 일치시키고 싶다고 가정해 보겠습니다. 문자 뒤에 별표를 배치하여 이를 수행할 수 있습니다.
[source,yaml]
branches: v*
*는 "임의의 수의 문자"를 의미합니다. 이 경우 참조 이름 시작 부분의 v 다음에 오는 임의의 수의 문자와 일치합니다.
또한 문자열의 두 부분 사이에 와일드카드를 사용하여 두 부분 사이의 임의의 수의 문자와 일치시킬 수 있습니다. 버전 번호를 더 정확하게 일치시키기 위해 사용해 보겠습니다.
[source,yaml]
branches: v*.*.x
이 패턴은 v1.0.x, v2.0.x, 심지어 v20.10.x와 일치합니다. 그러나 참조 이름 자체에 숫자만 있는 경우에만 숫자와 일치합니다. 즉, very.last.x와도 일치할 수 있습니다. 나중에 더 고급 패턴으로 들어갈 때 해당 문제를 해결할 수 있겠지만 과도한 일치 문제와 제외의 필요성을 가져옵니다.
=== 제외
지금까지 우리는 일치시키고 싶은 참조 이름, 즉 포함에 대해 이야기했습니다. 패턴을 사용하기 시작하면 너무 많은 항목과 일치하는 문제가 발생할 수 있습니다. 하나 이상의 제외를 사용하여 이전에 일치한 항목에서 제거할 수 있습니다. 제외 항목은 항상 !로 시작합니다.
버전과 유사한 모든 참조 이름을 일치시키되 Antora 사용을 시작하기 전 버전은 제외하려 한다고 가정해 보겠습니다.
[source,yaml]
branches: [v*.*.x, '!v1.0.x']
권장대로 값을 배열 구문으로 전환했습니다. 또한 제외 항목을 작은따옴표로 묶어 YAML 파서를 혼동하지 않도록 해야 합니다. 의심스러울 때는 문자열 값을 작은따옴표로 묶으세요. 그렇게 해도 절대 해가 되지 않습니다.
실수로 일치시킨 비버전 참조 이름을 버려 보겠습니다:
[source,yaml]
branches: [v*.*.x, '!v1.0.x', '!very.last.x']
제외 패턴에서 와일드카드를 사용하여 이미 일치시킨 항목을 대량으로 일치시키고 해당 일치 항목을 제거할 수도 있습니다.
[source,yaml]
branches: [v*..x, '!v1..x', '!very.last.x']
와일드카드는 유용한 도구이지만 일치시키는 문자에 대해 매우 느슨합니다. 보다 정확해져야 할 필요가 있다는 것을 알 수 있습니다. 그때 중괄호가 등장합니다.

=== 중괄호
중괄호는 중괄호({}) 안에 묶인 패턴으로도 알려져 있습니다. Antora에서 지원되는 중괄호 표현식에는 세 가지 종류가 있습니다:

쉼표로 구분된 대체 문자 시퀀스 목록
알파 또는 숫자 범위
단계가 있는 숫자 범위

==== 대안

{this,that}과 같은 대체 문자의 쉼표로 구분된 목록은 "this 또는 that"으로 읽어야 합니다. 이는 버전의 특정 숫자를 일치시키는 데 유용할 수 있습니다. 매우 제한된 수의 주요 버전 참조 이름만 일치시키려 한다고 가정해 보겠습니다. 대안 중괄호 표현식을 사용하여 식별할 수 있습니다:
[source,yaml]
branches: v{5,6}.*.x
이 표현식은 v5.0.x, v5.1.x 및 v6.0.x와 일치합니다.
대안 표현식을 사용하여 빈 항목을 사용하여 문자 또는 세그먼트의 부재와 일치시킬 수 있습니다. v 접두사를 선택 사항으로 만드는 것을 고려해 보겠습니다.
[source,yaml]
branches: '{,v}{5,6}.*.x'
와일드카드를 대안 항목에서 사용할 수도 있습니다. 예를 들어 다음과 같은 방식으로 사전 릴리스를 일치시킬 수 있습니다:
[source,yaml]
branches: '{,v}{5,6}..x{,-}'
주어진 주요 버전 참조 이름에 대한 특정 부 버전을 일치시키는 또 다른 경우를 고려해 보겠습니다:
[source,yaml]
branches: v5.{7,8}.x
v(또는 다른 선행 문자)로 시작하지 않는 참조 이름을 일치시킬 수도 있습니다.
[source,yaml]
branches: 5.{7,8}.x
상상할 수 있듯이 숫자를 많이 지정하면 범위를 형성하기 시작할 수 있습니다. 범위 구문을 사용하여 대안을 통합할 수 있습니다.
==== 범위
일치시키는 문자가 범위의 구성원인 경우 시작 값과 끝 값만 지정하고 두 개의 마침표(..)로 구분하여 지정할 수 있습니다. 범위는 각 항목이 고려되는 또 다른 종류의 대안입니다.
숫자가 있는 일치 항목만 고려하도록 버전 패턴을 다시 살펴보겠습니다.
[source,yaml]
branches: v{1..9}.{0..9}.x
이제 더 이상 very.last.x와 일치하지 않습니다. 그러나 v20.10.x와도 더 이상 일치하지 않습니다. 범위를 확장하여 이를 수정할 수 있습니다. 범위는 한 자리 숫자로 제한되지 않습니다.
[source,yaml]
branches: v{1..99}.{0..99}.x
그러나 이를 작성하는 더 효율적인 방법이 있으며 확장된 글로빙 섹션에서 다룰 것입니다.
다른 예로 돌아가서 5.9.x가 방금 출시되었고 이를 Antora 시대 버전 번호 패턴에 추가하려 한다고 가정해 보겠습니다. 기본 대안에서 범위로 전환할 수 있습니다.
[source,yaml]
branches: 5.{7..9}.x
또는 제외를 사용하여 반대 방식으로 이 일치를 표현할 수 있습니다.
[source,yaml]
branches: ['5.*.x', '!5.{0..6}.x']
기본적으로 범위는 각 항목을 고려합니다. 단계를 사용하여 항목을 건너뛸 수 있습니다.
==== 단계
두 개의 마침표로 오프셋된 세 번째 매개변수를 추가하여 범위의 단계 크기를 조정할 수 있습니다. 단계 크기는 패턴 일치자에게 범위의 다음 항목으로 이동할 때 얼마나 멀리 갈지 알려줍니다. 다음 패턴을 사용하여 2부터 8까지의 모든 짝수 주요 버전을 일치시킬 수 있습니다:
[source,yaml]
branches: v{2..8..2}.*.x
시작 값을 변경하면 대신 홀수 주요 버전을 일치시킬 수 있습니다:
[source,yaml]
branches: v{1..9..2}.*.x
중괄호 자체로는 복잡한 패턴을 표현하는 능력이 제한적입니다. 중괄호 표현식을 진정으로 강력하게 만들려면 확장된 글로빙과 결합해야 합니다.
=== 확장된 글로빙과 반복
지금까지 우리는 문자 시퀀스, 대안 또는 범위 여부에 관계없이 세그먼트의 단일 발생을 일치시켰습니다. 이러한 세그먼트가 발생해야 하는 횟수(있는 경우)를 지정하여 패턴을 더 발전시킬 수 있습니다. 확장된 글로브를 사용하면 패턴이나 패턴 목록을 한 쌍의 괄호로 묶은 다음 반복 연산자를 할당할 수 있습니다.
Antora의 패턴 일치는 다음 연산자를 지원합니다:

* - 0번 이상
+ - 1번 이상(즉, 적어도 한 번)
? - 0번 또는 1번(즉, 선택적)
@ - 정확히 한 번(연산자가 지정되지 않은 경우 암시됨)
! - 존재하지 않아야 함

다음 확장 글로브는 {0..9}를 작성하는 보다 형식적인 방법입니다:
[source,text]
@({0..9})
숫자의 모든 시퀀스와 일치하는 확장 글로브는 다음과 같습니다.
[source,text]
*({0..9})
이러한 반복 사용은 다음 범위보다 훨씬 더 효율적이며 사용하지 않는 것이 좋습니다:
[source,text]
{0..100}
패턴 목록 뒤에 *를 넣을 수 있지만 권장하지 않습니다. 반복 연산은 항상 패턴 목록 앞에 배치해야 합니다.
확장된 글로빙을 사용하여 v1.0.0부터 시작하여 모든 부 버전 참조 이름을 정확하게 일치시킬 수 있습니다:
[source,yaml]
branches: v@({1..9})*({0..9}).+({0..9}).x
또는 더 간결하게:
[source,yaml]
branches: v{1..9}*({0..9}).+({0..9}).x
주요 버전이 0으로 시작하면 안 된다는 것을 말하고 있습니다. 그런 다음 임의의 수의 숫자(예: 1, 10 등)가 뒤따를 수 있습니다. 부 버전은 하나 이상의 숫자(예: 0, 99, 101 등)를 가질 수 있습니다.
별도의 제외 항목을 사용하는 대신 포함하는 동안 제외하기 위해 부정 연산자를 사용할 수 있습니다:
[source,yaml]
branches: 5.!({0..5}).x
중첩된 중괄호 표현식을 사용하여 두 가지 일치 분기를 지정할 수 있습니다. 초기 부 버전을 제외하면서 여전히 앞으로 나올 버전과 일치시키는 방법은 다음과 같습니다.
[source,yaml]
branches: '5.{{6..9},{1..9}+({0..9})}.x'
패턴을 너무 복잡하게 만들지 않도록 주의해야 합니다. 필요한 모든 일치를 수행할 수 있는 패턴을 만들 수 있을지 모르지만 읽고 유지 관리하기가 점점 더 어려워집니다. 그렇기 때문에 사이트의 참조 이름을 편안하게 일치시키는 데 필요한 만큼 포함 및 제외 패턴을 사용하는 것이 좋습니다.
모든 마일스톤 버전이 제거된 매우 특정한 버전 번호 범위를 일치시키는 전체 예제로 마무리하겠습니다.
[source,yaml]
tags:

'{5,6}.+({0..9}).+({0..9}){,-*}'
'!5.{0..5}.*'
'!*-M+({0..9})'



== Configure Your Site - Git Keys

git 아래에 구성된 플레이북 키는 Antora에서 사용하는 git 클라이언트의 동작을 제어합니다.
=== git 키
git 키는 git 자격 증명, 자동 URL 접미사 및 플러그인과 같은 모든 git 관련 플레이북 키를 보유합니다.
.예제 1. antora-playbook.yml
[source,yaml]
git:
fetch_concurrency: 3
ensure_git_suffix: false
credentials:
path: ./.git-credentials
plugins:
credential_manager: ./system-git-credential-manager.js
read_concurrency: 5
<1> 선택적 git 카테고리 키
<2> 동시 가져오기 작업 수를 제한하는 선택적 fetch_concurrency 키
<3> 선택적 ensure_git_suffix 키
<4> 선택적 credentials 카테고리 키
<5> 선택적 자격 증명의 위치를 지정하는 path 키; contents 키와 상호 배타적
<6> 선택적 plugins 카테고리 키
<7> 선택적 credential_manager 키
<8> 동시 읽기 작업 수를 제한하는 선택적 read_concurrency 키(저장소를 가져온 후)
git 카테고리 키와 이 키가 받아들이는 하위 키는 모두 선택 사항입니다. git 키가 플레이북에 없으면 Antora는 git 클라이언트의 기본 구성을 사용하는 것으로 대체됩니다.

=== 사용 가능한 git 키
[cols="1,3,1", options="header"]
|===
| Git 키 | 설명 | 필수
| credentials.contents
| git 자격 증명 저장소에서 사용하는 형식과 일치하는 git 자격 증명 데이터를 받아들입니다.
| 아니오
| credentials.path
| git 자격 증명 저장소에서 사용하는 형식과 일치하는 git 자격 증명 파일의 파일 시스템 경로를 받아들입니다.
| 아니오
| fetch_concurrency
| 기본값은 1입니다. 양의 정수 또는 0을 받아들입니다. 0이 아닌 경우 동시 가져오기 작업 수를 지정된 값으로 제한합니다. 0인 경우 동시 가져오기 작업 수를 제한하지 않습니다.
| 아니오
| plugins.credential_manager
| 사용자 정의 자격 증명 관리자를 제공하는 코드의 위치를 지정하는 요청을 받아들입니다.
| 아니오
| plugins.http
| 사용자 정의 HTTP 요청 처리기를 제공하는 코드의 위치를 지정하는 요청을 받아들입니다.
| 아니오
| ensure_git_suffix
| 기본값은 true입니다. true인 경우 이 키는 콘텐츠 소스 저장소 URL에 .git이 없으면 자동으로 추가하도록 git 클라이언트에 지시합니다.
| 아니오
| read_concurrency
| 기본값은 0입니다(사실상 제한 없음). 양의 정수 또는 0을 받아들입니다. 0이 아닌 경우 읽기 작업 수를 지정된 값으로 제한합니다. 0인 경우 읽기 작업 수를 제한하지 않습니다.
| 아니오
|===



== Configure Your Site - Git Keys - Git Repository URL Suffix

ensure_git_suffix 키는 원격 콘텐츠 소스의 URL에 .git 확장자가 없는 경우 Antora가 이를 추가해야 하는지 여부를 알려줍니다. GitHub 또는 GitLab을 사용하는 경우 기본값으로 충분하므로 플레이북에서 이 키를 정의할 필요가 없습니다. 그러나 Team Foundation Server(TFS) 또는 Azure DevOps를 사용하는 경우 계속 읽어보세요.
=== 기본 git 저장소 URL 접미사
기본적으로 ensure_git_suffix 키에는 true 값이 할당됩니다. ensure_git_suffix가 true이면 Antora는 접미사가 누락된 모든 원격 콘텐츠 소스 저장소 URL에 .git을 자동으로 추가하도록 git 클라이언트에 지시합니다.
일부 git 서비스는 URL에 .git 확장자가 포함된 경우 URL을 인식하지 않습니다. 따라서 이 동작을 구성할 수 있어야 합니다.
=== ensure_git_suffix 키
선택적 ensure_git_suffix 키는 플레이북의 git 키 아래에 설정됩니다. 이 키는 부울 값을 받아들입니다.

false




Antora는 .git 접미사가 누락된 원격 콘텐츠 소스의 URL에 .git을 추가하지 않습니다.

true




기본값입니다. Antora는 .git 접미사가 누락된 모든 원격 콘텐츠 소스 저장소 URL에 .git을 추가합니다.
Team Foundation Server(TFS) 또는 Azure DevOps를 사용하는 경우 콘텐츠 소스 저장소를 복제하지 못하면 ensure_git_suffix를 false로 설정해야 할 수 있습니다.
.예제 1. antora-playbook.yml
[source,yaml]
git:
ensure_git_suffix: false



== Configure Your Site - Git Keys - Git Fetch Concurrency Limit

fetch_concurrency 키는 원격 git 저장소에서 콘텐츠를 검색할 때 Antora가 허용하는 동시 가져오기 작업 수를 알려줍니다. 이는 fetch와 clone 작업 모두를 포함합니다(clone이 먼저 fetch를 수행하기 때문). 동시 작업 수가 이 제한에 도달하면 Antora는 대기열에 다른 작업을 추가하기 전에 활성 작업이 완료될 때까지 기다립니다.
Antora가 한 번에 몇 개의 저장소에서 읽어오는지 제어하는 방법을 알아보려면 Git 읽기 동시성 제한을 참조하세요.
=== 기본 가져오기 동시성
기본적으로 Antora는 가져오기 동시성을 1로 제한하므로 한 번에 하나의 저장소에서만 가져옵니다. Antora가 모든 저장소를 한 번에 가져오도록 허용하려면 이 값을 0으로 변경할 수 있습니다.
많은 저장소를 한 번에 가져오면 네트워크에 큰 부담이 될 수 있습니다. 또한 일부 git 호스팅 서비스는 특히 익명 요청(속도 제한이라고 함)에 대해 동시 요청에 할당량을 적용합니다. 이로 인해 git 클라이언트가 git 서버에 의해 제한(또는 심지어 차단)될 수 있습니다. 최악의 경우 서버가 네트워크 연결에서 중단될 수 있으며, 이는 Antora의 실패를 초래합니다. 이러한 상황을 완화하기 위해 Antora에서는 가져오기 동시성 제한을 조정할 수 있습니다.
=== fetch_concurrency 키
선택적 fetch_concurrency 키는 플레이북의 git 카테고리 아래에 설정됩니다. 이 키는 양의 정수 값 또는 제한 없음을 나타내는 0을 받아들입니다.
.예제 1. antora-playbook.yml
[source,yaml]
git:
fetch_concurrency: 5
fetch_concurrency 키의 목적은 콘텐츠 집계기에 의해 한 번에 만들어지는 네트워크 연결 수를 제어(즉, 제한)할 수 있도록 하여 git 호스트에서 시행하는 속도 제한 문제를 우회하는 것입니다. GitHub의 경우와 같이 git 서버가 일시 중지된 연결을 재설정하는 데 매우 적극적인 경우 이 값을 1로 설정하는 것이 좋습니다.
동시 작업 수를 제한하면 가져오기 작업이 완료되는 데 걸리는 시간이 줄어드는 것을 알 수 있습니다. 이는 아마도 git 서버가 요청을 제한하지 않기 때문일 것입니다. 그러나 직렬로 저장소를 가져오면 전체적으로 저장소를 가져오는 데 걸리는 시간이 늘어날 수도 있습니다. 사이트에 가장 적합한 설정을 찾으려면 이 값을 실험해 보아야 합니다.
대화형 터미널의 경우 가져오기 동시성을 제한하면 터미널에 한 번에 나타나는 진행률 표시줄 수도 제한됩니다.

=== 저장소 스캔과의 관계
저장소가 가져와졌거나 가져오기가 필요하지 않은 경우 Antora는 저장소를 스캔할 풀에 넣습니다. 기본적으로 Antora는 동시에 스캔되는 저장소 수에 제한을 두지 않습니다. Git 읽기 동시성 제한 키를 사용하여 이 동작을 제어할 수 있습니다. Antora는 모든 가져오기(또는 복제) 작업이 완료된 후에만 저장소에서 읽기를 시작합니다. 제한은 가져오기 단계에만 적용됩니다.
Antora는 이전에 저장소를 복제하지 않았거나 runtime.fetch 키가 설정된 경우 원격 저장소에서 콘텐츠를 가져옵니다.



== Configure Your Site - Git Keys - Git Read Concurrency Limit

Git 가져오기 동시성 제한과 유사하게 read_concurrency 키는 Antora에게 한 번에 몇 개의 콘텐츠 저장소(로컬 또는 관리)에서 읽어야 하는지 알려줍니다. 이 키는 사실상 한 번에 메모리에 로드되는 git 인덱스 수를 제어합니다(git 인덱스는 git 저장소의 파일에 대한 백업 저장소).
Antora는 해당 저장소에 대한 모든 가져오기/복제 작업이 완료된 후에만 저장소를 읽습니다. 따라서 가져오기와 읽기는 별개의 단계입니다.
=== 기본 읽기 동시성
기본적으로 Antora는 읽기 동시성을 제한하지 않습니다(값 0). 즉, 파일을 스캔하고 수집할 때 모든 저장소를 한 번에 메모리에 로드합니다. 많은 대용량 저장소를 한 번에 로드하면 많은 메모리를 소모할 수 있습니다. 이러한 상황을 완화하기 위해 Antora에서는 읽기 동시성 제한을 조정할 수 있습니다.
읽기 동시성은 가져오기 동시성이나 네트워크 트래픽에 영향을 미치지 않습니다.
=== read_concurrency 키
선택적 read_concurrency 키는 플레이북의 git 카테고리 아래에 설정됩니다. 이 키는 양의 정수 값 또는 제한 없음을 나타내는 0을 받아들입니다.
.예제 1. antora-playbook.yml
[source,yaml]
git:
read_concurrency: 4
많은 저장소로 작업할 때 최적 값은 2에서 5 사이입니다.
read_concurrency 키의 목적은 콘텐츠 저장소에서 파일을 읽을 때 사용되는 메모리 양을 제어할 수 있도록 하는 것입니다. git 인덱스가 메모리에 로드되면 Antora는 각 참조의 트리를 읽어 파일을 콘텐츠 카탈로그의 전구체로 수집하는 데 무제한 동시성을 사용합니다(콘텐츠 카탈로그 생성은 후속 단계).
=== 메모리 사용량과의 관계
잔류 메모리는 수집된 모든 콘텐츠 파일의 크기와 같겠지만 해당 파일을 포함하는 git 인덱스는 상당히 더 클 수 있습니다. 이는 특히 문서가 소프트웨어 프로젝트의 소스 파일과 함께 위치하는 경우에 해당합니다. Antora는 파일의 일부만 가져오는 경우에도 git 인덱스를 로드해야 합니다.
동시 작업 수를 제한하면 콘텐츠 집계기가 완료되는 데 걸리는 시간이 줄어드는 것을 알 수 있습니다. 이는 아마도 Antora가 컨텍스트 전환을 덜 해야 하기 때문일 것입니다. 사이트에 가장 적합한 설정을 찾으려면 이 값을 실험해 보아야 합니다.



== Configure Your Site - Git Keys - Git Credentials Path and Contents

Antora가 비공개 저장소에 액세스하려면 이러한 비공개 저장소에 액세스하기 위한 인증 자격 증명을 제공해야 합니다. 기본적으로 Antora는 기본 git 자격 증명 저장소에서 이러한 인증 자격 증명을 찾습니다. 대체 git 자격 증명 저장소 위치를 사용하거나 기본 저장소에 자격 증명을 채우지 않은 경우 credentials.path 또는 credentials.contents 키를 사용하여 Antora에 자격 증명을 전달할 수 있습니다.
=== 기본 git 자격 증명 저장소 및 경로
git 호스트가 비공개 콘텐츠 소스 저장소에 대한 인증을 요청하면 Antora의 내장 자격 증명 관리자는 기본 git 자격 증명 저장소에서 자동으로 자격 증명을 확인합니다. git 자격 증명 저장소의 기본 경로는 $HOME/.git-credentials이며, 이전 위치가 존재하지 않는 경우 $XDG_CONFIG_HOME/git/credentials입니다.
=== credentials 키
credentials 키는 git 키 아래에 설정됩니다.
.예제 1. antora-playbook.adoc
[source,yaml]
git:
credentials:
<1> 부모 키 git을 입력한 다음 콜론(:)을 입력하고 Enter 키를 누릅니다.
<2> credentials 키는 git의 하위 항목입니다. 키의 이름 credentials를 입력한 다음 콜론(:)을 입력하고 Enter 키를 누릅니다.
credentials 키는 git 자격 증명 파일의 대체 파일 시스템 경로(path) 또는 git 자격 증명 파일의 내용(contents)을 지정하는 키-값 쌍을 받아들입니다. contents 키와 path 키는 상호 배타적입니다. 즉, 플레이북에서 둘 중 하나만 설정할 수 있습니다.
=== path 키
기본 경로의 자격 증명 저장소를 사용하는 대신 Antora에 다른 위치에서 파일을 찾도록 지시할 수 있습니다. path 키는 Antora가 git 자격 증명 저장소를 찾을 수 있는 파일 시스템 경로를 지정합니다. 이 경로는 플레이북의 git과 credentials 키 아래에 구성됩니다. path 키는 절대 파일 시스템 경로 또는 플레이북 파일을 기준으로 하는 상대 파일 시스템 경로를 받아들입니다.
.예제 2. antora-playbook.yml
[source,yaml]
git:
credentials:
path: /home/user/.git-credentials
<1> path 키는 credentials 아래에 중첩되어 있습니다.
<2> 키 이름 path를 입력한 다음 콜론(:)을 입력합니다. 콜론 뒤에 공백을 입력한 다음 git 자격 증명 저장소의 파일 시스템 경로를 입력합니다.
--git-credentials-path CLI 옵션이나 GIT_CREDENTIALS_PATH 환경 변수를 사용하여 대체 git 자격 증명 경로를 지정할 수도 있습니다.
=== contents 키
contents 키를 사용하는 대신 기본 자격 증명 저장소에 자격 증명을 채우거나 GIT_CREDENTIALS 환경 변수를 사용하여 전달하는 것이 좋습니다. 이 키는 실제로 자동 생성된 플레이북 파일을 위한 것입니다.
contents 키는 contents 키를 사용하여 하나의 자격 증명 세트 또는 하나의 git 호스트에 대한 자격 증명을 받아들입니다. 둘 이상의 자격 증명 세트를 지정하거나 서로 다른 git 호스트에서 비공개 저장소에 액세스하려면 자격 증명 저장소를 대화형으로 채우거나 직접 채워야 합니다. GIT_CREDENTIALS 환경 변수를 사용하여 둘 이상의 자격 증명 세트를 전달할 수도 있습니다.
contents 키는 플레이북의 git.credentials 키 아래에 구성됩니다. contents의 값은 비공개 콘텐츠 소스 저장소를 제공하는 git 호스트에 따라 달라집니다. 일반적으로 값은 https://<credentials>@<hostname> 형식을 취합니다. 여기서 <credentials>는 환경 변수($ENV_VARIABLE), 사용자 이름/비밀번호 쌍(username:password) 또는 액세스 토큰(token)을 참조하는 자리 표시자입니다. <hostname>은 git 서버의 주소입니다(예: gitlab.com).
플레이북에 git 호스트 사용자 이름/비밀번호 쌍이나 액세스 토큰을 직접 입력하는 것은 권장하지 않습니다! 플레이북을 원격 저장소나 CI 서버로 푸시하여 실수로 노출할 수 있습니다.
아래 예제에서 호스트 GitHub가 액세스 토큰을 찾을 것으로 예상하는 위치에 GITHUB_TOKEN이라는 환경 변수에 대한 참조가 배치됩니다. 자격 증명 구조와 위치는 git 호스트에 따라 다릅니다. 예를 들어 GitHub에서는 토큰 끝에 콜론(:)을 배치해야 합니다.
.예제 3. antora-playbook.yml
[source,yaml]
git:
credentials:
contents: https://$GITHUB_TOKEN:@github.com
안타깝게도 Antora는 아직 플레이북 파일에 위치한 환경 변수 확인을 지원하지 않습니다. 그러나 다음 스크립트를 사용하여 Antora를 호출하기 전에 환경 변수 참조를 값으로 대체하는 방식으로 이 동작을 에뮬레이션할 수 있습니다:
[source,bash]
sed -i s/$GITHUB_TOKEN/$GITHUB_TOKEN/ antora-playbook.yml &&
antora antora-playbook.yml
이러한 해결 방법에도 불구하고 contents 키를 사용하는 대신 git 자격 증명 저장소를 채우거나 GIT_CREDENTIALS 환경 변수를 사용하여 자격 증명을 전달하는 것이 좋습니다.



== Configure Your Site - Git Keys - Git Plugins

plugins 카테고리 키는 git 클라이언트에 로드할 플러그인의 위치를 지정하는 데 사용됩니다. 플러그인 세트는 고정되어 있으며 미리 결정된 이름을 사용하여 참조됩니다. 이러한 플러그인은 Antora에서 사용하는 git 클라이언트의 작동 방식에 대한 어느 정도의 제어 기능을 제공합니다. 플러그인 세트는 시간이 지남에 따라 증가할 수 있습니다.
=== plugins 키
plugins 키는 git 카테고리 키 아래에 설정됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
git:
plugins:
<1> 부모 키 git을 입력한 다음 콜론(:)을 입력하고 Enter 키를 누릅니다.
<2> plugins 카테고리 키는 git 카테고리 키 아래에 중첩되어 있습니다. 키의 이름 plugins를 입력한 다음 콜론(:)을 입력하고 Enter 키를 누릅니다.
plugins 키는 git 클라이언트에 로드할 미리 결정된 플러그인의 위치를 지정하는 맵(즉, 키-값 쌍)을 받아들입니다.
=== credential_manager 키
credential_manager 키는 git.plugins 카테고리 키의 하위 항목입니다. git 클라이언트가 사용할 사용자 정의 자격 증명 관리자를 지정하는 방법을 제공합니다. 자격 증명 관리자 플러그인은 git 클라이언트가 인증이 필요한 저장소와 상호 작용할 때마다 호출됩니다.
.예제 2. antora-playbook.yml
[source,yaml]
git:
plugins:
credential_manager: ./my-git-credential-manager-plugin.js
<1> credential_manager 카테고리 키는 git.plugins 카테고리 키 아래에 중첩되어 있습니다.
<2> 키 이름 credential_manager를 입력한 다음 콜론(:)을 입력합니다. 콜론 뒤에 공백을 입력한 다음 자격 증명 관리자 플러그인의 코드 위치를 식별하는 요청을 입력합니다.
credential_manager 키가 설정되면 Antora는 요청을 사용하여 플러그인의 코드를 찾아 로드하고 git 클라이언트에 등록합니다. 자격 증명 관리자 플러그인의 API와 작동 방식은 사용자 정의 자격 증명 관리자 구성에 설명되어 있습니다.
=== http 키
http 키는 git.plugins 카테고리 키의 하위 항목입니다. git 클라이언트가 사용할 사용자 정의 HTTP 요청 처리기를 지정하는 방법을 제공합니다. http 플러그인은 git 클라이언트가 git 저장소와 통신할 때마다(모두 HTTP를 통해 수행됨) 호출됩니다.
.예제 3. antora-playbook.yml
[source,yaml]
git:
plugins:
http: ./my-git-http-plugin.js
<1> http 카테고리 키는 git.plugins 카테고리 키 아래에 중첩되어 있습니다.
<2> 키 이름 http를 입력한 다음 콜론(:)을 입력합니다. 콜론 뒤에 공백을 입력한 다음 http 플러그인의 코드 위치를 식별하는 요청을 입력합니다.
http 키가 설정되면 Antora는 요청을 사용하여 플러그인의 코드를 찾아 로드하고 git 클라이언트에 등록합니다.
http 플러그인의 API는 isomorphic-git 문서에서 다룹니다. url, method, headers 및 body를 매개변수로 받아들이고 url, method, headers, body, statusCode 및 statusMessage 속성이 있는 객체로 요청의 결과를 반환하는 request라는 비동기 함수를 내보내는 것이 핵심입니다. 해당 함수에서 자신의 HTTP 클라이언트를 사용하여 요청을 이행할 수 있습니다.


== Configure Your Site - AsciiDoc Keys

asciidoc 아래에 구성된 플레이북 키는 AsciiDoc 프로세서에 속성, Asciidoctor 확장 및 추가 동작을 적용합니다.
=== asciidoc 키
asciidoc 키는 사이트의 모든 페이지에 할당되고 사용 가능하게 되는 속성을 지정합니다. 또한 Asciidoctor 확장을 등록하고 추가 AsciiDoc 구문 오류 보고 기능을 활성화합니다.
.예제 1. antora-playbook.yml
[source,yaml]
----
asciidoc:
sourcemap: true
attributes:
table-caption: ~
extensions:

./lib/custom-block.js


<1> 선택적 asciidoc 키
<2> 선택적 sourcemap 키
<3> 선택적 attributes 키
<4> 정의된 기본 제공 AsciiDoc 속성
<5> 선택적 extensions 키
<6> 로컬 확장 스크립트의 경로
----

=== 사용 가능한 AsciiDoc 키
[cols="1,3,1", options="header"]
|===
| AsciiDoc 키 | 설명 | 필수
| attributes
| 사이트의 모든 페이지에 적용되고 사용 가능하게 되는 기본 제공, 사용자 정의 및 페이지 속성의 맵을 받아들입니다.
| 아니오
| extensions
| Asciidoctor 확장 목록을 받아들입니다. 확장의 기능에 따라 확장은 전역적으로 등록되거나 페이지의 AsciiDoc 프로세서 인스턴스에 범위가 지정됩니다.
| 아니오
| sourcemap
| true일 때 Antora의 로거와 Asciidoctor 확장에 AsciiDoc 블록에 대한 추가 파일 및 행 번호 정보를 제공합니다. 기본값은 false입니다.
| 아니오
|===

== Configure Your Site - AsciiDoc Keys - Assign Attributes to a Site

사이트의 플레이북 파일에 선언하여 사이트의 모든 페이지에 속성을 적용할 수 있습니다.
=== 사이트 속성
플레이북에 선언된 속성을 사이트 속성이라고 합니다. 이러한 속성은 사이트의 모든 페이지에 설정되고 사용할 수 있습니다(설정되지 않은 경우 사용할 수 없음). 사이트의 페이지는 Antora의 단일 실행을 위해 플레이북에 지정된 콘텐츠 소스에서 Antora가 찾은 모든 페이지로 정의됩니다. 사이트 속성은 기본 제공, 사용자 정의 및 페이지 속성일 수 있습니다. 속성 우선 순위 규칙은 사이트 속성을 보다 세분화된 수준에서 재정의할 수 있는지 여부를 결정합니다.
플레이북에서 사이트 전체에 선언되는 것 외에도 속성은 antora.yml 파일의 구성 요소 버전별로 정의되거나 페이지의 헤더에서 직접 정의될 수 있습니다. 그러나 사이트의 플레이북에서 속성이 하드 설정되거나 하드 설정 해제된 경우 구성 요소 버전 설명자 또는 페이지에서 동일한 속성의 후속 선언을 재정의합니다. 사이트 속성은 CLI에서도 구성할 수 있습니다.
=== 플레이북 파일 vs 구성 요소 버전 설명자 파일
속성은 플레이북 파일과 구성 요소 버전 설명자 파일 모두에서 동일한 구조와 구문을 사용하여 선언됩니다.
플레이북은 사이트, 콘텐츠 소스 및 UI URL을 구성하는 곳입니다. 플레이북 파일의 파일 이름에는 일반적으로 플레이북이라는 단어가 포함됩니다(예: antora-playbook.yml 또는 local-antora-playbook.yml).
구성 요소 버전 설명자는 구성 요소 버전의 이름, 버전, 메타데이터, 속성 및 탐색 목록을 구성하는 곳입니다. 구성 요소 버전 설명자의 파일 이름은 항상 antora.yml입니다.
=== attributes 키
사이트 속성은 플레이북의 attributes 키 아래에 매핑됩니다. attributes 키는 asciidoc 키 아래에 설정되어야 합니다.
.예제 1. antora-playbook.yml
[source,yaml]
asciidoc:
attributes:
hide-uri-scheme: ''
page-team: Coco B
table-caption: ~
listing-caption: Snippet@
사이트 속성은 속성 우선 순위 규칙에 따라 사이트의 모든 페이지에 적용되고 사용할 수 있습니다.
=== 플레이북에서 속성 설정
각 사이트 속성은 attributes 키 아래에 키-값 쌍으로 자체 줄에 입력됩니다.
.예제 2. 플레이북에서 속성 선언
[source,yaml]
asciidoc:
attributes:
listing-caption: Snippet
hide-uri-scheme: ''
page-team: Coco B
db: graphical-peaks-pack.db
<1> asciidoc 키를 입력하고 콜론(:)을 입력한 다음 Enter 키를 누릅니다.
<2> attributes 키는 asciidoc 키 아래에 중첩되어 있습니다. attributes를 입력하고 콜론(:)을 입력한 다음 Enter 키를 누릅니다.
<3> 사이트 속성은 attributes 키 아래에 중첩되어 있습니다. 속성의 이름을 입력하고 콜론(:)을 입력합니다. 콜론 뒤에 공백을 한 번 누른 다음 속성의 값을 입력합니다.
<4> 명시적 값을 지정하지 않고 속성을 설정하려면 값 부분에 연속된 작은따옴표 두 개('')를 입력하여 빈 문자열을 할당합니다. 특정 기본 제공 속성의 경우 빈 값은 기본값과 같지만 속성에 따라 다릅니다. 이 경우 부울 값 true를 사용하는 것이 효과가 있지만 AsciiDoc의 속성 값은 문자열이므로 문자열 값 'true'로 강제 변환될 가능성이 높습니다.
<5> 사용자 정의 페이지 속성을 선언하려면 page-와 속성 이름을 입력한 다음 콜론(:)을 입력합니다. 콜론 뒤에 공백을 한 번 누른 다음 속성의 값을 입력합니다.
<6> 이 사용자 정의 속성은 이전 세 속성과 마찬가지로 하드 설정됩니다.
예제 2의 속성은 모두 하드 설정됩니다. 하드 설정된 사이트 속성은 구성 요소 버전 설명자나 페이지에서 재정의할 수 없습니다. 기본적으로 속성에 속성을 설정 해제하기 위해 예약된 값(즉, false 또는 ~)이 할당되지 않고 수정자(즉, @)로 끝나지 않으면 하드 설정됩니다. 구성 요소 버전 또는 페이지에서 사이트 속성을 수정하거나 설정 해제할 수 있도록 하려면 사이트 속성을 소프트 설정해야 합니다.
플레이북에 설정된 속성은 사이트 전체에 적용되므로 사이트의 모든 페이지에서 사용할 수 있습니다. page-team과 db와 같은 사용자 정의 속성의 값은 AsciiDoc 속성 참조 구문(예: {page-team}, {db})을 사용하여 페이지에 표시할 수 있습니다. 사이트 속성은 다른 사이트 속성, 구성 요소 버전 속성 또는 페이지 속성의 값에서도 참조할 수 있습니다.
=== 소프트 설정 속성
소프트 설정된 사이트 속성은 구성 요소 버전 설명자나 페이지에서 재정의할 수 있습니다. 속성은 값 끝에 @ 수정자를 추가하여 플레이북에서 소프트 설정됩니다.
.예제 3. 속성에 소프트 설정 우선 순위 할당
[source,yaml]
asciidoc:
attributes:
page-team: Coco B@
hide-uri-scheme: '@'
<1> 명시적 값이 할당된 속성을 소프트 설정하려면 값 끝에 @ 수정자를 추가합니다.
<2> 기본 제공 속성의 기본값을 소프트 설정하고 할당하거나 부울 속성의 경우 빈 문자열 값을 할당하려면 여는 작은따옴표를 입력하고 @ 수정자를 입력한 다음 닫는 작은따옴표(')를 입력합니다.
예제 3의 사이트 속성은 소프트 설정되므로 구성 요소 버전 설명자나 페이지에서 값을 수정하거나 설정 해제할 수 있습니다.
=== 다른 속성의 값 삽입
플레이북 앞부분이나 CLI에서 설정된 모든 사이트 속성의 값은 AsciiDoc 속성 참조(예: {page-team})를 사용하여 사이트 속성의 값에 삽입할 수 있습니다.
.예제 4. 다른 사이트 속성의 값을 참조하는 사이트 속성
[source,yaml]
asciidoc:
attributes:
page-team: Coco B@
db: graphical-peaks-pack.db
test-server: http://localhost:9090/{db}
사이트 속성은 구성 요소 버전 속성 또는 페이지 속성의 값에서도 참조할 수 있습니다.
속성 참조 대체를 방지하려면 참조 앞에 백슬래시를 삽입합니다(예: \{not-substituted}). 이 경우 속성 참조는 대체되지 않고 백슬래시는 생략됩니다.
=== 플레이북에서 속성 설정 해제
사이트 속성은 플레이북에서 설정 해제할 수도 있습니다. 사이트 속성은 예약된 물결 기호(~) 값이 할당될 때 하드 설정 해제됩니다. 각 사이트 속성은 attributes 키 아래에 키-값 쌍으로 자체 줄에 입력됩니다.
.예제 5. 플레이북에서 사이트 속성 하드 설정 해제
[source,yaml]
asciidoc:
attributes:
figure-caption: ~
hide-uri-scheme: ~
<1> 속성을 하드 설정 해제하려면 물결 기호(~)를 할당합니다. ~는 YAML에서 nil의 단축어이며, 사이트 속성을 하드 설정 해제하는 예약된 값입니다.
<2> 부울 속성은 물결 기호(~)가 할당될 때도 하드 설정 해제됩니다.
하드 설정 해제된 사이트 속성은 구성 요소 버전 설명자나 페이지에서 재정의할 수 없습니다. 사이트 속성이 하드 설정 해제되면 해당 동작이 꺼지고 사이트의 페이지에서 사용할 수 없습니다.
=== 소프트 설정 해제 속성
소프트 설정 해제된 사이트 속성은 구성 요소 버전 설명자나 페이지에서 재정의할 수 있습니다. 속성은 예약된 값 false를 할당하여 플레이북에서 소프트 설정 해제됩니다.
.예제 6. 속성에 소프트 설정 해제 우선 순위 할당
[source,yaml]

asciidoc:
attributes:
figure-caption: false
hide-uri-scheme: false
<1> 속성을 소프트 설정 해제하려면 값 false를 할당합니다.
<2> 부울 속성도 false가 할당되면 소프트 설정 해제됩니다.
예제 6의 사이트 속성은 소프트 설정 해제되므로 구성 요소 버전 설명자나 페이지에서 재설정할 수 있습니다.

=== 우선 순위 규칙

Antora는 먼저 사이트의 플레이북에 할당된 속성의 우선 순위를 고려합니다. 하드 설정되고 하드 설정 해제된 사이트 속성은 구성 요소 버전 설명자 파일이나 페이지에서 변경할 수 없습니다. 그러나 소프트 설정 및 설정 해제된 사이트 속성은 구성 요소 버전 설명자나 페이지에서 재정의할 수 있습니다.
뒤에 오는 @ 수정자 없이 문자열 값을 사용하여 사이트 속성을 하드 설정하면(예: value 또는 '') 구성 요소 버전 설명자나 페이지에서 속성을 변경하거나 설정 해제할 수 없습니다.
뒤에 오는 @ 수정자와 함께 문자열 값을 사용하여 사이트 속성을 소프트 설정하면(예: value@ 또는 '@') 구성 요소 버전 설명자나 페이지에서 속성을 변경하거나 설정 해제할 수 있습니다.
물결 기호(~)를 사용하여 사이트 속성을 하드 설정 해제하면 구성 요소 버전 설명자나 페이지에서 속성을 설정할 수 없습니다.
false 값을 사용하여 사이트 속성을 소프트 설정 해제하면 구성 요소 버전 설명자나 페이지에서 속성을 설정할 수 있습니다.
사이트 속성이 구성 요소 버전 속성 및 페이지 속성과 어떻게 상호 작용하는지 자세히 알아보려면 구성 요소 버전에 속성 할당 및 Antora의 AsciiDoc 속성을 참조하세요.
=== 내재적 사이트 속성
Antora는 플레이북 파일의 일부 키에서 내재적 사이트 및 페이지 속성을 정의합니다. 예를 들어 Antora는 기본 제공 속성 site-title을 설정하고 site.title 키에 지정된 값을 할당합니다. Antora는 또한 sectanchors와 같은 일부 기본 제공 AsciiDoc 속성을 기본적으로 설정합니다. 자세한 내용은 사이트 및 구성 속성과 내재적 페이지 속성을 참조하세요.
일부 기본 제공 AsciiDoc 속성은 Antora 환경에서 적용되지 않습니다. 이러한 속성에는 data-uri, allow-uri-read, docinfo, linkcss, noheader, nofooter, webfonts 및 outfilesuffix가 포함됩니다. 이러한 속성을 설정하면 효과가 없거나 Antora가 오작동할 수 있습니다. imagesdir와 같은 다른 속성은 Antora에 의해 자동으로 설정되며 재정의할 수 없습니다.


== Configure Your Site - AsciiDoc Keys - Asciidoctor Extensions

asciidoc 키는 Asciidoctor 확장을 등록하는 데 사용할 수 있습니다.
=== 확장 코드 설치
플레이북에 확장을 등록하기 전에 확장 코드를 설치해야 합니다. 전역적으로 설치하거나 프로젝트의 종속성으로 선언하거나 플레이북 프로젝트에 확장 스크립트를 추가할 수 있습니다.
=== extensions 키
Asciidoctor 확장은 extensions 키를 사용하여 등록됩니다. extensions 키는 노드 모듈 이름(즉, npm 패키지 이름)과 상대 또는 절대 파일 시스템 경로의 목록을 받아들입니다.
Asciidoctor 확장을 등록할 때 중첩된 키 asciidoc.extensions를 사용하고 있는지 확인하세요. antora.extensions는 아닙니다. 후자의 키는 다른 확장 기능을 사용하는 Antora 확장을 등록하는 데 사용됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
asciidoc:
extensions:

name-of-node-module
./path/to/extension


.js와 같은 파일 확장자로 끝나는 Node.js 모듈(예: npmjs.com에서 설치한 패키지)을 요구하려고 하는 경우 뒤에 슬래시를 추가해야 합니다. 예를 들어 Node.js 모듈 highlight.js는 highlight.js/로 작성되어야 합니다. 이 접미사는 Antora에게 요청을 로컬 파일이 아닌 모듈의 이름으로 해석하도록 지시합니다. 이 접미사가 없으면 Antora는 요청이 로컬 파일이라고 가정합니다. 로컬 파일이 아닌 경우 Cannot find module 오류 메시지가 발생할 수 있습니다. 요청이 이미 로컬 파일인 경우 접미사는 필요하지 않습니다.
=== 전역 Asciidoctor 확장
전역 확장은 페이지가 변환되기 전에 한 번 등록됩니다. 이러한 확장은 Antora가 Asciidoctor를 사용하여 변환하는 모든 문서(탐색 파일 포함)에서 공유됩니다. 전역 확장은 요구될 때 함수를 내보내는 노드 모듈 또는 스크립트입니다. Antora는 이 함수를 Asciidoctor의 정적 확장 레지스트리의 register 메서드에 직접 전달합니다.
전역 확장을 등록하려면 extensions 키에 이름(요구 경로에 있는 노드 모듈인 경우) 또는 경로(로컬 스크립트인 경우)를 참조하기만 하면 됩니다.
.예제 2. 노드 모듈에서 제공하는 전역 확장 등록
[source,yaml]
asciidoc:
extensions:

asciidoctor-emoji-macro


이 경우 asciidoctor-emoji-macro는 설치된 노드 모듈의 이름이므로 요구 경로에서 사용할 수 있습니다(플레이북 프로젝트의 node_modules 디렉터리 또는 전역 node_modules 디렉터리).
.예제 3. 로컬 스크립트에서 전역 확장 등록
[source,yaml]
asciidoc:
extensions:

./lib/shout-block


이 경우 확장은 플레이북 파일을 기준으로 lib/shout-block.js 경로에 있는 스크립트입니다.
여러 전역 확장을 등록하는 방법을 보여주는 예제는 다음과 같습니다:
.예제 4. 여러 전역 확장 등록
[source,yaml]
asciidoc:
extensions:

asciidoctor-emoji-macro
./lib/shout-block


=== 범위가 지정된 Asciidoctor 확장
확장을 전역적으로 요구하는 대신 AsciiDoc 프로세서의 인스턴스별로 확장을 등록하고 싶을 수 있습니다. 이 접근 방식의 이점은 확장이 Antora 수명 주기에 연결할 수 있다는 것입니다. 또 다른 차이점은 범위가 지정된 확장은 탐색 파일이 아닌 페이지에 대해서만 등록되고 사용된다는 것입니다.
범위가 지정된 확장을 등록하려면 확장이 이 사용 모드를 지원해야 합니다. 구체적으로 확장은 자체 등록하는 확장 레지스트리를 받아들이는 register 함수를 내보내야 합니다. 이 함수는 범위가 지정된(프로세서별) 확장 레지스트리와 컨텍스트 객체와 함께 호출됩니다. 컨텍스트 객체에는 현재 파일, 콘텐츠 카탈로그 및 플레이북의 AsciiDoc 구성 객체가 포함됩니다.
범위가 지정된 확장에 대한 register 함수의 예제는 다음과 같습니다:
.예제 5. 범위가 지정된 Asciidoctor 확장 register 함수
[source,js]
module.exports.register = function (registry, context) {
registry.block('shout', createShoutBlock(context))
}
범위가 지정된 확장은 전역 확장과 정확히 동일한 방식으로 플레이북에 등록됩니다.
.예제 6. 요구 경로에서 범위가 지정된 확장 등록
[source,yaml]
asciidoc:
extensions:

asciidoctor-kroki


.예제 7. 로컬 스크립트에서 범위가 지정된 확장 등록
[source,yaml]
asciidoc:
extensions:

./lib/equation-macro


주요 차이점은 확장이 register 함수를 내보내는 경우 전역적으로 등록되는 대신 프로세서 인스턴스에 범위가 지정된다는 것입니다.
=== 확장 사전 로드
플레이북을 사용하여 확장을 등록하는 대신 -r 또는 --require CLI 옵션을 사용하여 확장을 사전 로드할 수 있습니다. 이 옵션의 값은 파일의 경로(현재 디렉터리를 기준으로) 또는 노드 모듈 이름일 수 있습니다. -r 옵션은 여러 번 지정할 수 있습니다.
이 옵션은 사이트 작성자에게 Antora가 실행을 시작하기 전에, 즉 Antora가 로드되기 전에 추가 코드를 런타임에 로드할 수 있는 기능을 제공합니다. 이 옵션은 Node.js의 require() 함수의 모듈 해석 규칙을 따릅니다. 이 옵션의 일반적인 사용 사례는 Asciidoctor 확장을 전역적으로 등록하는 것입니다.
노드 모듈 또는 스크립트가 Asciidoctor 확장인 경우 확장을 사용하려면 요구될 때 Asciidoctor의 정적 확장 레지스트리에 자체 등록해야 합니다. (Antora는 단순히 스크립트를 요구할 뿐입니다. 내보낸 함수를 호출하지 않습니다).
Antora CLI를 사용하여 여러 Asciidoctor 확장을 사전 로드하는 방법을 보여주는 예제는 다음과 같습니다:
[source,bash]
antora -r ./lib/shout-block -r asciidoctor-emoji-macro antora-playbook.yml
-r 옵션은 전역 상태를 변경하거나 Antora 구성 요소를 재정의하는 등 다른 용도로도 사용할 수 있습니다.
CLI에 대한 자세한 내용은 Antora CLI 명령을 참조하세요.



== Configure Your Site - AsciiDoc Keys - File and Line Number Information

=== sourcemap 키
활성화되면 Antora의 로거와 Asciidoctor 확장에 AsciiDoc 블록에 대한 추가 파일 및 행 번호 정보를 제공합니다.
=== 소스맵이란?
소스맵은 구문 분석된 각 AsciiDoc 블록의 파일 및 행 번호를 추적하고 저장하는 AsciiDoc 프로세서 기능입니다. 일부 Asciidoctor 확장은 성공적으로 실행되거나 올바른 출력을 반환하기 위해 이 정보에 의존합니다. Antora의 로거는 이 정보를 사용하여 AsciiDoc 구문과 관련된 오류, 경고 및 정보 메시지에 행 번호와 include 지시문 소스 파일 위치 컨텍스트를 추가합니다. 예를 들어 AsciiDoc 프로세서의 소스맵이 켜져(활성화되어) 있으면 Antora의 로거는 파일에서 확인되지 않은 xref가 위치한 행 번호를 제공할 수 있습니다. 소스맵이 꺼져 있으면 로거는 손상된 xref가 포함된 페이지 파일의 위치만 제공할 수 있습니다.
소스맵 기능은 플레이북에서 sourcemap 키를 활성화하거나 --asciidoc-sourcemap 옵션을 사용하여 켤 수 있습니다.
=== 기본 소스맵 값
sourcemap 키는 기본적으로 false로 설정됩니다. 즉, 플레이북에서 활성화되거나 --asciidoc-sourcemap 옵션을 사용하여 CLI에서 활성화되지 않는 한 런타임에 비활성화(꺼짐)됩니다.
==== 소스맵이 기본적으로 켜져 있지 않은 이유는?
소스맵은 빌드 프로세스에 추가 처리 및 객체 할당을 추가하기 때문에 Antora는 기본적으로 sourcemap 키를 활성화하지 않습니다. 이로 인해 사이트 생성 시간이 늘어날 수 있습니다.
=== sourcemap 키
선택적 sourcemap 키는 asciidoc 키에 매핑됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
asciidoc:
sourcemap: true
sourcemap 키를 활성화하려면 플레이북 파일에서 값 true를 할당하세요.
=== AsciiDoc 소스맵 옵션
이 키를 활성화 또는 비활성화하기 위해 플레이북 파일을 직접 수정할 필요는 없습니다. CLI에서 소스맵을 활성화하려면 --asciidoc-sourcemap 옵션을 사용하세요.
[source,console]
$ antora --asciidoc-sourcemap antora-playbook.yml
--asciidoc-sourcemap 옵션은 플레이북 파일에 할당된 sourcemap 키 값을 재정의합니다.
sourcemap 키가 플레이북 파일에서 활성화된 경우 명령줄에서 비활성화할 수 없습니다. CLI는 이를 활성화할 수만 있습니다.



== Configure Your Site - UI Keys

ui 아래에 구성된 플레이북 키는 UI 번들의 위치를 정의하고 처리 방법을 제어합니다.

=== ui 키

ui 키는 UI 번들의 위치, 상태, 기본 페이지 템플릿 이름 및 출력 디렉터리를 지정합니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
ui: [1]
  bundle: [2] 
    url: https://example.org/docs-ui/download/latest/ui-bundle.zip [3]
    snapshot: true [4]
    start_path: dark [5]
  default_layout: base [6]
  output_dir: _/dark [7]
----

[1] 필수 ui 키 +
[2] 필수 bundle 키 +
[3] 필수 url 키 +
[4] 선택적 snapshot 키 +
[5] 선택적 start_path 키 +
[6] 선택적 default_layout 키 +
[7] 선택적 output_dir 키

ui, bundle 및 url 키는 필수입니다. 또는 url 키는 CLI에서 할당할 수 있습니다. 다른 키는 선택 사항이며, 지정되지 않은 경우 Antora는 기본값을 사용합니다.

=== 사용 가능한 UI 키

[cols="2,4,1", options="header"]
|===
|UI 키|설명|필수

|bundle.snapshot
|URL이 스냅샷을 가리키는지 여부를 나타냅니다.
|아니오

|bundle.start_path
|UI 번들 내부의 경로를 허용하며, 해당 경로에서 파일을 선택해야 합니다.
|아니오

|bundle.url
|UI 번들 아카이브에 대한 URL 또는 파일 시스템 경로를 허용합니다.
|예

|default_layout
|페이지 레이아웃을 지정하지 않은 페이지에 레이아웃 템플릿을 적용합니다.
|아니오

|output_dir
|Antora가 게시된 사이트의 UI 파일을 작성하는 출력 디렉터리에 대한 파일 시스템 경로를 허용합니다.
|아니오

|supplemental_files
|UI 번들에 오버레이할 보충 파일(일명 보충 UI)입니다.
|아니오
|===



== Configure Your Site - UI Keys - UI Bundle URL

UI 번들은 사이트에 대한 하나 이상의 UI를 포함하는 ZIP 아카이브 또는 디렉터리입니다. UI 번들에 필요한 유일한 파일은 페이지의 기본 레이아웃(예: layouts/default.hbs)입니다(404 페이지가 활성화된 경우 layouts/404.hbs도 필요). Antora는 사이트를 생성할 때 자동으로 UI 번들을 가져와 로드합니다.

=== url 키

url 키는 필수입니다. 이 키는 플레이북의 ui 카테고리 키 아래 bundle 키에 구성됩니다. url 키는 Antora가 사이트의 UI 번들을 찾아 가져올 수 있는 URL 또는 파일 시스템 경로를 허용합니다. 파일 시스템 경로는 ZIP 아카이브 또는 ZIP 아카이브가 추출된 로컬 디렉터리를 가리켜야 합니다.

.예제 1. antora-playbook.adoc
[source,yaml]
----
ui: [1]
  bundle: [2] 
    url: https://repo.org/path/to/a-ui-bundle.zip [3]
----

[1] 부모 키 ui를 입력하고 콜론(:)을 입력한 다음 Enter를 누릅니다.
[2] bundle 키는 ui의 자식입니다. 키의 이름 bundle을 입력하고 콜론(:)을 입력한 다음 Enter를 누릅니다.
[3] url 키는 bundle의 자식입니다. url을 입력하고 콜론과 공백(: )을 입력한 다음 URL 또는 파일 시스템 경로 값을 입력합니다.

또는 url 키는 CLI에서 할당할 수 있습니다.

UI 번들은 보충 UI를 사용하여 보강할 수 있습니다.

=== 원격 번들 로드

url 값이 원격 URL인 경우 Antora는 처음 실행할 때 UI 번들을 다운로드하고 캐시합니다. 이 경우 대상은 ZIP 아카이브여야 합니다.

.예제 2. 원격 UI 번들
[source,yaml]
----
ui:
  bundle:
    url: https://repo.org/path/to/a-ui-bundle.zip
----

UI 번들은 URL의 서명을 기반으로 캐시됩니다. 후속 실행에서 url 값이 변경되지 않는 한 Antora는 캐시에서 번들을 로드합니다. 이렇게 하면 사이트를 생성할 때마다 Antora가 번들을 다운로드할 필요가 없습니다.

==== 스냅샷 사용

fetch가 활성화된 경우에도 UI 번들이 캐시에 있으면 Antora는 UI 번들을 다시 다운로드하지 않습니다. url 값은 동일하게 유지되지만 가리키는 아카이브가 시간이 지남에 따라 변경되는 경우 이 캐시를 우회하려면 UI 번들을 스냅샷으로 식별해야 합니다.

url 값을 변경하지 않고 UI 번들 업데이트를 검색하려면 url 키 옆에 snapshot 키를 활성화해야 합니다. 기본적으로 snapshot은 활성화되지 않습니다(false로 설정됨). snapshot이 true로 설정되면 플레이북의 runtime 카테고리 아래에 있는 fetch 키가 활성화될 때마다 Antora가 UI 번들을 다운로드합니다. fetch 키는 Antora에게 업데이트(UI 번들 스냅샷 포함)를 검색하도록 지시합니다.

.예제 3. 스냅샷으로 표시된 원격 UI 번들
[source,yaml]
----
ui:
  bundle:
    url: https://gitlab.com/antora/antora-ui-default/-/jobs/artifacts/HEAD/raw/build/ui-bundle.zip?job=bundle-stable
    snapshot: true
snapshot: true
----

[TIP]
====
Antora의 참조 UI 번들을 사용하는 경우 URL이 절대 변경되지 않으므로 번들을 스냅샷으로 표시해야 합니다.
====

Antora가 업데이트를 검색하는 시기를 제어하려면 antora 명령을 호출할 때 --fetch 옵션을 전달하세요. 이 설정을 영구적으로 만들려면 플레이북의 runtime.fetch 키를 true로 설정하세요.

.예제 4. 영구 설정으로 업데이트 가져오기
[source,yaml]
----
runtime:
  fetch: true
----

snapshot 키는 원격 번들을 참조하는 경우에만 필요합니다(Antora는 기본적으로 캐시함). 파일 시스템에서 번들을 참조하는 경우 Antora는 항상 지정된 파일을 사용합니다.

=== 파일 시스템에서 번들 로드

url 키는 절대 또는 상대 파일 시스템 경로를 사용하여 로컬 UI 번들을 참조할 수 있습니다.

.예제 5. 상대 UI 번들 경로
[source,yaml]
----
ui:
  bundle:
    url: ./../docs-ui/build/ui-bundle.zip
----

상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

- 첫 번째 경로 세그먼트가 물결표(~)이면 나머지 경로는 사용자의 홈 디렉터리를 기준으로 해석됩니다.
- 첫 번째 경로 세그먼트가 점(.)이면 나머지 경로는 플레이북 파일의 위치를 기준으로 해석됩니다.
- 첫 번째 경로 세그먼트가 물결표 바로 뒤에 더하기 기호(~+)가 오거나 앞에서 언급한 접두사로 시작하지 않으면 나머지 경로는 현재 작업 디렉터리를 기준으로 해석됩니다.

다음은 동일한 UI 번들의 경로이지만 절대 경로를 대신 사용합니다.

.예제 6. 절대 UI 번들 경로
[source,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle.zip
----

다음은 UI 번들이 추출된 위치(또는 추출된 아카이브와 동일한 레이아웃으로 구성된 위치)의 경로입니다.

.예제 7. 추출된 UI 번들 경로
[source,yaml]
----
Example 7. Extracted UI bundle path
ui:
  bundle:
    url: ./../docs-ui/build/ui-bundle-extracted
----

로컬 디렉터리에서 UI 번들을 로드하는 것은 로직을 디버깅하는 좋은 방법입니다.

=== start_path 키

start_path 키는 bundle 키에 매핑됩니다. 이 키는 Antora가 파일 읽기를 시작해야 하는 UI 번들 내부의 상대 경로를 허용합니다. 이 키는 UI 번들이 여러 UI(예: 밝은 테마, 어두운 테마 등)를 패키징할 때 유용합니다.

.예제 8. start_path에서 UI 선택
[source,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle-with-themes.zip
    start_path: dark
----

이 예제에서 Antora는 dark 디렉터리 외부에 있는 UI 번들의 모든 파일을 무시합니다.



== Configure Your Site - UI Keys - Supplemental UI

UI 번들을 보강하기 위해 보조 UI 파일을 지정할 수 있습니다. 이러한 파일은 UI 번들에서 제공하는 파일을 보완하기 때문에 총칭하여 보조 UI라고 합니다.

보조 UI는 새로운 UI 번들을 만들지 않고도 기존 UI 번들을 사용자 정의하는 데 유용합니다. 그러나 사용자 정의 UI 번들 개발을 대체하는 용도로 사용해서는 안 됩니다. 오히려 특정 환경에 맞게 몇 가지 사소한 조정이나 추가를 하는 데 사용해야 합니다. 그 중 한 가지 예는 파비콘입니다. 파비콘은 브랜드 정체성의 일부이므로 기성품 UI 번들을 사용하되 자신만의 파비콘을 추가할 수 있습니다. 보조 UI를 사용하여 이 목표를 달성할 수 있습니다.

=== 작동 방식

보조 UI는 로드된 UI 번들의 파일에 오버레이됩니다. 보조 UI의 파일 경로가 UI 번들의 파일 경로와 일치하지 않으면 해당 파일은 UI 번들의 파일에 추가됩니다. 보조 UI의 파일 경로가 UI 번들의 파일 경로와 일치하면 보조 UI의 파일이 UI 번들의 파일을 대체합니다. 보조 UI의 파일은 따로 처리되지 않습니다.

=== supplemental_files 키

보조 UI는 ui 카테고리 키 아래의 supplemental_files 키를 사용하여 구성됩니다. 이 키는 보조 파일이 포함된 디렉터리의 경로 또는 가상 파일의 맵을 허용합니다. 현재 이 두 값 유형은 상호 배타적입니다.

**디렉터리**

supplemental_files 키의 값이 문자열이면 Antora는 이 값을 디렉터리의 경로로 가정합니다. 이 값은 상대 또는 절대 파일 시스템 경로로 지정할 수 있습니다. 상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

- 첫 번째 경로 세그먼트가 물결표(~)이면 나머지 경로는 사용자의 홈 디렉터리를 기준으로 해석됩니다.
- 첫 번째 경로 세그먼트가 점(.)이면 나머지 경로는 플레이북 파일의 위치를 기준으로 해석됩니다.
- 첫 번째 경로 세그먼트가 물결표 바로 뒤에 더하기 기호(~+)가 오거나 앞에서 언급한 접두사로 시작하지 않으면 나머지 경로는 현재 작업 디렉터리를 기준으로 해석됩니다.

[source,yaml]
----
ui:
  supplemental_files: ./supplemental-ui
----

Antora는 이 디렉터리에서 파일을 검색하여 로드된 UI 번들에 추가합니다. 이 디렉터리는 UI 계층 구조의 루트로 간주됩니다. 따라서 UI 경로는 이 디렉터리에 상대적인 파일의 경로입니다.

head-meta 부분을 자신만의 부분으로 대체하려고 한다고 가정해 보겠습니다. 플레이북 파일에 상대적인 supplemental-ui/partials/head-meta.hbs 위치에 파일을 만듭니다. 다음으로 HTML과 포함하려는 선택적 템플릿 로직으로 채웁니다.

.예제 1. supplemental-ui/partials/head-meta.hbs
[source,hbs]
----
{{#with site.keys.googleSiteVerification}}
<meta name="google-site-verification" content="{{this}}">
{{/with}}
----

이제 Antora는 UI에서 제공하는 _head-meta_ 부분 대신 이 부분을 사용합니다.

**가상 파일**

디렉터리의 대안으로 보조 UI 파일을 플레이북에 직접 가상 파일로 지정할 수 있습니다. supplemental_files 키의 값이 배열이면 Antora는 각 항목이 가상 파일이라고 가정합니다. 가상 파일 항목은 path와 contents의 두 키로 구성됩니다. path 키는 UI에서 파일의 상대 경로입니다(예: partials/head-meta.hbs). 내용은 지정된 디렉터리이거나 파일 시스템의 파일에서 소싱될 수 있습니다.

contents 키의 값이 한 줄이고 파일 확장자(예: .hbs)로 끝나면 Antora는 이 값을 상대 또는 절대 파일 시스템 경로로 지정된 파일의 경로로 가정합니다. 그렇지 않으면 Antora는 입력된 값을 내용으로 사용합니다. Antora가 값이 파일 경로라고 판단하면 파일을 읽고 내용을 가상 파일에 할당합니다. contents 키를 생략하면 Antora는 빈 파일을 만듭니다.

head-meta 부분을 자신만의 부분으로 대체하려고 한다고 가정해 보겠습니다. 플레이북에서 가상 파일로 정의할 수 있습니다:

[source,yaml]
----
ui:
  supplemental_files:
  - path: partials/head-meta.hbs
    contents: |
      {{#with site.keys.googleSiteVerification}}
      <meta name="google-site-verification" content="{{this}}">
      {{/with}}
----

내용을 파일에 넣고 가상 파일 항목에서 참조할 수도 있습니다:

[source,yaml]
----
ui:
  supplemental_files:
  - path: partials/head-meta.hbs
    contents: ./supplemental-ui/partials/head-meta.hbs
----

몇 개의 작은 파일만 정의하는 경우 일반적으로 플레이북에 직접 정의할 수 있습니다. 파일이 더 크거나 여러 플레이북 간에 공유해야 하는 경우에는 별도의 파일에 저장하는 것이 가장 좋습니다.

=== 정적 파일

기본적으로 이미지 및 JavaScript 파일과 같은 보조 UI에서 제공하는 게시 가능한 자산은 UI 출력 디렉터리에 게시됩니다. 특정 파일을 게시된 사이트의 루트에 게시하도록 구성할 수 있습니다. 이러한 파일을 정적 파일이라고 합니다. 정적 파일은 보조 UI에서 제공해야 하는 UI 설명자 ui.yml을 사용하여 식별됩니다. UI 설명자는 UI의 특정 측면을 구성하는 YAML 파일입니다.

정적 파일을 만들려면 먼저 일반적으로 표준 폴더 외부의 보조 UI에 파일을 만듭니다. 정적 파일의 좋은 예는 사이트 루트에 있는 파비콘 favicon.ico입니다. supplemental-ui 디렉터리에 파비콘을 넣었다고 가정해 보겠습니다. 경로에서 보조 UI를 로드하는 경우 다음 내용으로 ui.yml 파일을 추가하세요:

.예제 2. ui.yml
[source,yaml]
----
static_files:
- favicon.ico
----

static_files 키는 문자열 배열을 허용합니다. 각 항목은 UI 내 파일의 상대 경로입니다(슬래시로 시작하면 안 됨). Antora는 이 파일을 선택하고 favicon이 정적 파일임을 확인한 다음 UI 출력 디렉터리 대신 사이트의 루트에 게시합니다.

보조 UI를 가상 파일로 정의하는 경우 파비콘과 ui.yml 파일 모두에 대한 항목을 추가해야 합니다.

.예제 3. antora-playbook.yml
[source,yaml]
----
ui:
  supplemental_files:
  - path: favicon.ico
    contents: ./supplemental-ui/favicon.ico
  - path: ui.yml
    contents: |
      static_files:
      - favicon.ico
----

[WARNGING]
====
UI 번들에 ui.yml 파일이 포함된 경우 보조 UI에 대해 다시 정의할 때 내용을 복제해야 합니다. 보조 UI의 파일이 UI 번들에서 제공하는 파일을 덮어쓰기 때문입니다.
====

보조 UI는 사이트에 정적 파일을 추가하는 편리한 방법을 제공하지만 대신 확장을 사용하는 것이 좋습니다.



== Configure Your Site - UI Keys - UI Output Directory

=== 기본 UI 출력 디렉터리

UI 파일은 사이트의 출력 디렉터리를 기준으로 단일 밑줄 _ 로 레이블이 지정된 디렉터리에 게시됩니다. 예를 들어 사이트가 기본 사이트 출력 디렉터리(_build/site_)에 게시되고 UI _output_dir_이 지정되지 않은 경우 UI 파일은 _build/site/__ 에 작성됩니다.

=== output_dir 키

output_dir 키를 사용하면 Antora가 UI 파일을 게시해야 하는 대체 디렉터리를 지정할 수 있습니다. 경로는 게시된 사이트의 루트에 상대적입니다.

.예제 1. 상대 UI 출력 경로
[source,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle-with-themes.zip
    start_path: dark
  output_dir: _/dark
----

이 예제에서는 사이트가 기본 대상 디렉터리에 작성되므로 UI 파일이 build/site/_/dark 에 게시됩니다.

Antora는 사용하는 값에 관계없이 UI 파일에 대한 모든 참조를 자동으로 재구성합니다. 이는 부분적으로 UI 템플릿에서 {{uiRootPath}} 자리 표시자를 사용하기 때문입니다.
다음 예제에서는 UI 출력 디렉터리 외에 사이트의 출력 디렉터리(dir)가 지정됩니다.

.예제 2. 사용자 정의 사이트 및 UI 출력 디렉터리
[source,yaml]
----
ui:
  bundle:
    url: /home/user/projects/docs-ui/build/ui-bundle-with-themes.zip
    start_path: dark
  output_dir: _/dark
output:
  dir: ./public
----

UI 파일은 _public/_/dark_ 에 게시됩니다.



== Configure Your Site - UI Keys - Default Layout for Pages

=== 기본 페이지 레이아웃

default_layout 키가 플레이북에 지정되지 않는 한 Antora는 page-layout 속성이 설정되지 않은 모든 페이지에 default 레이아웃을 적용합니다. default 레이아웃은 Antora가 UI 번들의 layouts 디렉터리에서 찾을 것으로 예상하는 _default.hbs_ 파일에 해당합니다.

default_layout 키를 사용하여 Antora에게 사이트의 모든 페이지에 사용자 정의 레이아웃을 적용하도록 지시할 수 있습니다.

=== default_layout 키

default_layout 키는 ui 키에 매핑됩니다. 레이아웃 파일의 줄기(즉, 파일 확장자가 없는 파일 이름)인 값을 허용합니다. 지정된 레이아웃 파일은 UI 번들의 _layouts_ 디렉터리에 있어야 합니다.

예를 들어 레이아웃 파일 article.hbs 를 기본 페이지 레이아웃으로 사용하려면 default_layout 을 article 로 설정하면 됩니다.

.예제 1. 기본 레이아웃 값
[source,yaml]
----
ui:
  bundle:
    url: ./../docs-ui/build/ui-bundle.zip
  default_layout: article
----

article 레이아웃은 헤더에 page-layout 속성이 정의된 페이지를 제외하고 사이트의 모든 페이지에 적용됩니다.



== Configure Your Site - URLs Keys

ui 아래에 구성된 플레이북 키는 UI 번들의 위치를 정의하고 처리 방법을 제어합니다.
=== ui 키
ui 키는 UI 번들의 위치, 상태, 기본 페이지 템플릿 이름 및 출력 디렉터리를 지정합니다.
.예제 1. antora-playbook.yml
[source,yaml]
ui:
bundle:
url: https://example.org/docs-ui/download/latest/ui-bundle.zip
snapshot: true
start_path: dark
default_layout: base
output_dir: _/dark
<1> 필수 ui 키
<2> 필수 bundle 키
<3> 필수 url 키
<4> 선택적 snapshot 키
<5> 선택적 start_path 키
<6> 선택적 default_layout 키
<7> 선택적 output_dir 키
ui, bundle 및 url 키는 필수입니다. 또는 url 키는 CLI에서 할당할 수 있습니다. 다른 키는 선택 사항이며, 지정되지 않으면 Antora는 해당 기본값을 사용합니다.
=== 사용 가능한 UI 키
[cols="1,3,1", options="header"]
|===
| UI 키 | 설명 | 필수
| bundle.snapshot
| URL이 스냅샷을 가리키는지 여부를 나타냅니다.
| 아니오
| bundle.start_path
| 파일을 선택해야 하는 UI 번들 내부의 경로를 받아들입니다.
| 아니오
| bundle.url
| UI 번들 아카이브에 대한 URL 또는 파일 시스템 경로를 받아들입니다.
| 예
| default_layout
| 페이지 레이아웃을 지정하지 않는 페이지에 레이아웃 템플릿을 적용합니다.
| 아니오
| output_dir
| Antora가 게시된 사이트의 UI 파일을 작성하는 출력 디렉터리에 대한 파일 시스템 경로를 받아들입니다.
| 아니오
| supplemental_files
| UI 번들에 오버레이할 보충 파일(별칭 보충 UI).
| 아니오
|===



== Configure Your Site - URLs Keys - HTML Extension Styles

Antora를 통해 HTML 페이지의 URL에 사용되는 파일 확장자를 사용자 정의할 수 있습니다. 기본적으로 URL은 게시된 파일의 이름을 반영하여 .html로 끝납니다. SEO 또는 기타 이유로 확장자를 숨겨서 URL을 "깔끔하게" 만들고 싶다면 Antora를 구성하여 그렇게 할 수 있습니다. 확장자를 완전히 삭제하거나 확장자를 슬래시로 대체하는 옵션이 있습니다(indexify라고 하는 기술). 이러한 옵션 중 하나를 사용할 때 소스 페이지의 이름이 index.adoc인 경우 Antora는 마지막 URL 세그먼트도 삭제합니다. 이 페이지에서는 이 설정을 제어하는 방법을 설명합니다.
=== html_extension_style 키
html_extension_style 키는 선택 사항입니다. 플레이북의 urls 키 아래에 구성됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
urls:
html_extension_style: indexify
다음과 같은 기본 제공 값을 받아들입니다:

default




게시된 페이지 URL은 .html 확장자와 함께 표시됩니다. 즉, *https://base-url.com/component/version/module/my-file.html*과 같습니다. Antora는 html_extension_style이 플레이북이나 CLI를 통해 설정되지 않은 경우 자동으로 이 스타일을 적용합니다.

indexify




.html 확장자가 삭제되고 게시된 페이지 URL 끝에 슬래시(/)가 추가됩니다. 즉, *https://base-url.com/component/version/module/my-file/*와 같습니다. URL에 .html 확장자가 나타나지 않게 하려면 이 스타일이 선호됩니다.

drop




.html 확장자는 게시된 페이지 URL 끝에서 삭제됩니다. 즉, *https://base-url.com/component/version/module/my-file*과 같습니다. 이 스타일은 웹 서버의 지원이 필요하며 필요한 웹 서버 구성을 적용하는 데 익숙한 경우에만 사용해야 합니다.
=== 기본 스타일 사용
html_extension_style 키가 플레이북이나 --html-url-extension-style 옵션을 사용하여 CLI에 설정되지 않은 경우 Antora는 런타임에 자동으로 값 default를 할당합니다. 기본 스타일은 모든 게시된 페이지의 URL 끝에 .html 확장자를 추가합니다. 예를 들어 my-file.adoc 페이지의 결과 URL은 브라우저에 .html이 끝에 추가된 *https://base-url.com/component/version/module/my-file.html*로 표시됩니다.
=== indexify 스타일 적용
html_extension_style 키에 indexify를 할당해 보겠습니다.
.예제 2. antora-playbook.yml
[source,yaml]
site:
title: Site Title
url: https://example.org
urls:
html_extension_style: indexify
indexify가 적용되면 사이트의 게시된 URL은 .html 확장자로 끝나지 않습니다. 대신 페이지 스템 끝에 슬래시(/)가 직접 추가됩니다. 이로 인해 my-file.adoc 페이지의 URL이 브라우저에 *https://example.com/component/version/module/my-file/*로 표시됩니다.
html_extension_style이 indexify로 할당된 경우 리디렉션 및 404 페이지와 같은 사이트의 모든 기능을 로컬에서 미리 보려면 로컬 서버를 실행해야 합니다.
=== drop 스타일 적용
html_extension_style 키에 drop을 할당해 보겠습니다.
.예제 3. antora-playbook.yml
[source,yaml]
site:
title: Site Title
url: https://example.org
urls:
html_extension_style: drop
drop이 적용되면 사이트의 게시된 URL은 .html 확장자로 끝나지 않습니다. 이로 인해 my-file.adoc 페이지의 URL이 브라우저에 *https://example.com/component/version/module/my-file*로 표시됩니다. 이 스타일을 사용할 때 사이트가 제대로 작동하려면 웹 서버를 통해 사이트를 봐야 합니다. 또한 웹 서버가 .html 확장자가 있는 파일을 찾도록 구성해야 합니다.
모든 웹 서버가 확장자 없는 HTML URL을 지원할 수 있는 것은 아닙니다.
nginx를 사용하는 경우 호스트에 대한 구성의 location / 스탠자에 다음 지시문을 추가해야 합니다:
[source,nginx]
location / {
...
try_files $uri $uri.html $uri/index.html = 404;
}
이 지시문은 nginx에게 먼저 요청된 파일을 찾은 다음 .html 확장자가 추가된 동일한 파일을 찾은 다음 요청된 파일과 일치하는 디렉터리에서 index.html이라는 파일을 찾도록 지시합니다. 이러한 시도는 게시된 파일의 레이아웃과 일치합니다.



== Configure Your Site - URLs Keys - Latest Version Segment

latest_version_segment 키는 최신 구성 요소 버전의 게시된 URL에서 실제 버전을 기호 버전으로 대체합니다. 키의 이름에서 알 수 있듯이 사이트에서 각 구성 요소 버전의 최신 버전에만 적용됩니다.
=== latest_version_segment 키
latest_version_segment 키는 플레이북의 urls 키 아래에 구성됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
urls:
latest_version_segment: current
<1> 부모 키 urls를 입력하고 콜론(:)을 입력한 다음 Enter 키를 눌러 새 줄로 이동합니다.
<2> latest_version_segment 키는 urls 키 아래에 중첩되어야 합니다. latest_version_segment를 입력하고 콜론(:)을 입력한 다음 기호 버전 값을 입력합니다.
latest_version_segment 키에 할당된 값은 기호 버전입니다. Antora는 URL의 버전 세그먼트에서 실제 버전을 기호 버전으로 대체합니다. 기호 버전은 구성 요소의 최신 버전에 속하는 페이지 및 자산의 URL에만 적용됩니다. latest_version_segment_strategy 키에 할당된 전략에 따라 Antora는 기호 버전 URL과 실제 버전 URL 간에 라우팅할 때 추가 리디렉션 규칙을 적용할 수 있습니다.
=== 값 요구 사항
version 키의 값에 적용되는 동일한 요구 사항이 latest_version_segment 키에도 적용됩니다. 값에는 문자, 숫자, 마침표(.), 밑줄(_) 및 하이픈(-)이 포함될 수 있습니다. 호스트 플랫폼 간의 이식성을 보장하려면 소문자를 사용하세요.
latest_version_segment 키의 값에는 공백, 슬래시(/) 또는 HTML 특수 문자(&, < 또는 >)를 포함할 수 없습니다. 값은 null일 수 없습니다(값이 없거나 ~일 수도 없음을 의미). 값은 latest_version_segment_strategy의 값이 redirect:to 또는 replace인 경우에만 빈 문자열일 수 있습니다. latest_version_segment_strategy의 값이 redirect:from이면 값은 빈 문자열일 수 없습니다. 이 제한은 상위 폴더에 리디렉션을 추가하면 다른 버전에 대한 액세스를 방지할 수 있기 때문입니다.
=== 최신 버전 세그먼트 지정
이 섹션에서는 latest_version_segment 키에 기호 버전을 할당한 결과를 살펴봅니다. 이 섹션의 예제는 예제 2와 예제 3에 표시된 구성 요소 버전 설명자 파일에 의해 정의된 구성 요소 버전을 사용합니다. 예제 2는 이름이 colorado이고 버전이 5.2인 구성 요소 버전을 정의합니다.
.예제 2. colorado 5.2 구성 요소 버전을 정의하는 구성 요소 버전 설명자(antora.yml 파일)
[source,yaml]
name: colorado
version: '5.2'
<1> antora.yml의 version 키는 구성 요소의 실제 버전을 5.2로 정의합니다.
예제 3은 이름이 colorado이고 버전이 5.6인 구성 요소 버전을 정의합니다.
.예제 3. colorado 5.6 구성 요소 버전을 정의하는 구성 요소 버전 설명자(antora.yml 파일)
[source,yaml]
name: colorado
version: '5.6'
<1> antora.yml의 version 키는 구성 요소의 실제 버전을 5.6으로 정의합니다.
두 구성 요소 버전에는 get-started 모듈에 속하는 tour.adoc라는 페이지가 있습니다.
먼저 Antora가 기본적으로 만드는 URL을 검토해 보겠습니다. 즉, 플레이북에 latest_version_segment 키가 설정되지 않은 경우입니다. 예제 4는 Antora가 절대 URL을 작성할 때와 URL이 브라우저 주소 표시줄에 표시될 때 사용하는 url 키에 할당된 사이트 URL을 지정합니다.
.예제 4. 사이트 url 값을 보여주는 플레이북(antora-playbook.yml 파일)
[source,yaml]
site:
title: The Ranges
url: https://docs.example.com
content:
...

예제 2와 예제 3이 사이트에서 유일한 구성 요소 버전이라고 가정하면 Antora는 colorado 5.6을 colorado 구성 요소의 최신 버전으로 식별합니다. Antora는 의미론적 및 명명된 버전 정렬 규칙을 기반으로 최신 구성 요소 버전과 버전 순서를 결정합니다. 플레이북과 antora.yml 파일의 정보를 사용하여 Antora는 각 구성 요소 버전의 tour.adoc 페이지에 대해 다음 URL을 구성합니다.
예제 5에 표시된 것처럼 colorado 5.2 구성 요소 버전에 속하는 tour.adoc 페이지의 버전 세그먼트는 실제 버전 5.2를 사용합니다.
.예제 5. colorado 5.2 tour.adoc 페이지의 URL
[source,text]
https://docs.example.com/colorado/5.2/get-started/tour.html
예제 6에서 버전 세그먼트는 colorado 5.6 구성 요소 버전에 속하는 tour.adoc 페이지에 실제 버전 5.6을 사용합니다.
.예제 6. colorado 5.6 tour.adoc 페이지의 URL
[source,text]
https://docs.example.com/colorado/5.6/get-started/tour.html
URL에 버전 5.6을 구성 요소 colorado의 최신 버전으로 나타내는 것은 없지만 Antora는 참조 UI에서 기본 정렬 순서를 적용하므로 버전 5.6은 구성 요소 버전 선택기의 colorado 구성 요소 이름 아래에 첫 번째로 나열되고 페이지 버전 선택기의 나열된 버전에서 첫 번째로 나열됩니다.
이제 최신 구성 요소 버전의 페이지 및 자산 URL에서 실제 버전을 대체할 기호 버전을 할당해 보겠습니다. latest_version_segment 키는 사이트의 모든 최신 구성 요소 버전에 적용되므로 구성 요소 버전 설명자 파일이 아닌 플레이북 파일에 구성됩니다. 예제 7은 latest_version_segment 키가 정의된 축약된 플레이북 파일을 보여줍니다.
.예제 7. 기호 버전을 정의하는 플레이북(antora-playbook.yml 파일)
[source,yaml]
----
site:
title: The Ranges
url: https://docs.example.com
urls:
latest_version_segment: stable
content: <1>
----
<1> latest_version_segment는 urls 키 아래에 설정되고 값 stable이 할당됩니다.

예제 2와 예제 3에 정의된 구성 요소 버전과 예제 7의 플레이북을 사용하여 Antora는 각 구성 요소 버전의 tour.adoc 페이지에 대해 다음 URL을 구성합니다.
예제 8에서 버전 세그먼트는 실제 버전을 사용합니다. colorado 5.2가 colorado 구성 요소의 최신 버전이 아니기 때문입니다.
.예제 8. latest_version_segment가 설정된 경우 colorado 5.2 tour.adoc 페이지의 URL
[source,text]
----
https://docs.example.com/colorado/5.2/get-started/tour.html
----

그러나 예제 9에서 버전 세그먼트는 기호 버전 stable을 사용합니다. Antora가 colorado 5.6이 colorado 구성 요소의 최신 버전이라고 판단했기 때문입니다.
.예제 9. latest_version_segment가 설정된 경우 colorado 5.6 tour.adoc 페이지의 URL
[source,text]
----
https://docs.example.com/colorado/stable/get-started/tour.html
----

실제 버전 5.6은 여전히 참조 UI 메뉴에 표시됩니다. 기호 버전 stable은 URL에만 사용됩니다. 참조 UI 메뉴에 표시되는 값을 사용자 정의하려면 display_version 키를 사용하세요.
URL에서 버전 세그먼트를 삭제하려면 값을 빈 문자열로 설정하여 수행할 수 있습니다(값이 없는 것과 다름).

.예제 10. 빈 기호 버전을 정의하는 플레이북
[source,yaml]
----
site:
title: The Ranges
url: https://docs.example.com
urls:
latest_version_segment: ''
content:
<1> URL에서 버전 세그먼트를 삭제하려면 latest_version_segment의 값을 빈 문자열로 설정하세요.
최신 버전의 페이지는 이제 버전 세그먼트를 포함하지 않는 URL에서 액세스할 수 있습니다.
----

.예제 11. latest_version_segment가 비어 있을 때 colorado 5.6 tour.adoc 페이지의 URL
[source,text]
----
https://docs.example.com/colorado/get-started/tour.html
----

버전이 더 이상 URL에 존재하지 않습니다. 실제 버전 5.6은 여전히 참조 UI 메뉴에 표시됩니다. latest_version_segment_strategy가 redirect:from인 경우 latest_version_segment를 빈 문자열로 설정할 수 없다는 점을 기억하세요.
이 섹션의 예제는 latest_version_segment_strategy 키가 설정되지 않았다고 가정했습니다. 따라서 Antora는 latest_version_segment 키를 감지하면 자동으로 latest_version_segment_strategy 키를 설정하고 런타임에 replace 전략을 할당합니다. redirect:to 및 redirect:from 전략이 latest_version_segment 키와 어떻게 작동하는지 알아보려면 최신 버전 세그먼트 전략을 참조하세요.



== Configure Your Site - URLs Keys - Latest Prerelease Version Segment

latest_prerelease_version_segment 키는 최신 사전 릴리스의 리소스 URL에서 실제 버전을 기호 사전 릴리스 버전으로 대체합니다.

버전이 사전 릴리스로 분류되려면 구성 요소에 하나 이상의 사전 릴리스가 아닌 버전도 있어야 합니다. 구성 요소에 사전 릴리스 버전만 있는 경우 구성 요소 설명자에 prerelease 키가 설정되어 있더라도 최신 버전은 사전 릴리스로 분류되지 않습니다. 구성 요소에 사전 릴리스 버전만 있는 경우 대신 latest_version_segment의 값이 사용됩니다. 이 동작은 향후 변경될 수 있습니다.

=== latest_prerelease_version_segment 키

latest_prerelease_version_segment 키는 플레이북의 urls 키 아래에 구성됩니다.

.예제 1. antora-playbook.yml
[source,yaml]
----
urls:
latest_prerelease_version_segment: unstable
----

latest_prerelease_version_segment 키에 할당된 값은 기호 사전 릴리스 버전입니다. Antora는 최신 사전 릴리스 구성 요소 버전 URL의 버전 세그먼트에서 실제 버전을 기호 사전 릴리스 버전으로 대체합니다. 구성 요소 버전은 사전 릴리스로 지정되어야 하며 latest_prerelease_version_segment 키에 할당된 값이 페이지 및 자산 URL에 적용되려면 Antora가 해당 버전이 구성 요소의 최신 사전 릴리스라고 판단해야 합니다. latest_version_segment_strategy 키에 할당된 전략에 따라 Antora는 기호 버전 URL과 실제 버전 URL 간에 라우팅할 때 추가 리디렉션 규칙을 적용할 수 있습니다.

=== 값 요구 사항

version 키의 값에 적용되는 동일한 요구 사항이 latest_prerelease_version_segment 키에도 적용됩니다. 값에는 문자, 숫자, 마침표(.), 밑줄(_) 및 하이픈(-)이 포함될 수 있습니다. 호스트 플랫폼 간의 이식성을 보장하려면 소문자를 사용하세요.
latest_prerelease_version_segment 키의 값에는 공백, 슬래시(/) 또는 HTML 특수 문자(&, < 또는 >)를 포함할 수 없습니다. latest_version_segment_strategy의 값이 redirect:to 또는 replace인 경우에만 값이 비어 있을 수 있습니다. latest_version_segment_strategy의 값이 redirect:from이면 값은 비어 있을 수 없습니다. 이 제한은 상위 폴더에서 리디렉션하면 다른 버전에 대한 액세스를 방지할 수 있기 때문입니다.

=== 최신 사전 릴리스 버전 세그먼트 지정

이 섹션에서는 latest_prerelease_version_segment 키에 기호 사전 릴리스 버전을 할당한 결과를 살펴봅니다. 이 섹션의 예제는 예제 2에 표시된 구성 요소 버전 설명자 파일에 의해 정의된 구성 요소 버전을 사용합니다. 예제 2는 이름이 colorado이고 버전이 6.0인 구성 요소 버전을 정의합니다.

.예제 2. colorado 6.0 구성 요소 버전을 정의하는 구성 요소 버전 설명자(antora.yml 파일)
[source,yaml]
----
name: colorado
version: '6.0'
prerelease: -beta.2

// <1> antora.yml의 version 키는 구성 요소의 실제 버전을 6.0으로 정의합니다.
// <2> prerelease 키와 할당된 식별자 -beta.2는 Antora에게 구성 요소 버전이 사전 릴리스임을 알려줍니다.
----

colorado 6.0 구성 요소 버전에는 get-started 모듈에 속하는 tour.adoc라는 페이지가 있습니다. 먼저 Antora가 기본적으로 만드는 URL을 검토해 보겠습니다. 즉, 플레이북에 latest_prerelease_version_segment 키가 설정되지 않은 경우입니다. 기본적으로 Antora는 구성 요소 버전이 식별자가 있는 사전 릴리스인 경우에도 페이지 및 자산 URL의 버전 세그먼트에 실제 버전을 사용합니다. 예제 3은 colorado 6.0 구성 요소 버전에 속하는 tour.adoc 페이지의 기본 URL을 보여줍니다.

.예제 3. colorado 6.0 tour.adoc 페이지의 URL

[source,text]
----
https://docs.example.com/colorado/6.0/get-started/tour.html
----

이제 이 사이트의 최신 사전 릴리스 구성 요소 버전에 기호 사전 릴리스 버전을 할당해 보겠습니다. latest_prerelease_version_segment 키는 사이트의 모든 최신 사전 릴리스 구성 요소 버전에 적용되므로 구성 요소 버전 설명자 파일이 아닌 플레이북 파일에 구성됩니다. 예제 4는 latest_prerelease_version_segment 키가 정의된 축약된 플레이북 파일을 보여줍니다.

.예제 4. 기호 사전 릴리스 버전을 정의하는 플레이북(antora-playbook.yml 파일)
[source,yaml]
----
site:
title: The Ranges
url: https://docs.example.com
urls:
latest_prerelease_version_segment: next
content: <1>
----
<1> latest_prerelease_version_segment는 urls 키 아래에 설정되고 값 next가 할당됩니다.


의미론적 및 명명된 버전 정렬 규칙에 따라 Antora는 colorado 6.0이 colorado 구성 요소의 최신 사전 릴리스 버전이라고 판단한다고 가정해 보겠습니다. 플레이북과 구성 요소 버전의 antora.yml 파일의 정보를 사용하여 Antora는 tour.adoc 페이지에 대해 다음 URL을 구성합니다.
이제 예제 5에서 버전 세그먼트에는 기호 사전 릴리스 버전 next가 포함되어 있습니다.

.예제 5. latest_prerelease_version_segment가 설정된 경우 colorado 6.0 tour.adoc 페이지의 URL
[source,text]
--
https://docs.example.com/colorado/next/get-started/tour.html
--


추가된 사전 릴리스 식별자가 있는 실제 버전 6.0-beta.2는 여전히 참조 UI 메뉴에 표시됩니다. 기호 사전 릴리스 버전 next는 URL에만 사용됩니다. 참조 UI 메뉴에 표시되는 값을 사용자 정의하려면 display_version 키를 사용하세요.
이 섹션의 예제는 latest_version_segment_strategy 키가 설정되지 않았다고 가정했습니다. 따라서 Antora는 latest_prerelease_version_segment 키를 감지하면 자동으로 latest_version_segment_strategy 키를 설정하고 런타임에 replace 전략을 할당합니다. redirect:to 및 redirect:from 전략이 latest_prerelease_version_segment 키와 어떻게 작동하는지 알아보려면 최신 버전 세그먼트 전략을 참조하세요.


== Configure Your Site - URLs Keys - Latest Version Segment Strategy

latest_version_segment_strategy 키는 실제 버전이 포함된 게시 가능한 URL과 기호 버전이 포함된 URL 간의 대체 및 리디렉션 방향을 제어합니다. 키의 이름에서 알 수 있듯이 선택한 전략은 구성 요소 버전의 최신 버전 또는 최신 사전 릴리스 버전에만 적용됩니다.
=== latest_version_segment_strategy 키
latest_version_segment_strategy 키는 선택 사항입니다. 플레이북의 urls 키 아래에 구성됩니다. latest_version_segment 키 또는 latest_prerelease_version_segment 키도 설정해야 합니다. 그렇지 않으면 Antora는 URL에서 실제 버전을 대체할 기호 버전이 없기 때문에 지정된 전략을 비활성화합니다. 지정된 전략과 기호 버전은 사이트의 각 구성 요소의 최신 버전 또는 최신 사전 릴리스 버전에만 적용됩니다. 다른 모든 구성 요소 버전의 URL은 URL의 버전 세그먼트에 실제 버전을 사용합니다.
.예제 1. antora-playbook.yml
[source,yaml]
urls:
latest_version_segment_strategy: redirect:to
latest_prerelease_version_segment: next
<1> 부모 키 urls를 입력하고 콜론(:)을 입력한 다음 Enter 키를 눌러 새 줄로 이동합니다.
<2> latest_version_segment_strategy 키는 urls 키 아래에 중첩되어야 합니다. latest_version_segment_strategy를 입력하고 콜론과 공백(: )을 입력한 다음 Antora가 사용할 기본 제공 전략 값을 입력하고 Enter 키를 누릅니다. 이 예제에서는 값 redirect:to를 사용합니다.
<3> latest_prerelease_version_segment를 입력하고 콜론과 공백(: )을 입력한 다음 기호 버전 값을 입력합니다. 이 예제에서는 최신 사전 릴리스 버전 세그먼트에 기호 버전 next를 사용합니다.
latest_version_segment_strategy 키는 다음과 같은 기본 제공 값을 받아들입니다:

redirect:from




기호 버전을 사용하는 URL에서 실제 버전(비어 있을 수 있음)을 사용하는 URL로 리디렉션을 설정합니다. 실제 버전은 latest_version_segment 키 또는 latest_prerelease_version_segment 키에 지정된 기호 버전으로 최신 구성 요소 버전의 페이지 및 자산 URL에서 대체됩니다. 이 전략은 현재 리디렉션 기능이 정적일 때 무시됩니다.

redirect:to




비어 있지 않은 실제 버전을 사용하는 URL에서 기호 버전을 사용하는 URL로 리디렉션을 설정합니다. 실제 버전은 latest_version_segment 키 또는 latest_prerelease_version_segment 키에 지정된 기호 버전으로 최신 구성 요소 버전의 페이지 및 자산 URL에서 대체됩니다. 버전이 비어 있으면 URL이 변경되지 않습니다. 리디렉션 기능이 정적일 때 이 전략은 투명하게 replace로 변경됩니다.

replace




기본값입니다. 비어 있지 않은 실제 버전은 latest_version_segment 키 또는 latest_prerelease_version_segment 키에 지정된 기호 버전으로 최신 구성 요소 버전의 페이지 및 자산 URL에서 대체됩니다. replace는 latest_version_segment_strategy 키가 설정되지 않았지만 latest_version_segment 키 또는 latest_prerelease_version_segment 키에 플레이북에서 값이 할당된 경우의 기본값입니다. 버전이 비어 있으면 URL이 변경되지 않습니다.
전략이 redirect:to 또는 redirect:from일 때 Antora는 임시 리디렉션(302)을 생성합니다. 규칙 및 리디렉션 구성 파일의 형식은 redirect_facility 키를 사용하여 지정하는 리디렉션 기능에 의해 결정됩니다. 플레이북이나 CLI에 redirect_facility 키가 정의되어 있지 않으면 Antora는 런타임에 키에 static 값을 할당합니다. 임시 리디렉션 규칙을 만드는 것은 웹 서버만 할 수 있는 일이므로 정적 리디렉션 기능을 사용할 때 redirect:from 전략은 무시되고 redirect:to 전략은 사실상 replace 전략이 됩니다.
latest_version_segment_strategy 키의 값이 redirect:from이면 latest_version_segment 및 latest_prerelease_version_segment의 값은 비어 있을 수 없습니다. 이 제한은 상위 폴더에서 리디렉션하면 다른 버전에 대한 액세스를 방지할 수 있기 때문입니다. 같은 이유로 실제 버전이 비어 있으면 redirect:to 및 replace 전략은 영향을 미치지 않습니다.
=== replace 전략 자동 활성화
replace가 선호하는 전략인 경우 플레이북에서 latest_version_segment 키 또는 latest_prerelease_version_segment 키에 값을 할당하기만 하면 latest_version_segment_strategy 키를 설정할 필요가 없습니다.
.예제 2. 런타임에 기본적으로 replace 사용
[source,yaml]
...
urls:
latest_version_segment: stable
content:
...

Antora가 예제 2의 플레이북을 읽고 latest_version_segment 키가 설정되고 값이 할당되었지만 latest_version_segment_strategy 키는 설정되지 않았음을 감지하면 Antora는 런타임에 자동으로 latest_version_segment_strategy를 설정하고 replace를 할당합니다. 마찬가지로 latest_prerelease_version_segment 키만 설정되고 값이 할당된 경우 Antora는 런타임에 자동으로 latest_version_segment_strategy를 설정하고 replace를 할당합니다.
=== 기호 버전 URL로 리디렉션
이 섹션에서는 redirect:to 전략을 사용하여 최신 구성 요소 버전의 실제 버전을 사용하는 URL을 기호 버전을 사용하는 URL로 리디렉션한 결과를 살펴봅니다. 이 섹션의 예제는 예제 3과 예제 4에 표시된 구성 요소 버전 설명자 파일에 의해 정의된 구성 요소 버전을 사용합니다. 예제 3은 구성 요소 이름이 colorado이고 버전이 5.2인 구성 요소 버전을 정의합니다.
.예제 3. colorado 5.2 구성 요소 버전을 정의하는 구성 요소 버전 설명자(antora.yml 파일)
[source,yaml]
name: colorado
version: '5.2'
<1> antora.yml의 version 키는 구성 요소의 실제 버전을 5.2로 정의합니다.
예제 4는 이름이 colorado이고 버전이 5.6인 구성 요소 버전을 정의합니다.
.예제 4. colorado 5.6 구성 요소 버전을 정의하는 구성 요소 버전 설명자(antora.yml 파일)
[source,yaml]
name: colorado
version: '5.6'
<1> antora.yml의 version 키는 구성 요소의 실제 버전을 5.6으로 정의합니다.
두 구성 요소 버전에는 get-started 모듈에 속하는 tour.adoc라는 페이지가 있습니다.
이제 최신 구성 요소 버전에 최신 버전 세그먼트 전략과 최신 버전 URL 세그먼트를 할당해 보겠습니다. 이 정보는 사이트의 플레이북 파일을 사용하여 Antora에 제공됩니다. latest_version_segment_strategy 및 latest_version_segment 키는 플레이북 파일(구성 요소 버전 설명자 파일이 아님)의 urls 키 아래에 구성됩니다. 예제 5는 플레이북 파일에 정의된 이러한 키를 보여줍니다.

.예제 5. 최신 버전 세그먼트 전략을 정의하는 플레이북(antora-playbook.yml 파일)

[source,yaml]
--
site:
title: The Ranges
url: https://docs.example.com
urls:
latest_version_segment_strategy: redirect:to
latest_version_segment: current
redirect_facility: nginx
content:
...

// <1> Antora는 최신 구성 요소 버전 URL에 대한 리디렉션 규칙을 생성할 때 redirect:to 전략을 사용합니다.
// <2> Antora는 최신 구성 요소 버전의 URL에서 실제 버전을 기호 버전 current로 대체합니다.
// <3> Antora는 nginx 리디렉션 파일을 생성하고 생성된 사이트의 루트에 .etc/nginx/rewrite.conf에 배치합니다.
--

예제 3과 예제 4가 사이트에서 유일한 구성 요소 버전이라고 가정하면 Antora는 colorado 5.6을 colorado 구성 요소의 최신 버전으로 식별합니다. Antora는 의미론적 및 명명된 버전 정렬 규칙을 기반으로 최신 구성 요소 버전과 버전 순서를 결정합니다.
예제 6에 표시된 것처럼 버전 세그먼트는 실제 버전을 사용합니다. colorado 5.2가 colorado 구성 요소의 최신 버전이 아니기 때문입니다.
.예제 6. colorado 5.2 tour.adoc 페이지의 URL
[source,text]
https://docs.example.com/colorado/5.2/get-started/tour.html
그러나 예제 7에서 버전 세그먼트는 기호 버전 current를 사용합니다. colorado 5.6이 colorado 구성 요소의 최신 버전이기 때문입니다.
.예제 7. colorado 5.6 tour.adoc 페이지의 URL
[source,text]
https://docs.example.com/colorado/current/get-started/tour.html
Antora는 최신 구성 요소 버전의 URL에서 실제 버전을 기호 버전으로 대체할 뿐만 아니라 실제 버전을 사용하는 URL에서 기호 버전을 사용하는 URL로 임시 리디렉션을 생성합니다. 예제 5의 플레이북은 redirect_facility 키에 nginx 값을 할당하므로 Antora는 리디렉션 규칙을 rewrite.conf라는 nginx 재작성 구성 파일에 작성하고 사이트의 .etc/nginx/rewrite.conf에 배치합니다. 버전이 비어 있지 않은 한 최신 구성 요소 버전의 실제 버전을 사용하는 URL에 대한 모든 요청은 기호 버전이 있는 URL로 리디렉션됩니다. 예를 들어 URL https://docs.example.com/colorado/5.6/get-started/tour.html이 요청되면 URL은 https://docs.example.com/colorado/current/get-started/tour.html로 리디렉션됩니다.
=== 새 구성 요소 버전이 사이트에 추가되면 어떻게 되나요?
이전 섹션에 제시된 시나리오를 계속 진행하면서 새 구성 요소 버전이 사이트에 추가될 때 어떤 일이 발생하는지 살펴보겠습니다. 예제 8은 이름이 colorado이고 실제 버전이 6.0인 구성 요소 버전을 정의합니다.
.예제 8. colorado 6.0 구성 요소 버전을 정의하는 구성 요소 버전 설명자(antora.yml 파일)
[source,yaml]
name: colorado
version: '6.0'
사이트는 예제 5와 동일한 플레이북을 사용합니다. 생성 중에 Antora는 colorado 구성 요소의 가장 높은 버전이 6.0이라고 판단하므로 colorado 6.0이 colorado 구성 요소의 최신 버전이 됩니다. 예제 3(colorado 5.2), 예제 4(colorado 5.6), 예제 8(colorado 6.0)에 정의된 구성 요소 버전과 예제 5의 플레이북을 사용하여 Antora는 각 구성 요소 버전의 tour.adoc 페이지에 대해 다음 URL을 구성합니다.
예제 9는 구성 요소 버전 colorado 5.2의 tour.adoc 페이지 URL이 동일하게 유지됨을 보여줍니다.
.예제 9. colorado 5.2 tour.adoc 페이지의 URL
[source,text]
https://docs.example.com/colorado/5.2/get-started/tour.html
이전 섹션의 colorado 5.6에 대한 URL과 달리 예제 10은 tour.adoc의 버전 세그먼트에 실제 버전이 포함되어 있음을 보여줍니다. colorado 5.6이 더 이상 colorado 구성 요소의 최신 버전이 아니기 때문입니다.
.예제 10. colorado 5.6 tour.adoc 페이지의 URL
[source,text]
https://docs.example.com/colorado/5.6/get-started/tour.html
Antora는 5.6이 있는 URL에서 current가 있는 URL로 임시 리디렉션을 설정하지 않습니다. https://docs.example.com/colorado/5.6/get-started/tour.html에 대한 요청은 요청된 대로 정확히 제공됩니다.
예제 11에서 버전 세그먼트는 기호 버전 current를 사용합니다. colorado 6.0이 colorado 구성 요소의 최신 버전이기 때문입니다.
.예제 11. colorado 6.0 tour.adoc 페이지의 URL
[source,text]
https://docs.example.com/colorado/current/get-started/tour.html
Antora는 최신 구성 요소 버전인 6.0의 실제 버전을 사용하는 URL에 대한 새로운 임시 리디렉션을 설정하고 이를 기호 버전이 있는 URL로 리디렉션합니다. 예를 들어 URL https://docs.example.com/colorado/6.0/get-started/tour.html이 요청되면 URL은 https://docs.example.com/colorado/current/get-started/tour.html로 리디렉션됩니다.

== Configure Your Site - URLs Keys - Redirect Facility Key

Antora는 지정한 리디렉션 기능에 따라 시작 페이지, 기호 최신 버전 및 페이지 별칭에 대한 자동 라우팅을 설정합니다.
기본적으로 Antora는 각 URL 별칭에 대해 정적 HTML 파일을 생성하여 방문자를 대상 페이지로 리디렉션합니다. Antora는 또한 웹 서버의 리디렉션/재작성 기능을 활용하여 대신 라우팅을 처리하는 웹 서버별 구성 파일을 생성할 수 있습니다.
사이트에 리디렉션이 정의되어 있지 않으면 Antora는 리디렉션 파일(예: _redirects)을 생성하지 않습니다.
Antora는 사이트 및 구성 요소 버전 시작 페이지, 최신 버전 별칭 및 page-aliases 속성을 사용하여 정의된 페이지 별칭에서 이러한 URL 경로를 파생합니다. 페이지 별칭의 경우 대상 페이지는 소스 페이지가 리디렉션되는 페이지입니다. 대상 페이지는 또한 페이지 별칭이 정의된 곳입니다. 소스 페이지는 리디렉션되는 별칭 페이지(즉, 클레임된 페이지)입니다.
=== redirect_facility 키와 해당 값
redirect_facility 플레이북 키는 선택 사항입니다. 플레이북 또는 CLI를 통해 구성할 수 있으며 다음과 같은 기본 제공 값 중 하나를 받아들입니다:

disabled




리디렉션 파일이 생성되지 않습니다. 사이트에 리디렉션이 정의되어 있지 않으면 이것이 실제 값이 됩니다.

gitlab




GitLab Pages용 리디렉션 파일인 _redirects가 생성되어 게시된 사이트의 루트에 배치됩니다.

httpd




Apache httpd용 리디렉션 파일인 .htaccess가 생성되어 게시된 사이트의 루트에 배치됩니다.

netlify




Netlify용 리디렉션 파일인 _redirects가 생성되어 게시된 사이트의 루트에 배치됩니다.

nginx




nginx용 리디렉션 파일인 rewrite.conf가 생성되어 게시된 사이트의 .etc/nginx/rewrite.conf 위치에 배치됩니다.
+
기본적으로 nginx는 이 위치에서 파일을 찾도록 알지 못합니다. nginx가 찾을 수 있는 곳으로 이동하거나 이 위치에서 사용하도록 nginx를 구성해야 합니다.

static




(기본값) http-equiv 메타 요소가 새로 고침으로 설정된 정적 HTML 파일이 소스 페이지의 URL에 생성됩니다. 파일은 리디렉션 알림을 제공하고 소스 페이지 URL을 대상 페이지 URL로 라우팅합니다.
명시적으로 구성하지 않는 한 Antora는 자동으로 static 값을 redirect_facility 키에 할당합니다.
=== 플레이북에서 리디렉션 기능 구성
redirect_facility 키는 플레이북의 urls 키 아래에 구성됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
urls:
redirect_facility: netlify
=== CLI에서 리디렉션 기능 구성
redirect_facility 키는 CLI에서도 구성할 수 있습니다.
[source,bash]
antora --redirect-facility netlify antora-playbook.yml
CLI 옵션은 플레이북에 지정된 값을 재정의합니다.
=== 리디렉션 기능 구성 선택
사이트의 URL 리디렉션을 구성하는 방법은 사이트를 제공하는 데 사용하는 웹 서버 또는 서비스에 따라 달라집니다.
기본 리디렉션 기능을 사용하면 Antora는 HTML의 메타 새로 고침 기능을 사용하여 방문자를 대상 페이지로 라우팅하는 HTML 페이지를 생성합니다(즉, 바운스 페이지). 사이트의 출력을 검사하면 최소한의 HTML 구조 내에 <meta http-equiv="refresh"> 태그가 포함된 .html로 끝나는 페이지를 찾을 수 있습니다. 사이트의 시작 페이지를 지정한 경우 게시된 사이트의 루트에 index.html 페이지가 포함됩니다.
다른 리디렉션 기능을 사용하면 Antora는 이러한 바운스 페이지를 생성하지 않습니다. (즉, 게시된 사이트의 루트에서 index.html 페이지를 찾을 수 없습니다). 대신 Antora는 웹 서버가 생성하는 리디렉션 규칙을 적용하도록 합니다. 이러한 규칙 및 작성 위치에 대한 자세한 내용은 아래 섹션을 참조하세요.
시작 페이지 및 페이지 별칭에 대한 리디렉션 규칙은 리디렉션이 영구적인 것으로 간주되는 301 HTTP 상태 코드를 사용하여 정의됩니다. 최신 버전 별칭에 대한 리디렉션 규칙은 리디렉션이 일시적인 것으로 간주되는 302 HTTP 상태 코드를 사용하여 정의됩니다.
웹 서버별 리디렉션/재작성 규칙의 위치는 사이트에서 액세스되는 페이지의 URL과 일치하므로 urls.html-extension-style 키의 값에 따라 달라집니다. 기본적으로 위치는 .html로 끝납니다. HTML URL 확장자 스타일이 indexify로 변경되면 위치는 /로 끝납니다.
==== Netlify
Netlify에서 제공하는 사이트에 대한 리디렉션 규칙은 _redirects라는 일반 텍스트 파일에 구성됩니다. 할당된 리디렉션 기능 값이 netlify인 경우 Antora는 _redirects 파일을 생성하여 생성된 사이트의 루트에 배치합니다.
.예제 2. Antora에 의해 생성된 Netlify용 _redirects 파일
[source,text]
/index.html /component/version/index.html 301!
/ /component/version/index.html 301!
/component/version/module/old-name.html /component/version/module/new-name.html 301!
위 예제 출력은 두 가지 시나리오에 대한 리디렉션 규칙을 보여줍니다. 첫 번째 시나리오는 첫 번째 두 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 루트 도메인에서 사이트 시작 페이지의 URL로 사용자를 라우팅합니다. 두 번째 시나리오는 마지막 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 이름이 변경된 페이지의 URL에서 새 URL로 사용자를 라우팅합니다.
==== GitLab
GitLab Pages에서 제공하는 사이트에 대한 리디렉션 규칙은 _redirects라는 일반 텍스트 파일에 구성됩니다. 이 파일의 형식은 Netlify용 파일의 수정된 버전입니다. 할당된 리디렉션 기능 값이 gitlab인 경우 Antora는 _redirects 파일을 생성하여 생성된 사이트의 루트에 배치합니다.
.예제 3. Antora에 의해 생성된 GitLab Pages용 _redirects 파일
[source,text]
/index.html /component/version/index.html 301
/ /component/version/index.html 301
/component/version/module/old-name.html /component/version/module/new-name.html 301
<1> netlify 리디렉션 기능의 리디렉션 파일과 달리 규칙이 !로 끝나지 않습니다.
위 예제 출력은 두 가지 시나리오에 대한 리디렉션 규칙을 보여줍니다. 첫 번째 시나리오는 첫 번째 두 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 루트 도메인에서 사이트 시작 페이지의 URL로 사용자를 라우팅합니다. 두 번째 시나리오는 마지막 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 이름이 변경된 페이지의 URL에서 새 URL로 사용자를 라우팅합니다.
==== nginx
Antora는 rewrite.conf라는 nginx 재작성 구성 파일을 생성하여 생성된 사이트의 .etc/nginx/rewrite.conf에 배치합니다.
.예제 4. Antora에 의해 생성된 nginx 재작성 구성 파일
[source,nginx]
location = /index.html { return 301 /component/version/index.html; }
location = /component/version/module/old-name.html { return 301 /component/version/module/new-name.html; }
위 예제 출력은 두 가지 시나리오에 대한 리디렉션 규칙을 보여줍니다. 첫 번째 시나리오는 첫 번째 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 루트 도메인에서 사이트 시작 페이지의 URL로 사용자를 라우팅합니다. 두 번째 시나리오는 마지막 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 이름이 변경된 페이지의 URL에서 새 URL로 사용자를 라우팅합니다.
nginx 리디렉션 기능을 사용할 때 Antora는 nginx가 예제 5와 유사한 방식으로 구성되었다고 가정합니다. /srv/www 경로는 생성된 사이트의 위치를 나타냅니다.
.예제 5. Antora에 의해 생성된 재작성 구성을 로드하는 nginx 구성
[source,nginx]
server {
listen       80;
server_name  _;
root         /srv/www;
location = /.etc/nginx/rewrite.conf {
deny    all;
return  404;
}
include /srv/www/.etc/nginx/rewrite.conf;
location / {
index  index.html;
# uncomment the next line if using --html-url-extension-style=drop
#try_files $uri $uri.html $uri/index.html = 404;
}
error_page  404  /404.html;
}
사이트가 다른 호스트 이름이나 포트에서 액세스할 수 있거나 다른 루트에서 제공되는 경우 구성을 조정하세요.
==== httpd
Antora는 리디렉션 규칙이 포함된 .htaccess 파일을 생성하여 생성된 사이트의 루트에 배치합니다.
.예제 6. Antora에 의해 생성된 .htaccess 파일
[source,apache]
Redirect 301 /index.html /component/version/index.html
Redirect 301 /component/version/module/old-name.html /component/version/module/new-name.html
위 예제 출력은 두 가지 시나리오에 대한 리디렉션 규칙을 보여줍니다. 첫 번째 시나리오는 첫 번째 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 루트 도메인에서 사이트 시작 페이지의 URL로 사용자를 라우팅합니다. 두 번째 시나리오는 마지막 규칙으로 처리되며 301 HTTP 상태 코드를 사용하여 이름이 변경된 페이지의 URL에서 새 URL로 사용자를 라우팅합니다.
httpd 리디렉션 기능을 사용할 때 Antora는 Apache httpd가 호스팅된 사이트의 루트에 있는 .htaccess 파일을 로드하도록 구성되었다고 가정합니다.
==== 정적(메타 새로 고침)
정적 리디렉션 값은 GitLab Pages 및 GitHub Pages와 같이 URL 리디렉션 구성 파일을 수락하거나 제공하지 않는 서비스에 배포된 사이트에 유용합니다. 이 설정은 또한 로컬 머신에서 사이트를 빌드하여 시작 페이지와 페이지 별칭을 테스트할 때 도움이 됩니다.
Antora는 별칭 소스 페이지마다 방문자를 해당 대상 페이지로 리디렉션하는 정적 메타 새로 고침 페이지를 생성합니다. 각 새로 고침 페이지에는 다음이 포함됩니다:

대상 페이지의 정식 URL.
refresh 값이 할당된 http-equiv 메타 속성.
0과 방문자가 리디렉션될 상대 대상 페이지의 URL이 할당된 content 메타 속성. 0은 방문자가 0초 후에 대상 페이지로 리디렉션됨을 나타냅니다.
소스 페이지가 더 이상 존재하지 않으며 대상 페이지에 대한 링크를 제공한다는 리디렉션 알림.

.예제 7. new-name.html로 리디렉션하는 old-name.html에 대한 정적 메타 새로 고침 페이지
[source,html]
----
<!DOCTYPE html>
<meta charset="utf-8">
<link rel="canonical" href="https://base-url.com/component/version/module/new-name.html">
<script>location="new-name.html"</script>
<meta http-equiv="refresh" content="0; url=new-name.html">
<meta name="robots" content="noindex">
<title>Redirect Notice</title>
<h1>Redirect Notice</h1>
<p>The page you requested has been relocated to <a href="new-name.html">https://base-url.com/component/version/module/new-name.html</a>.</p>
----



== Configure Your Site - Output Keys

output 아래에 구성된 플레이북 키는 사이트 파일이 작성되는 위치를 정의하고 처리 방식을 제어합니다.
=== output 키
output 키에는 공통 출력 설정과 대상 사양 목록이 포함됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
----
output:
clean: true
dir: ./public
destinations:

provider: archive
path: ./public/blue.zip


<1> 선택적 output 키
<2> 선택적 clean 키
<3> 선택적 dir 키
<4> 선택적 destinations 키
<5> 선택적 provider 키
<6> 선택적 path 키
----

output 키와 이 키가 받아들일 수 있는 키-값 쌍은 선택 사항입니다. output이 플레이북에 설정되지 않은 경우 Antora는 기본적으로 fs 프로바이더를 사용하고 사이트를 출력 디렉터리 build/site에 게시합니다.
=== destinations 및 provider 키
output 키는 destinations 키와 중첩된 키-값 쌍 목록을 받아들입니다. 사이트 파일을 아카이브로 게시하거나 사용자 정의 프로바이더를 사용하거나 사이트를 여러 대상에 게시하려는 경우 destinations 키가 필요합니다.
destinations 키는 Antora가 사이트를 게시하는 데 사용할 프로바이더와 생성된 파일을 저장할 위치를 지정하는 사양 목록을 받아들입니다. destinations가 설정된 경우 그 아래에 하나 이상의 provider 키를 정의해야 합니다.
프로바이더는 Antora가 사이트를 게시할 때 사용해야 하는 전송 프로토콜(로컬, SSH, HTTP 등)을 결정하고 게시의 저수준 세부 사항을 관리합니다. Antora에는 두 가지 내장 프로바이더인 fs(파일 시스템)와 archive(ZIP 아카이브)가 있습니다. provider는 SSH, S3 등과 같은 사용자 정의 프로바이더에 위임하는 데 사용할 수 있는 확장 지점이기도 합니다.
==== 사이트 게시 비활성화
기본 출력 디렉터리를 포함하여 사이트 파일 게시를 완전히 비활성화하려면 destinations를 빈 배열([])로 설정하세요.
=== 사용 가능한 출력 키
[cols="1,3,1", options="header"]
|===
| 출력 키 | 설명 | 필수
| clean, destinations[n].clean
| true로 설정하면 clean 키는 사이트를 생성하기 전에 출력 디렉터리 또는 파일 시스템 프로바이더 경로를 재귀적으로 제거합니다.
| 아니오
| destinations[n].path
| 출력 파일이 작성되는 대상 위치를 지정합니다. 파일 시스템 프로바이더 및 경로와 아카이브 프로바이더 및 경로를 참조하세요.
| 아니오
| destinations[n].provider
| Antora가 사이트를 게시하는 데 사용하는 전송 프로토콜을 지정합니다. 내장된 fs 또는 archive 값을 받아들입니다. 사용자 정의 프로바이더도 지정할 수 있습니다. destinations 아래에 여러 프로바이더를 지정할 수 있습니다.
| 아니오
| dir
| 사이트가 기본 프로바이더 또는 destinations 아래에 지정된 첫 번째 fs 프로바이더를 사용하여 게시될 때 출력 디렉터리를 지정합니다.
| 아니오
|===



== Configure Your Site - Output Keys - Output Directory

dir 키는 생성된 사이트 파일이 게시되는 디렉터리를 지정합니다. 더 정식적인 destinations 및 provider 키를 설정하지 않고도 기본 fs 프로바이더를 사용할 수 있는 간단한 방법을 제공합니다.
=== 기본 출력 디렉터리
기본 출력 디렉터리는 build/site입니다. dir이 설정되지 않고 fs 프로바이더 path가 지정되지 않은 경우 사이트 파일은 이 기본 디렉터리에 작성됩니다.
=== dir 키
dir 키는 플레이북의 output 키 아래에 구성됩니다. dir 키는 생성된 사이트 파일이 게시되는 디렉터리를 지정합니다. 이 키는 상대 또는 절대 파일 시스템 경로를 받아들입니다. 상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

첫 번째 경로 세그먼트가 틸드(~)인 경우 나머지 경로는 사용자의 홈 디렉터리를 기준으로 확인됩니다.
첫 번째 경로 세그먼트가 점(.)인 경우 나머지 경로는 플레이북 파일의 위치를 기준으로 확인됩니다.
첫 번째 경로 세그먼트가 틸드 다음에 바로 더하기 기호(~+)이거나 앞서 언급한 접두사로 시작하지 않는 경우 나머지 경로는 현재 작업 디렉터리를 기준으로 확인됩니다.

dir 키는 destinations 키와 함께 사용할 수 있습니다. fs 프로바이더 path와 dir 모두 지정된 경우 dir에 할당된 값이 첫 번째 fs 프로바이더 경로를 재정의합니다. --to-dir 옵션을 사용하여 출력 디렉터리를 CLI에서 지정하면 플레이북의 dir과 첫 번째 fs 프로바이더 path도 재정의합니다.
==== 상대 경로 지정
예제 1에서는 사이트가 플레이북 파일을 기준으로 launch라는 폴더에 게시됩니다.
.예제 1. dir 키에 상대 경로 할당
[source,yaml]
output:
dir: ./launch
==== 절대 경로 지정
예제 2에서는 플레이북이 어디에 있든 상관없이 사이트가 home/dev/docs-site/beta에 게시됩니다.
.예제 2. dir 키에 절대 경로 할당
[source,yaml]
output:
dir: /home/dev/docs-site/beta
=== 출력 디렉터리 정리
clean 키는 선택 사항이며 기본적으로 비활성화(값 false 할당)되어 있습니다. 플레이북에서 값 true가 할당되면 사이트를 생성하기 전에 dir에 할당된 경로를 재귀적으로 제거합니다.
.예제 3. clean 키 활성화
[source,yaml]
output:
clean: true
<1> clean은 값 true로 활성화되고 false로 비활성화됩니다.
이 키는 파일 시스템 프로바이더에만 적용됩니다.
이 키를 조심스럽게 사용하세요. 예를 들어 dir을 home 디렉터리로 설정하고 clean을 true로 설정하면 home의 모든 폴더와 파일이 삭제됩니다.
clean 키는 --clean 옵션을 사용하여 CLI를 통해서도 활성화할 수 있습니다.



== Configure Your Site - Output Keys - Archive Provider

사이트의 파일을 ZIP 아카이브로 게시하려면 플레이북에 output, destinations 및 provider 키를 설정해야 합니다.

=== archive 프로바이더

provider 값 archive는 사이트를 ZIP 파일로 게시합니다.

.예제 1. antora-playbook.yml [source,yaml]
output:
destinations:

provider: archive
<1> provider 키는 destinations 키 아래에 구성되어야 합니다.
<2> destinations 아래에 하이픈(-)과 공백을 입력한 다음 키 이름 provider를 입력하고 콜론(:)을 입력합니다. 콜론 뒤에 공백을 입력한 다음 기본 제공 값 이름 archive를 입력합니다.

path 키가 지정되지 않는 한 archive 프로바이더의 기본 출력 대상은 build/site.zip입니다.

=== path 키

선택적 path 키는 생성된 ZIP 아카이브의 대상 경로와 파일 이름을 지정합니다. path가 지정되지 않으면 Antora는 기본 아카이브 경로 값 build/site.zip을 사용합니다.

path 키는 상대 또는 절대 파일 시스템 경로를 받아들입니다. 프로바이더는 필요에 따라 모든 중간 디렉터리를 생성합니다. 상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

첫 번째 경로 세그먼트가 틸드(~)인 경우 나머지 경로는 사용자의 홈 디렉터리를 기준으로 확인됩니다.
첫 번째 경로 세그먼트가 점(.)인 경우 나머지 경로는 플레이북 파일의 위치를 기준으로 확인됩니다.
첫 번째 경로 세그먼트가 틸드 다음에 바로 더하기 기호(~+)이거나 앞서 언급한 접두사로 시작하지 않는 경우 나머지 경로는 현재 작업 디렉터리를 기준으로 확인됩니다.
==== 상대 경로 지정

예제 2에서는 사이트가 플레이북 파일을 기준으로 대상 파일 blue.zip에 게시됩니다.

.예제 2. path 키에 상대 경로 할당 [source,yaml]
output:
destinations:

provider: archive path: ./blue.zip
==== 절대 경로 지정

예제 3에서는 플레이북이 어디에 있든 상관없이 사이트가 /home/user/projects/launch/blue.zip에 게시됩니다.

.예제 3. path 키에 절대 경로 할당 [source,yaml]
output:
destinations:

provider: archive path: /home/user/projects/launch/blue.zip
=== 여러 대상에 게시

예제 4에서 Antora는 tmp 디렉터리의 플레이북 파일에서 실행되며 상대 경로와 절대 경로의 두 위치에 사이트를 게시합니다.

.예제 4. 여러 프로바이더 지정 [source,yaml]
output:
destinations:

provider: fs path: ./releases/red clean: true
provider: archive path: /home/user/projects/docs-site/blue.zip
fs를 사용하여 게시된 사이트 파일은 tmp/releases/red 디렉터리에 작성됩니다. clean 키가 true로 할당되었으므로 이 디렉터리는 게시 전에 제거됩니다. 사이트는 archive 프로바이더에 의해 /home/user/projects/docs-site/blue.zip에 아카이브로도 게시됩니다.



== Configure Your Site - Output Keys - Filesystem Provider

하나 이상의 파일 시스템 대상을 포함하여 여러 대상에 사이트를 게시하려면 플레이북에 output, destinations 및 provider 키를 설정해야 합니다.
=== fs 프로바이더
provider 값 fs는 사이트를 파일 시스템의 디렉터리에 게시합니다. dir 키를 사용하여 출력 디렉터리를 지정하는 것과 동일한 공식적인 기능입니다.
.예제 1. antora-playbook.yml
[source,yaml]
----
output:
destinations:

provider: fs


<1> provider 키는 destinations 키 아래에 구성되어야 합니다.
<2> destinations 아래에 하이픈(-)과 공백을 입력한 다음 키 이름 provider를 입력하고 콜론(:)을 입력합니다. 콜론 뒤에 공백을 입력한 다음 기본 제공 값 이름 fs를 입력합니다.
----

path 키나 dir 키가 지정되지 않는 한 fs 프로바이더의 기본 경로는 build/site입니다.

=== path 키

선택적 path 키는 출력 파일이 작성될 대상 위치를 지정합니다. fs 프로바이더는 이 값을 대상 디렉터리로 처리합니다.
path 키는 상대 또는 절대 파일 시스템 경로를 받아들입니다. 프로바이더는 필요에 따라 모든 중간 디렉터리를 생성합니다. 상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

첫 번째 경로 세그먼트가 틸드(~)인 경우 나머지 경로는 사용자의 홈 디렉터리를 기준으로 확인됩니다.
첫 번째 경로 세그먼트가 점(.)인 경우 나머지 경로는 플레이북 파일의 위치를 기준으로 확인됩니다.
첫 번째 경로 세그먼트가 틸드 다음에 바로 더하기 기호(~+)이거나 앞서 언급한 접두사로 시작하지 않는 경우 나머지 경로는 현재 작업 디렉터리를 기준으로 확인됩니다.

path가 지정되지 않으면 기본값 build/site 또는 첫 번째 fs 프로바이더의 경우 dir의 값으로 채워집니다. dir 키가 지정되면 해당 값이 첫 번째 fs 프로바이더 path에 할당(또는 재정의)됩니다. --to-dir 옵션을 사용하여 출력 디렉터리를 CLI에서 지정하면 플레이북의 첫 번째 fs 프로바이더 path(dir뿐만 아니라)도 재정의합니다.

==== 상대 경로 지정
예제 2에서는 사이트가 플레이북 파일을 기준으로 launch라는 폴더에 게시됩니다.

.예제 2. 상대 경로 할당
[source,yaml]
----
output:
destinations:

provider: fs
path: ./launch
----

==== 절대 경로 지정
예제 3에서는 플레이북이 어디에 있든 상관없이 사이트가 home/dev/site/beta에 게시됩니다.
.예제 3. 절대 경로 할당
[source,yaml]
----
output:
destinations:

provider: fs
path: /home/dev/site/beta
----

=== clean 키
clean 키는 선택 사항이며 기본적으로 비활성화(값 false 할당)되어 있습니다. output 키 바로 아래가 아니라 fs 프로바이더 구성의 일부로 적용할 수 있습니다.
.예제 4. antora-playbook.yml
[source,yaml]
----
output:
destinations:

provider: fs
path: /home/dev/site/beta
clean: true


<1> clean은 값 true로 활성화되고 false로 비활성화됩니다.
----

clean에 값 true가 할당되면 사이트를 생성하기 전에 대상 path를 재귀적으로 제거합니다. 이 키는 fs 프로바이더에만 적용됩니다.
이 키를 조심스럽게 사용하세요. 예를 들어 path를 home 디렉터리로 설정하고 clean을 true로 설정하면 home의 모든 폴더와 파일이 삭제됩니다.
=== 여러 대상에 게시
예제 5에서 Antora는 tmp 디렉터리의 플레이북 파일에서 실행되며 상대 경로와 절대 경로의 두 위치에 사이트를 게시합니다.
.예제 5. 여러 프로바이더 지정
[source,yaml]
output:
destinations:

provider: fs
path: ./releases/red
clean: true
provider: archive
path: /home/user/projects/docs-site/blue.zip


fs를 사용하여 게시된 사이트 파일은 tmp/releases/red 디렉터리에 작성됩니다. clean 키가 true로 할당되었으므로 이 디렉터리는 게시 전에 제거됩니다. 사이트는 archive 프로바이더에 의해 /home/user/projects/docs-site/blue.zip에 아카이브로도 게시됩니다.


== Configure Your Site - Output Keys - Custom Provider

=== 사용자 정의 출력 제공자 사용
provider 키가 인식된 기본 제공자를 지정하지 않으면 Antora는 이를 Node.js 모듈로 요구하려고 시도합니다. 이를 통해 사용자 정의 제공자를 제공할 수 있습니다.
값이 점(.)으로 시작하는 경우 Antora는 플레이북 파일을 기준으로 상대 경로를 요구합니다. 그렇지 않으면 Antora는 플레이북 프로젝트에 설치된 Node.js 모듈로 값을 요구합니다.
사용자 정의 제공자는 다음 시그니처와 일치하는 JavaScript 함수입니다.
[source,js]
async function (destConfig, files, playbook)
다음은 시작하는 데 사용할 수 있는 템플릿입니다.
예제 1. custom-output-provider.js
[source,js]
'use strict'
module.exports = async function (destConfig, files, playbook) {
const to = destConfig.path || '_site'
console.log(Publishing files to ${to})
for await (const file of files) {
console.log(Writing file to ${file.path})
}
return {}
}
destConfig 인수는 대상 사양의 속성에 해당하는 키-값 쌍을 포함하는 객체입니다. files 인수는 가상 파일의 ReadableStream입니다(for await를 사용하여 반복). 각 파일은 contents, path 및 stat 속성을 포함하는 Vinyl 객체입니다. playbook 인수는 전체 플레이북에서 키-값 쌍을 포함하는 객체입니다.



== Configure Your Site - Runtime Keys

=== runtime 키
Antora의 로거, 콘솔 출력, 캐싱 및 원격 저장소 업데이트 동작을 관리하는 플레이북 키는 runtime 키 아래에 구성됩니다.
=== runtime 키
전역 로그, 콘솔 출력, 가져오기 및 캐시 디렉터리 속성은 플레이북 파일의 runtime 키 아래에 정의됩니다. 이러한 설정은 Antora 파이프라인이 시작될 때 적용됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
runtime:
cache_dir: ./.cache/antora
fetch: true
log:
level: error

선택적 runtime 키
선택적 cache_dir 키
선택적 fetch 키
선택적 log 키
선택적 level 키

runtime 키와 이것이 허용하는 키-값 쌍은 선택 사항입니다. 플레이북에 runtime이 설정되지 않은 경우 Antora는 기본 캐시 디렉터리, 가져오기 및 로그 설정을 사용합니다. 또는 이러한 키는 CLI에서 할당하거나 fetch를 제외하고 환경 변수를 사용하여 할당할 수 있습니다.
=== log 키
log 키는 선택 사항입니다. 플레이북에서 설정하는 경우 runtime 키 아래에 중첩해야 합니다. log 키는 로그 레벨(level), 실패 레벨(failure_level) 및 표시 형식(format)을 구성하는 기본 제공 키-값 쌍 목록을 허용합니다.
.예제 2. antora-playbook.yml
[source,yaml]
runtime:
log:
format: json
failure_level: warn
level: all
level_format: number
destination:
file: ./antora.log
append: true
buffer_size: 4096
sync: false

선택적 log 카테고리 키는 runtime 카테고리 키 아래에 중첩됩니다.
선택적 format 키는 log 카테고리 키 아래에 중첩됩니다.
선택적 failure_level 키는 log 카테고리 키 아래에 중첩됩니다.
선택적 level 키는 log 카테고리 키 아래에 중첩됩니다.
선택적 level_format 키는 log 카테고리 키 아래에 중첩됩니다.
선택적 destination 카테고리 키는 log 카테고리 키 아래에 중첩됩니다.
선택적 file 키는 destination 카테고리 키 아래에 중첩됩니다.
선택적 append 키는 destination 카테고리 키 아래에 중첩됩니다.
선택적 buffer_size 키는 destination 카테고리 키 아래에 중첩됩니다.
선택적 sync 키는 destination 카테고리 키 아래에 중첩됩니다.

level, failure_level, format 또는 level_format이 플레이북에 설정된 경우 log 카테고리 키 아래에 중첩되어야 합니다. level, failure_level, format 및 level_format 키에는 플레이북 또는 해당 명령줄 옵션이나 환경 변수를 사용하여 명시적으로 정의되지 않은 경우 Antora가 실행될 때 자동으로 적용되는 기본값이 있습니다.
file, append, buffer_size 또는 sync가 플레이북에 설정된 경우 destination 카테고리 키 아래에 중첩되어야 합니다.
Antora가 플레이북을 완전히 구성하기 전에 치명적인 오류가 발생하면 로그 설정이 적용되지 않습니다. 이러한 경우 오류 메시지는 사전 구성된 로거를 사용하여 표준 오류(stderr)에만 직접 출력됩니다.
=== 사용 가능한 런타임 키
|===
|런타임 키 |설명 |필수
|cache_dir
|원격 콘텐츠 소스 Git 저장소와 UI 번들이 캐시되는 디렉터리를 지정합니다.
|No
|fetch
|true로 설정하면 fetch 키는 Antora가 실행될 때마다 캐시의 파일을 새로 고칩니다.
|No
|log.failure_level
|충족되거나 초과될 때 Antora가 0이 아닌 종료 코드로 실패하도록 하는 로그 레벨 허용 오차를 설정합니다. warn, error, fatal 및 none 값을 허용합니다. 기본값은 fatal입니다. none 값은 Antora가 항상 0 종료 코드로 종료되도록 합니다.
|No
|log.format
|로그 메시지의 형식을 설정합니다. pretty와 json 값을 허용합니다. 기본값은 CI 환경에서는 json이고 다른 모든 환경에서는 pretty입니다.
|No
|log.level
|메시지가 로깅되려면 충족해야 하는 최소 심각도 임계값 레벨을 설정합니다. all, debug, info, warn, error, fatal 및 silent 값을 허용합니다. 기본값은 warn입니다. silent 값은 로거를 끕니다.
|No
|log.level_format
|로그 레벨이 표현되는 방식의 형식을 설정합니다. log.format이 json인 경우에만 적용됩니다. label과 number 값을 허용합니다. 기본값은 label입니다.
|No
|log.destination.file
|로그 메시지가 기록되는 대상 파일 또는 스트림을 설정합니다. 기본값(stdout 또는 stderr)은 로그 형식에 따라 다릅니다.
|No
|log.destination.append
|파일에 쓰기 전에 파일을 자를지(즉, 지울지) 여부를 구성합니다. 기본값은 false이며, 이는 파일을 자른다는 것을 의미합니다.
|No
|log.destination.buffer_size
|로그 메시지를 버퍼링하는 데 사용할 메모리 양을 설정합니다. 버퍼가 이 크기에 도달하면 버퍼링된 메시지가 일괄적으로 대상에 기록됩니다. 기본값은 0이며, 이는 이 동작을 끈다는 것을 의미합니다.
|No
|log.destination.sync
|로그 메시지를 대상에 쓰는 데 동기 또는 비동기 작업을 사용할지 여부를 구성합니다. 기본값은 true이며, 이는 로그 메시지가 동기적으로(차단하여) 기록된다는 것을 의미합니다.
|No
|===



== Configure Your Site - Runtime Keys - Log Keys

== Configure Your Site - Runtime Keys - Log Keys - Log Severity Level

log level 키는 debug 또는 error와 같은 심각도 임계값을 지정하며, 메시지가 로깅되려면 이 임계값을 충족해야 합니다.
=== 기본 로그 레벨
level 키에 값을 명시적으로 할당하는 것은 선택 사항입니다. 플레이북에 설정되지 않았거나 --log-level 옵션 또는 ANTORA_LOG_LEVEL 변수를 사용하여 지정되지 않은 경우, Antora는 런타임에 warn 값을 키에 할당합니다. 기본값이 적용되면 warn 임계값을 충족하거나 초과하는 모든 메시지가 로깅됩니다.
=== level 키
level 키는 플레이북의 runtime과 log 키 아래에 구성됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
runtime:
log:
level: error
level 키는 다음과 같은 내장 값을 허용합니다:

fatal
Antora를 갑자기 종료하도록 강제하는 치명적인 오류입니다. 사이트가 생성되지 않았습니다.
Antora가 플레이북을 구성하기 전에 치명적인 오류가 발생하면, Antora는 메시지를 표준 오류(STERR)로만 출력합니다. 오류 메시지는 사용자가 구성한 로거를 통해 라우팅되지 않습니다.
error
중요한 작업이 발생하지 않았거나 성공적으로 완료되지 않았음을 나타내는 심각한 문제입니다. 오류가 Antora를 종료하지 않을 수 있지만, 사이트가 예상대로 생성되거나 게시되지 않았을 가능성이 높습니다.
warn
기본값. 누락된 AsciiDoc 속성, 플레이북 또는 구성 요소 구성과 같은 잘못된 AsciiDoc 구문과 생성된 사이트의 사용성, 성능 또는 모양에 영향을 미칠 가능성이 있는 기타 문제점 또는 특이한 상황입니다.
info
Antora의 정상 작동과 이정표를 강조하는 정보성 메시지입니다.
debug
Antora의 활동, 이벤트, 경고 및 오류가 발생한 상황에 대한 자세한 컨텍스트를 제공하는 진단 메시지입니다. 이 레벨은 경고 또는 오류에 대한 추가 정보가 필요할 때 유용합니다.
all
Antora의 작업과 해당 작업의 결과에 대한 모든 정보와 세부 사항이 기록됩니다.
silent
로거가 꺼지고 메시지가 로깅되지 않습니다.

심각도 임계값을 충족하거나 초과하는 메시지가 로깅됩니다. 심각도 임계값을 충족하지 않는 메시지는 보고되지 않습니다.
=== 로그 레벨 지정
예제 2에 표시된 플레이북에서 level 키에 info 값을 할당해 보겠습니다.
.예제 2. level 키에 info 심각도 임계값 할당
[source,yaml]
runtime:
log:
level: info
플레이북 파일에서 부모 키 runtime을 입력하고 콜론(:)을 입력한 다음 Enter 키를 누릅니다. log 키는 runtime의 자식입니다. 키의 이름인 log를 입력하고 콜론(:)을 입력한 다음 Enter 키를 누릅니다. level 키는 log의 자식입니다. level을 입력하고 콜론과 공백(: )을 입력한 다음 info 값을 입력합니다.
Antora가 실행되고 level에 info가 할당되면 info 임계값을 충족하거나 초과하는 메시지가 로깅됩니다. info 심각도 수준을 충족하지 않는 메시지는 보고되지 않습니다.
=== 로그 레벨 옵션
플레이북 파일을 직접 수정하지 않고도 CLI에서 --log-level 옵션을 사용하여 level 키를 설정할 수 있습니다.
[source,console]
$ antora --log-level=debug antora-playbook.yml
--log-level 옵션은 level 키 또는 ANTORA_LOG_LEVEL 환경 변수에 할당된 값을 재정의합니다.



== Configure Your Site - Runtime Keys - Log Keys - Log Failure Level

failure_level 키는 충족되거나 초과될 때 Antora가 0이 아닌(즉, 실패) 종료 코드로 종료되도록 하는 심각도 임계값을 지정합니다.
명확히 하자면, 이 설정은 Antora의 실행을 중지시키지 않습니다. 오히려 Antora가 실행 중인 프로세스의 종료 코드 값에만 영향을 미칩니다. 대부분의 CI 환경에서 그러하듯이 이 값을 해석하는 것은 쉘에 달려 있습니다.
=== 기본 실패 레벨
failure_level 키에 값을 명시적으로 할당하는 것은 선택 사항입니다. 플레이북에 설정되지 않았거나 --log-failure-level 옵션 또는 ANTORA_LOG_FAILURE_LEVEL 변수를 사용하여 지정되지 않은 경우, Antora는 런타임에 fatal 값을 키에 할당합니다. 로그된 메시지가 fatal 심각도 임계값을 충족하면 Antora는 0이 아닌 종료 코드로 종료됩니다.
=== failure_level 키
failure_level 키는 플레이북의 runtime과 log 키 아래에 구성됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
runtime:
log:
failure_level: error
이 키는 다음과 같은 내장 값을 허용합니다:

fatal (기본값)
error
warn
none

이러한 값은 Antora가 로그 메시지에 할당하는 심각도 수준에 해당합니다. 값이 none인 경우를 제외하고, failure_level에 할당된 값을 충족하거나 초과하는 메시지가 로그되면 Antora는 0이 아닌 종료 코드로 종료됩니다. 값이 none이면 처리되지 않은 오류가 발생해도 Antora는 항상 0 종료 코드로 종료됩니다. Antora의 로거가 꺼져 있으면 failure_level 키와 해당 값이 적용되지 않습니다.
=== 0 종료 코드 강제
failure_level 키에 none 값이 할당되면 치명적인 오류가 발생하더라도 Antora는 항상 종료 코드 0으로 종료됩니다.
=== 실패 레벨 지정
예제 2에 표시된 플레이북에서 failure_level 키에 warn 값을 할당해 보겠습니다.
.예제 2. failure_level 키에 warn 심각도 임계값 할당
[source,yaml]
runtime:
log:
failure_level: warn
Antora는 치명적인 오류가 발생하지 않는 한 사이트 생성을 완료하고, warn 이상의 심각도로 메시지가 로그되면 0이 아닌 종료 코드로 종료됩니다. 경고, 오류 또는 치명적인 메시지가 로그되지 않으면 Antora는 0 종료 코드로 종료됩니다. 즉, 사이트가 오류나 잠재적인 문제 없이 성공적으로 빌드되었습니다!
=== 로그 실패 레벨 옵션
또는 CLI에서 --log-failure-level 옵션을 사용하여 실패 임계값을 할당할 수 있습니다.
[source,console]
$ antora --log-failure-level=warn antora-playbook.yml
--log-failure-level 옵션은 failure_level 키 또는 ANTORA_LOG_FAILURE_LEVEL 환경 변수에 할당된 값을 재정의합니다.


== Configure Your Site - Runtime Keys - Log Keys - Log Format

log format 키는 로그 메시지의 형식을 지정합니다.
Antora가 플레이북을 완전히 구성하기 전에 치명적인 오류가 발생하면 로그 형식과 다른 모든 로그 설정이 적용되지 않습니다. 대신 오류 메시지가 표준 오류(STDERR)로 직접 출력됩니다.
=== 기본 로그 형식
format 키에 값을 명시적으로 할당하는 것은 선택 사항입니다. format이 설정되지 않은 경우 Antora는 런타임에 감지된 환경을 기준으로 키의 허용 값인 json 또는 pretty 중 하나를 할당합니다. 지속적 통합 환경(CI=true)에서 Antora가 실행 중이거나, IS_TTY 환경 변수가 true이거나, 터미널이 대화형(TTY)이고 IS_TTY 환경 변수가 false가 아닌 경우 Antora는 format 키에 pretty 값을 할당합니다. 다른 모든 경우에는 Antora가 json 값을 사용합니다.
=== format 키
format 키는 플레이북의 runtime과 log 키 아래에 구성됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
runtime:
log:
format: json
format 키는 다음과 같은 내장 값을 허용합니다:

json
CI 환경 변수가 설정되지 않은 경우(CI 환경 변수에서 실행되지 않음), IS_TTY=false 또는 터미널이 대화형이 아닌 경우 기본값입니다. 구조화된 로그 메시지는 JSON 형식으로 표준 출력 스트림(STDOUT)으로 내보내므로 다른 애플리케이션으로 파이프하고 처리할 수 있습니다. 출력은 JSON Lines(jsonl) 텍스트 형식(Newline delimited JSON 또는 ndjson이라고도 함)을 준수합니다. 각 메시지는 UTF-8 인코딩을 사용하여 자체 줄에 출력되며 각 줄은 유효한 JSON 값입니다. 메시지 레벨은 기본적으로 error, info 등의 레이블로 표현됩니다. log.level_format 키를 설정하고 number 값을 할당하여 레벨 형식을 숫자로 변경할 수 있습니다.
pretty
CI=true, IS_TTY=true 또는 터미널이 대화형인 경우 기본값입니다. 로그 메시지는 가독성을 위해 형식이 지정되고 표준 오류 스트림(STDERR)으로 내보내집니다.

format 키는 --log-format 옵션 또는 ANTORA_LOG_FORMAT 변수를 사용하여 지정할 수도 있습니다.
=== CI 환경 변수
Netlify, GitHub Actions, GitLab CI 등과 같은 지속적 통합(CI) 환경은 일반적으로 지속적 통합 환경 변수(CI)를 true로 설정합니다. Antora는 이 환경 변수를 사용하여 CI 환경에서 실행 중인 시기를 결정하고 그에 따라 동작을 변경합니다.
=== 예쁘게 꾸민 형식
형식이 지정된 로그 메시지를 내보내려면 플레이북의 format 키에 pretty 값을 할당합니다.
.예제 2. format 키에 pretty 값 할당
[source,yaml]
runtime:
log:
format: pretty
이제 Antora를 실행하면 로그 메시지가 STDERR로 내보내집니다. Antora는 색상 사용에 스마트하려고 합니다. Antora가 STDERR과 같은 표준 스트림에 로그 메시지를 작성할 때 터미널이 색상을 지원하면 예쁘게 꾸민 로그 메시지에 색상을 적용합니다.
터미널에서 Antora를 실행하면 형식이 지정된 로그 메시지가 거기에 표시됩니다. 예제 3은 xref 오류에 대한 예쁘게 꾸민 로그 메시지(색상 없음)를 보여줍니다.
.예제 3. pretty 형식을 사용하여 로그 메시지 출력
[source]
[16:03:00.691] ERROR (asciidoctor): target of xref not found: a-page.adoc
file: /home/computer/my-projects/project/docs/modules/module-name/pages/index.adoc:54
source: /home/computer/my-projects/project (refname: my-branch <worktree>, start path: docs)
오류가 발생하는 줄 번호를 표시하려면 sourcemap 키를 설정합니다.
Antora를 실행할 때 NO_COLOR 환경 변수를 설정하여 Antora가 예쁘게 꾸민 로그 메시지에 색상을 적용하지 않도록 할 수 있습니다.
[source,console]
NO_COLOR=1 antora antora-playbook.yml
NO_COLOR 환경 변수가 설정되어 있으면 터미널의 기능에 관계없이 Antora는 로그 메시지에 색상을 적용하지 않습니다. 터미널에서 색상 지원이 감지되지 않더라도 Antora가 색상을 적용하도록 강제하려면 대신 FORCE_COLOR 환경 변수를 설정하십시오(예: FORCE_COLOR=1).
=== JSON
JSON 형식의 구조화된 로그 메시지를 내보내려면 플레이북의 format 키에 json 값을 할당합니다.
.예제 4. format 키에 json 값 할당
[source,yaml]
runtime:
log:
format: json
Antora가 실행되면 모든 로그 메시지가 STDOUT로 내보내집니다. 예제 5는 xref 오류에 대한 구조화된 로그 메시지를 보여줍니다.
.예제 5. JSON으로 로그 메시지 출력
[source,json]
{"level":"error","time":1627682525543,"name":"asciidoctor","file":{"path":"/home/computer/my-projects/project/docs/modules/module-name/pages/index.adoc","line":54},"source":{"url":"https://gitlab.com/org/project.git","worktree":"/home/computer/my-projects/project","refname":"my-branch","startPath":"docs"},"msg":"target of xref not found: a-page.adoc"}
구조화된 로그 메시지는 일련의 키-값 쌍으로 구성됩니다. 각 키는 level과 같은 로그 메시지 필드를 나타내고 각 값은 error와 같은 해당 필드에 대한 로깅 정보를 기록합니다.
=== JSON 메시지 처리
JSON 형식의 메시지는 별도의 애플리케이션으로 전달하거나 구문 분석, 검색 및 분석을 위해 로그 수집 서비스로 전송할 수 있습니다. JSON 메시지를 다루는 데 널리 사용되는 도구는 jq입니다. jq는 JSON 프로세서이며, JSON 메시지를 선택, 필터링 및 재구성하는 명령줄 도구입니다.
다음은 Antora에서 생성된 JSON 형식의 로그 메시지를 jq로 파이프하는 방법을 보여주는 예제입니다.
[source,console]
antora antora-playbook.yml | jq
예제 6은 읽기 쉽도록 jq로 파이프된 xref 오류에 대한 구조화된 로그 메시지의 결과를 보여줍니다.
.예제 6. jq로 파이프된 로그 메시지 출력
[source,json]
{
"level": "error",
"time": 1627683497637,
"name": "asciidoctor",
"file": {
"path": "/home/user/projects/project/docs/modules/module-name/pages/index.adoc",
"line": 54
},
"source": {
"url": "https://gitlab.com/org/project.git",
"worktree": "/home/user/projects/project",
"refname": "my-branch",
"startPath": "docs"
},
"msg": "target of xref not found: a-page.adoc"
}
jq를 사용하여 메시지를 필터링할 수도 있습니다. 예를 들어 다른 모든 오류는 무시하고 Asciidoctor의 xref 오류만 보려는 경우 jq 명령에 select 필터를 추가할 수 있습니다.
[source,console]
antora --log-level=error antora-playbook.yml | 
jq 'select(.name == "asciidoctor" and (.msg | contains(" not found:")))'
사이트의 일부만 빌드하고 있고 "오프사이트" 페이지에 대한 경고를 필터링하려는 경우 jq 명령에 ignore 필터를 추가할 수 있습니다.
[source,console]
antora antora-playbook.yml | 
jq 'select(.msg | contains(" not found: missing-component-name:") | not)'
추가 메시지를 선택하거나 무시하기 위해 여러 번 jq로 파이프할 수 있습니다. select 함수를 사용하는 방법에 대해 자세히 알아보려면 select 함수의 참조 설명서를 참조하십시오.
jq의 결과 집합을 예쁘게 꾸민 형식으로 표시하려면 해당 결과를 pino-pretty로 파이프할 수 있습니다. pino-pretty는 Antora의 종속성이므로 npx를 사용하여 호출할 수 있습니다.
[source,console]
antora antora-playbook.yml | jq -cM | npx pino-pretty
-c 옵션은 jq에게 출력을 JSON 라인 형식으로 유지하도록 지시하고 -M 옵션은 pino-pretty로 전달되는 데이터의 색상을 끕니다. 예쁘게 꾸민 메시지는 Antora가 생성하는 출력만큼 예쁘지는 않지만 pino-pretty를 사용자 정의하여 유사한 결과를 얻을 수 있습니다.
=== 로그 형식 옵션
플레이북 파일을 직접 수정하지 않고도 CLI에서 --log-format 옵션을 사용하여 format 키를 설정할 수 있습니다.
[source,console]
antora --log-format=json antora-playbook.yml
--log-format 옵션은 format 키 또는 ANTORA_LOG_FORMAT 환경 변수에 할당된 값을 재정의합니다.
그러나 출력을 다른 프로그램으로 파이프하고 로그 형식이 지정되지 않은 경우 Antora는 자동으로 JSON 형식으로 전환합니다.
=== level_format 키
로그 형식이 JSON(json)인 경우 각 로그 레벨은 레이블과 숫자에 상관관계가 있습니다. JSON 형식은 기본적으로 레벨을 error 또는 info와 같은 레이블로 표현합니다. 그러나 일부 도구에서는 레벨이 숫자여야 합니다. 레벨의 형식은 level_format 키로 구성할 수 있습니다. level_format 키는 플레이북의 runtime과 log 키 아래에 구성됩니다.
.예제 7. level_format 키에 number 값 할당
[source,yaml]
runtime:
log:
format: json
level_format: number
level_format 키는 label과 number의 내장 값을 허용합니다. 기본값은 label입니다. 로그 형식이 pretty인 경우 level_format 키에 할당된 값은 무시되고 레벨은 항상 레이블로 표현됩니다.
=== 레벨 형식 옵션
플레이북 파일을 직접 수정하지 않고도 CLI에서 --log-level-format 옵션을 사용하여 level_format 키를 설정할 수 있습니다.
[source,console]
antora --log-format=json --log-level-format=number antora-playbook.yml
--log-level-format 옵션은 level_format 키 또는 ANTORA_LOG_LEVEL_FORMAT 환경 변수에 할당된 값을 재정의합니다.



== Configure Your Site - Runtime Keys - Log Keys - Log Destination

runtime.log 카테고리 아래의 destination 카테고리는 Antora가 로그 메시지를 기록하는 위치를 제어할 수 있는 키를 제공합니다. Antora가 메시지를 표준 스트림 또는 파일에 기록하도록 구성할 수 있습니다. 또한 Antora가 이러한 로그 메시지를 작성하는 시기와 방법을 제어할 수 있습니다.
=== 기본 대상
기본 대상 파일은 로그 형식과 연관되어 있습니다. 로그 형식이 pretty이면 기본 대상은 표준 오류 스트림(stderr)입니다. 로그 형식이 json이면 기본 대상은 표준 출력 스트림(stdout)입니다. 어느 경우든 메시지는 터미널의 출력에 나타납니다.
file 키를 사용하면 Antora가 선택하는 표준 스트림을 제어하거나 Antora가 로그 메시지를 로컬 파일로 라우팅하도록 구성할 수 있습니다.
=== file 키
file 키는 플레이북의 log 카테고리 키의 destination 카테고리 키 아래에 구성됩니다. file 키는 선택 사항입니다. 이 키의 값은 로컬 파일에 대한 경로, 표준 출력 스트림의 값 stdout(또는 1) 또는 표준 오류 스트림의 값 stderr(또는 2)일 수 있습니다.
.예제 1. antora-playbook.yml
[source,yaml]
runtime:
log:
destination:
file: ./antora.log
이 키가 설정되면 로그 형식에 관계없이 기본 대상 대신 지정된 대상이 사용됩니다.
file에 대한 해상도 규칙은 플레이북의 다른 경로와 동일합니다. 상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

첫 번째 경로 세그먼트가 물결표(~)인 경우 나머지 경로는 사용자의 홈 디렉터리에 상대적으로 해석됩니다.
첫 번째 경로 세그먼트가 점(.)인 경우 나머지 경로는 플레이북 파일의 위치에 상대적으로 해석됩니다.
첫 번째 경로 세그먼트가 물결표 다음에 바로 더하기 기호(~+)이거나 앞서 언급한 접두사로 시작하지 않는 경우 나머지 경로는 현재 작업 디렉터리에 상대적으로 해석됩니다.

file 키의 값이 표준 스트림이 아닌 로컬 파일의 경로이고 로그 형식이 pretty인 경우 메시지에 색상이 지정되지 않습니다. 로그 메시지를 파일로 라우팅하면 더 이상 터미널에서 해당 메시지를 볼 수 없다는 점에 유의하십시오. Antora가 해당 파일에 로그 메시지를 기록했는지 확인하려면 로그 파일을 확인해야 합니다.
기본적으로 Antora는 파일에 쓰기 전에 파일을 자릅니다. append 키를 사용하여 이 동작을 변경할 수 있습니다.
=== append 키
append 키는 플레이북의 log 카테고리 키의 destination 카테고리 키 아래에 구성됩니다. append 키는 선택 사항입니다. 이 키의 값은 true 또는 false일 수 있습니다. 기본적으로 값은 false입니다. 값을 true로 설정하면 Antora는 파일에 쓰기 전에 파일을 자르지(즉, 지우지) 않습니다. 즉, Antora의 이전 실행에서 로그 메시지가 보존됩니다.
.예제 2. antora-playbook.yml
[source,yaml]
runtime:
log:
destination:
file: ./antora.log
append: true
이 키는 file 키가 로컬 파일의 경로로 지정된 경우에만 관련이 있습니다.
기본적으로 Antora는 로그 메시지를 대상에 즉시 작성합니다. buffer_size 및 sync 키를 사용하여 이 동작을 제어할 수 있습니다.
=== buffer_size 키
buffer_size 키는 플레이북의 log 카테고리 키의 destination 카테고리 키 아래에 구성됩니다. buffer_size 키는 선택 사항입니다. 이 키의 값은 0 또는 양의 정수일 수 있습니다. 값은 버퍼링할 바이트 수를 나타냅니다(예: 4096은 4K).
기본적으로 값은 0이며, 이는 Antora가 로그 메시지를 버퍼링하지 않음을 의미합니다. 값이 0보다 크면 Antora는 지정된 바이트 크기에 도달할 때까지 로그 메시지를 일괄 처리합니다. 버퍼링된 로그 메시지의 상주 크기가 이 값을 충족하거나 초과하면 Antora는 버퍼를 대상으로 플러시합니다.
.예제 3. antora-playbook.yml
[source,yaml]
runtime:
log:
destination:
buffer_size: 4096
로그 메시지를 파일로 라우팅하는 경우 buffer_size 키는 과도한 수의 쓰기를 방지하는 방법을 제공합니다. 일반적으로 Antora를 실행할 때 리소스 문제가 발생하는 경우에만 이 키를 사용하면 됩니다.
sync 키는 쓰기를 제어하는 추가 방법을 제공합니다.
=== sync 키
sync 키는 플레이북의 log 카테고리 키의 destination 카테고리 키 아래에 구성됩니다. sync 키는 선택 사항입니다. 이 키의 값은 true 또는 false일 수 있습니다. 기본적으로 값은 true이며, 이는 Antora가 동기 작업을 사용하여 대상에 쓴다는 것을 의미합니다. 값을 false로 설정하면 Antora는 비동기 작업을 사용하여 대상에 쓰도록 전환합니다. 즉, Node.js 프로세스가 I/O 작업을 수행할 수 있는 다음에 로그 메시지가 기록됩니다.
.예제 4. antora-playbook.yml
[source,yaml]
runtime:
log:
destination:
file: ./antora.log
sync: false
sync 키를 false로 설정하면 로그 이벤트가 쓰기를 완료하기 위해 프로그램을 일시 중지하는 것을 방지합니다. 대신 이러한 쓰기는 대기열에 넣어지고 Node.js 프로세스가 유휴 상태일 때(예: 네트워크 작업을 수행 중일 때) 다음에 수행됩니다. 즉, 쓰기는 자연스럽게 일괄 처리됩니다. 사이트 생성으로 인해 많은 로그 메시지가 생성되는 경우 이를 통해 Antora가 더 최적으로 수행할 수 있습니다.
sync 키와 buffer_size 키를 결합하여 로그 메시지 쓰기가 지연되는 정도를 최대화할 수 있습니다.


== Configure Your Site - Runtime Keys - Fetch Updates

원격 콘텐츠 소스 저장소 및 UI 번들 스냅샷에서 업데이트를 검색할 때마다 fetch 키를 사용하십시오.
=== Fetch 작업
플레이북 또는 CLI에서 fetch 키를 활성화하면 Antora가 실행될 때마다 다음 두 가지 작업을 모두 수행합니다:

Antora가 복제한 모든 원격 콘텐츠 소스 저장소에 대해 fetch 작업을 실행하거나, 그렇지 않으면 복제합니다.
이미 다운로드되었더라도 UI 번들이 스냅샷으로 표시된 경우 원격 UI 번들을 다운로드합니다.

Antora는 복제본이 Antora에 의해 관리되기 때문에 원격 콘텐츠 소스에 대한 업데이트만 가져옵니다. Antora는 로컬 콘텐츠 소스(즉, 로컬 Git 저장소)에 대한 업데이트를 가져오지 않습니다. 즉, Antora는 로컬 Git 저장소에서 git fetch 또는 git pull을 실행하지 않습니다. 그렇게 하면 저장소를 비일관된 상태로 만들거나 작성자의 작업을 방해할 위험이 있습니다. Antora는 로컬 콘텐츠 저장소의 상태 관리를 작성자에게 맡깁니다.
=== fetch 키
Antora가 플레이북을 처음 실행할 때 원격 콘텐츠 소스 Git 저장소를 복제하고 UI 번들을 Antora 캐시 디렉터리에 다운로드합니다. 이후 실행에서 Antora는 캐시 폴더에서 이러한 리소스를 해결하여 효과적으로 오프라인으로 실행합니다.
선택적 fetch 키를 true로 설정하여 Antora에게 캐시를 새로 고치도록 지시할 수 있습니다. fetch 키는 플레이북의 runtime 키 아래에 구성됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
runtime:
fetch: true
=== Fetch 옵션
플레이북 파일을 직접 수정하지 않고도 CLI에서 --fetch 옵션을 사용하여 이 키를 설정할 수 있습니다.
[source,console]
$ antora --fetch antora-playbook.yml
--fetch 옵션은 플레이북 파일에서 fetch 키에 할당된 값을 재정의합니다.



== Configure Your Site - Runtime Keys - Cache Directory

Antora가 처음 실행될 때 원격 콘텐츠 소스 Git 저장소와 UI 번들을 캐시합니다. 이후 실행에서 Antora는 캐시 폴더에서 이러한 리소스를 해결하여 효과적으로 오프라인으로 실행합니다.
=== 기본 캐시 디렉터리
cache_dir 키를 사용하여 대체 위치를 구성하지 않는 한 원격 리소스는 Antora의 기본 캐시 위치에 저장됩니다. 캐시의 기본 위치는 운영 체제에 따라 다릅니다.
.Linux

$XDG_CACHE_HOME/antora 또는 $XDG_CACHE_HOME이 설정되지 않은 경우 $HOME/.cache/antora

.macOS

$HOME/Library/Caches/antora

.Windows

$APPDATA/antora/Caches

Antora는 원격 리소스를 다운로드하기 전에 먼저 캐시 폴더에서 리소스를 찾습니다. 캐시를 업데이트하려면 Antora가 업데이트를 가져오도록 구성하십시오. 다른 옵션은 시스템에서 Antora 캐시 디렉터리를 찾아 수동으로 삭제하는 것입니다.
=== cache_dir 키
선택적 cache_dir 키는 플레이북의 runtime 키 아래에 구성됩니다. cache_dir은 원격 저장소를 복제하고 원격 UI 번들을 다운로드해야 하는 디렉터리를 지정합니다. 상대 또는 절대 파일 시스템 경로를 허용합니다.
.예제 1. antora-playbook.yml
[source,yaml]
runtime:
cache_dir: ./.cache/antora
이 경우 값은 플레이북 파일의 위치를 기준으로 .cache/antora 폴더로 확인됩니다. ./로 시작하기 때문에 확인된 위치가 플레이북 파일에 상대적임을 알 수 있습니다.
cache_dir에 대한 해상도 규칙은 플레이북의 다른 경로와 동일합니다. 상대 경로는 다음 규칙을 사용하여 절대 경로로 확장됩니다:

첫 번째 경로 세그먼트가 물결표(~)인 경우 나머지 경로는 사용자의 홈 디렉터리에 상대적으로 해석됩니다.
첫 번째 경로 세그먼트가 점(.)인 경우 나머지 경로는 플레이북 파일의 위치에 상대적으로 해석됩니다.
첫 번째 경로 세그먼트가 물결표 다음에 바로 더하기 기호(~+)이거나 앞서 언급한 접두사로 시작하지 않는 경우 나머지 경로는 현재 작업 디렉터리에 상대적으로 해석됩니다.

캐시 디렉터리는 --cache-dir 옵션을 사용하거나 ANTORA_CACHE_DIR 변수를 사용하여 CLI에서 구성할 수도 있습니다.


== Configure Your Site - Network Keys

=== network 키
network 아래에 구성된 플레이북 키는 Antora에서 시작한 네트워크 요청을 제어합니다. 현재 이러한 요청에는 콘텐츠 집계기의 Git 클라이언트와 UI 로더의 HTTP 클라이언트에서 수행한 요청이 포함됩니다.
대부분의 경우 사용자는 플레이북에 정의하는 대신 이 카테고리의 키에 매핑된 환경 변수(http_proxy, https_proxy 및 no_proxy)를 사용하기로 선택합니다. 그러나 플레이북이나 매핑된 CLI 옵션을 통해 이러한 설정을 지정할 수 있다는 점은 Antora 실행마다 이러한 설정을 제어할 수 있는 가능성을 제공합니다. 환경 변수는 플레이북 파일에 정의된 키보다 우선하지만 해당 키에 대한 CLI 옵션에 의해 재정의됩니다.
=== network 키
network 키는 프록시 설정과 같은 네트워크 관련 플레이북 키를 보유합니다.
.예제 1. antora-playbook.yml
[source,yaml]
network:
http_proxy: github.com
https_proxy: github.com
no_proxy: gitlab.com

선택적 network 카테고리 키
HTTP 요청을 라우팅할 선택적 http_proxy 키
HTTPS 요청을 라우팅할 선택적 https_proxy 키
프록시를 우회해야 하는 HTTP 또는 HTTPS 도메인 요청에 대한 선택적 no_proxy 키

network 카테고리 키와 이것이 허용하는 하위 키는 모두 선택 사항입니다. network 키가 플레이북에 없고(환경 변수를 통해 설정되지 않은 경우) Antora는 HTTP 요청에 대한 기본 모드를 사용하는 것으로 대체합니다.
=== 사용 가능한 네트워크 키
|===
|Git 키 |설명 |필수
|http_proxy
|HTTP 요청을 라우팅할 URL(예: http://localhost:3128)을 허용합니다. 설정된 경우 http_proxy 환경 변수의 값을 따릅니다.
|No
|https_proxy
|HTTPS 요청을 라우팅할 URL(예: http://localhost:3128)을 허용합니다. 설정된 경우 https_proxy 환경 변수의 값을 따릅니다.
|No
|no_proxy
|프록시되지 않아야 하는 HTTP 또는 HTTPS 요청의 쉼표로 구분된 도메인 목록을 허용합니다. 프록시를 완전히 우회하려면 값을 *로 설정하십시오. 설정된 경우 no_proxy 환경 변수의 값을 따릅니다.
|No
|===



== Configure Your Site - Network Keys - Network Proxy

플레이북의 네트워크 프록시 관련 키의 목적은 일반적인 기업 환경에서와 같이 HTTP/HTTPS 프록시 뒤에서 Antora를 사용할 수 있도록 하는 것입니다. 현재 이러한 키의 영향을 받는 요청에는 콘텐츠 집계기의 Git 클라이언트와 UI 로더의 HTTP 클라이언트에서 수행한 요청이 포함됩니다.
=== 자동 구성
기본적으로 Antora는 설정된 경우 업계 표준 http_proxy, https_proxy 및 no_proxy 환경 변수를 따릅니다. 즉, 플레이북 파일에 이러한 키가 설정되지 않았더라도 Antora가 네트워크 요청을 자동으로 프록시할 수 있습니다. 이는 Antora 2에서 동작의 주목할 만한 변화를 반영합니다.
http_proxy 및 https_proxy 환경 변수는 Antora가 각각 HTTP 및 HTTP 요청을 라우팅해야 하는 URL을 지정합니다. no_proxy 환경 변수를 사용하면 특정 도메인 또는 하위 도메인에 대한 요청이 프록시를 우회할 수 있습니다(즉, 제외).
이 접근 방식을 사용하면 다른 URL에 대해 다른 프록시를 구성할 수 없습니다. 유일한 URL 별 구성은 no_proxy를 사용하여 특정 도메인 또는 하위 도메인에 대한 프록시를 비활성화하는 것입니다.
이러한 환경 변수를 준수함으로써 Antora는 애플리케이션 수준에서 설정을 수정하지 않고도 프록시로 작업하기 위한 네트워크 프로그래밍의 표준 계약을 이행하고 있습니다. 이것은 네트워크 기반 소프트웨어가 개발되는 계약입니다. 이러한 환경 변수가 설정되었을 때 여전히 연결을 할 수 없다면 IT 문제입니다.
환경 변수를 사용하지 않고 프록시 설정을 구성해야 하는 경우에만 플레이북 파일에 지정해야 합니다. 그렇다면 계속 읽어보십시오.
=== http_proxy 키
http_proxy 키는 HTTP 요청을 라우팅할 URL을 허용합니다. URL에는 프로토콜(http 또는 https), 도메인(루트 도메인 또는 하위 도메인) 및 포트만 포함되어야 합니다. 설정하면 Antora에서 수행하는 모든 HTTP 요청이 이 URL을 통해 라우팅됩니다.
.예제 1. antora-playbook.yml
[source,yaml]
network:
http_proxy: http://localhost:3128
프록시 URL의 프로토콜이 원본 URL의 프로토콜과 일치하지 않아도 됩니다.
=== https_proxy 키
https_proxy 키는 HTTPS 요청을 라우팅할 URL을 허용합니다. URL에는 프로토콜(http 또는 https), 도메인(루트 도메인 또는 하위 도메인) 및 포트만 포함되어야 합니다. 설정하면 Antora에서 수행하는 모든 HTTPS 요청이 이 URL을 통해 라우팅됩니다.
.예제 2. antora-playbook.yml
[source,yaml]
network:
https_proxy: http://localhost:3128
프록시 URL의 프로토콜이 원본 URL의 프로토콜과 일치하지 않아도 됩니다.
=== no_proxy 키
no_proxy 키는 프록시 제외를 지정합니다. 이러한 제외는 쉼표로 구분된 도메인 또는 하위 도메인 목록으로 표현됩니다. 요청의 URL이 이러한 값 중 하나와 일치하면 URL의 프로토콜(http 또는 https)에 대해 프록시가 구성되어 있더라도 프록시를 통해 라우팅되지 않습니다.
.예제 3. antora-playbook.yml
[source,yaml]
network:
no_proxy: gitlab.com,github.com
모든 요청에 대해 프록시를 끄려면 이 값을 *로 설정하십시오.
.예제 4. antora-playbook.yml
[source,yaml]
network:
no_proxy: '*'
Antora 2는 http_proxy 및 https_proxy 환경 변수를 따르지 않았습니다. Antora 2에서 Antora 3으로 마이그레이션하는 경우 네트워크 오류(Bad response: 503)가 발생하면 Antora 3의 자동 프록시 지원이 원인일 수 있습니다. 프록시가 Antora가 엔드포인트에 연결하는 것을 방해하는 경우 no_proxy 키를 사용하여 프록시를 우회해야 할 수 있습니다. 플레이북을 수정하지 않으려면 CLI 옵션을 사용하여 이 키를 지정할 수 있습니다.
[source,console]
$ antora --noproxy '*' antora-playbook.yml
그러나 이것이 필요한 경우 프록시가 요청을 라우팅하지 못하는 이유를 이해하는 것이 좋습니다.



== Configure Your Site - Use Author Mode

Antora의 주요 기능은 게시를 위한 사이트를 생성하는 것이지만 작성자를 위한 도구로도 사용됩니다. 플레이북을 구성하여 로컬 저장소를 사용하도록 Antora를 구성하면 커밋하지 않은 콘텐츠를 포함하여 로컬 콘텐츠를 미리 볼 수 있습니다.
=== 작성자 모드 활성화
하나 이상의 콘텐츠 저장소에 로컬 복제본을 사용하도록 플레이북을 구성할 때 작성자 모드가 활성화됩니다. Antora는 원격 위치에서 복제하는 대신 로컬 시스템에 있는 저장소를 사용합니다. 이 시나리오에서는 이미 저장소를 복제했으며 사이트 생성에 통합하려는 것으로 가정합니다.
시작하려면 프로젝트에 workspace라는 폴더를 만듭니다.
[source,console]
mkdir workspace
새로 만든 디렉터리로 전환하고 저장소 중 하나를 복제합니다:
[source,console]
git clone https://github.com/my-antora-demo/server-docs workspace/server-docs
다음으로 로컬에서 사용할 플레이북 파일의 복사본을 만듭니다. 아래 예제에서는 antora-playbook.yml이 복사되고 새 파일 이름은 local-antora-playbook.yml입니다.
[source,console]
cp antora-playbook.yml local-antora-playbook.yml
다음으로 새 플레이북 파일을 열고 원격 저장소 대신 복제된 저장소를 사용하도록 구성합니다. 플레이북 파일을 기준으로 상대 경로 또는 절대 경로로 저장소를 지정할 수 있습니다.

.예제 1. local-antora-playbook.yml
[source,yaml]
----
content:
sources:

url: ./workspace/server-docs
branches: HEAD


<1> 작성자 모드에서는 일반적으로 로컬 저장소의 현재 체크 아웃된 HEAD를 사용하려고 합니다.
----

새 플레이북 파일을 사용하여 Antora 사이트를 빌드합니다.

[source,console]
antora local-antora-playbook.yml
로컬 저장소의 내용이 파이프라인에 통합됩니다.
workspace 디렉터리가 플레이북 저장소 내에 있는 경우 원격으로 푸시하지 않도록 .gitignore 파일에 추가하는 것이 가장 좋습니다.
=== 여러 작업 트리 사용
이전 섹션에서는 단일 작업 트리로 로컬 저장소를 사용하도록 Antora를 구성하는 방법을 배웠습니다. 저장소에 단일 콘텐츠 브랜치만 있는 경우 이 설정은 잘 작동합니다. 그러나 여러 브랜치로 작업하기 시작하면 단일 작업 트리를 사용하는 것이 이상적이지 않습니다. 다른 구성 요소 버전의 파일을 읽거나 업데이트해야 할 때마다 브랜치를 전환해야 하므로 버전 간에 파일을 셔플하기가 매우 어려워집니다. 여기서 여러 작업 트리가 작동합니다.
로컬 Git 저장소는 여러 작업 트리를 지원할 수 있습니다. 로컬 저장소의 위치는 여전히 기본 작업 트리 역할을 합니다. git worktree 명령을 사용하면 각각 별도의 브랜치에 매핑되는 추가 작업 트리를 저장소와 연결할 수 있습니다. 새 작업 트리를 연결된 작업 트리라고 합니다. 기본 작업 트리와 별개의 디렉터리에 있습니다. 즉, 단일 저장소에 대해 한 번에 둘 이상의 브랜치를 효과적으로 체크 아웃할 수 있습니다.
이 기능을 활성화한 경우 Antora는 로컬 콘텐츠 소스에 연결된 연결된 작업 트리를 인식하고 플레이북에 지정된 브랜치 패턴 중 하나와 일치하면 해당 작업 트리를 사용합니다. 이 기능을 활성화하려면 Antora 플레이북의 콘텐츠 소스 항목에 worktrees: true를 추가합니다.
여러 작업 트리로 로컬 콘텐츠 소스를 설정하려면 다음 단계를 따르십시오:

플레이북 저장소를 복제합니다.
Git가 복제를 위해 만든 폴더에 workspace라는 폴더를 만듭니다.
workspace 폴더로 전환하고 콘텐츠 저장소의 작업 트리를 보관할 다른 폴더를 만듭니다(예: workspace/software-with-docs). (이것은 Git 저장소가 아님을 유의하세요.)
해당 폴더로 전환합니다.
콘텐츠 저장소를 main 폴더(또는 기본 브랜치 이름)에 복제합니다(예: git clone https://github.com/my-antora-demo/server-docs main).
해당 폴더로 전환합니다.
이제 git worktree를 사용하여 편집하려는 각 브랜치에 대한 작업 트리를 만듭니다. 예를 들면 git worktree add ../6.0 6.0입니다. git worktree add에 대한 첫 번째 인수는 작업 트리의 위치이고 두 번째 인수는 브랜치의 이름입니다. 일반적으로 브랜치의 이름을 사용하여 작업 트리 폴더의 이름을 지정합니다.
이제 플레이북 저장소(antora-playbook.yml이 있는 위치)로 돌아가서 이전 섹션에서 설명한 대로 local-antora-playbook.yml이라는 작성자 플레이북을 열고 필요한 경우 생성합니다.
플레이북 파일에서 콘텐츠 저장소의 URL을 workspace 내부의 복제된 저장소를 가리키도록 변경합니다(예: ./workspace/software-with-docs/main). Antora를 기본 작업 트리로 가리켜야 하며 연결된 작업 트리 중 하나로 가리키면 안 됩니다.
동일한 콘텐츠 소스 항목에서 worktrees: true를 추가하여 작업 트리 기능을 활성화합니다.
작업하려는 각 콘텐츠 저장소에 대해 3-10단계를 반복합니다.

이제 Antora가 브랜치를 스캔할 때 연결한 작업 트리를 자동으로 검색하고 (Git 트리에서 읽는 대신) 작업 트리에서 파일을 읽습니다. 이 설정을 사용하면 플레이북 저장소를 홈 베이스로 사용하고 작성을 위해 그 아래에 모든 콘텐츠 저장소와 브랜치를 구성할 수 있습니다.
플레이북 저장소에서 이 작성 환경 설정 프로세스를 자동화하는 스크립트를 만들 수 있습니다.
Git 작업 트리와 사용 방법에 대해 자세히 알아보려면 Git 문서의 git-worktree 페이지를 참조하십시오.

=== 작성자 모드 작업 순서

저장소가 로컬일 때 생성기가 어떤 브랜치를 선택하는지, 커밋되지 않은 변경 사항을 선택하는지 궁금할 수 있습니다. 로컬 저장소가 처리되는 방식은 다음과 같습니다:

로컬 시스템의 저장소 내용이 원격 저장소 위치의 내용 대신 사용됩니다.
로컬 저장소는 원격 저장소 위치에서 업데이트되지 않습니다. Antora는 작성자가 저장소를 관리한다고 가정합니다(필요에 따라 저장소에서 명시적으로 git fetch 또는 git pull을 호출).

작성자 모드에서 브랜치가 선택되는 방식은 다음과 같습니다:

원격 url과 연결된 로컬 브랜치와 원격 브랜치가 모두 고려됩니다.
로컬 브랜치의 이름이 원격 브랜치와 동일한 경우 로컬 브랜치가 선택됩니다.
작업 트리의 내용이 현재 브랜치의 파일 대신 사용됩니다. 이름 외에는 현재 브랜치가 효과적으로 무시됩니다.
작업 트리의 현재 브랜치는 url 항목에 구성된 branches 필터와 일치해야 합니다. 그렇지 않으면 작업 트리가 무시됩니다. 예약된 HEAD 값을 사용하여 현재 작업 트리가 항상 사용되도록 할 수 있습니다.
여러 작업 트리를 사용하려면 저장소를 여러 번 복제하고 플레이북에 여러 항목을 구성하면 됩니다. branches 키를 사용하여 원하지 않는 브랜치의 이름을 필터링할 수 있습니다.


== Configure Your Site - Use an Existing Playbook Project

이 페이지는 이미 Antora를 사용하는 문서 프로젝트에 참여하는 사람들을 위한 것입니다.
플레이북은 일반적으로 플레이북 프로젝트에 위치합니다. 플레이북 프로젝트 저장소는 문서 사이트 생성을 담당합니다. 이것은 엄격히 코드로서의 구성 저장소입니다. 콘텐츠는 포함하지 않습니다. 대신 플레이북 파일과 특정 상황에서 추가 UI 파일 및 확장 코드를 포함합니다.
Antora로 사이트를 생성하려면 먼저 사이트의 플레이북 프로젝트를 가져와야 합니다.
=== 플레이북 프로젝트 가져오기
시작하려면 터미널을 열고 Git을 사용하여 플레이북 프로젝트를 복제합니다.
[source,console]
$ git clone your-playbook-repo && cd "basename $_"
이 명령은 기존 플레이북 프로젝트를 복제한 다음 프로젝트 폴더로 전환합니다.
프로젝트에 package-lock.json 파일이 포함된 경우 Antora를 로컬로 설치하도록 요청하는 것입니다. 이렇게 하려면 다음 명령을 실행하십시오.
[source,console]
$ npm ci
Antora가 로컬로 설치되면 antora 대신 npx antora를 사용하여 Antora를 실행합니다. npx 명령은 플레이북 프로젝트 내부 또는 플레이북 프로젝트의 상위 디렉터리에 설치된 antora 명령을 찾습니다.
=== 더 알아보기

Antora를 실행하여 사이트를 생성합니다.
사이트 속성이나 사이트의 콘텐츠 소스를 구성하려면 플레이북을 수정하십시오.



== Configure Your Site - Environment Variables

Antora는 플레이북의 키에 매핑되는 여러 환경 변수를 인식합니다. 이러한 환경 변수는 플레이북 파일을 수정하지 않고도 다양한 환경에 맞게 Antora를 구성하는 데 사용할 수 있습니다.
=== 환경 변수란 무엇인가요?
환경 변수는 터미널에서 지속적인 변수(즉, key=value 쌍)로, 프롬프트에서 실행하는 모든 명령에서 사용할 수 있습니다. 이 기능을 사용하면 명령이 실행 중인 환경에 따라 명령의 동작을 변경할 수 있습니다. 예를 들어, 지속적 통합(CI) 또는 게시 환경에서 환경 변수를 사용하여 기본적으로 활성화되지 않을 수 있는 동작을 활성화할 수 있습니다.
echo 명령을 사용하여 환경 변수의 현재 값을 출력할 수 있습니다. Linux 또는 macOS 터미널에서 다음을 입력하십시오.
[source,console]
$ echo $PATH
Windows 명령 프롬프트에서 다음을 입력하십시오.
[source,console]
$ echo %PATH%
Windows Powershell에서는 다음을 입력하십시오.
[source,console]
$ echo $env:PATH
Antora를 사용하는 데 환경 변수는 필요하지 않습니다. 해당 명령줄 옵션 또는 플레이북의 일치하는 키를 사용하여 이러한 변수를 구성할 수 있습니다.
=== 우선 순위
환경 변수는 플레이북 파일에 정의된 키보다 우선합니다. 그러나 키에 대한 CLI 옵션은 해당 키에 대한 환경 변수보다 우선합니다.
환경 변수(예: URL 또는 https_proxy)가 이미 환경에 설정되어 있고 antora 명령을 실행할 때(즉, 단일 호출) 일시적으로 해제하려는 경우 env 명령을 사용하여 이를 수행할 수 있습니다.
[source,console]
$ env -u URL antora antora-playbook.yml
다른 옵션은 하위 셸에서 antora 명령을 실행하는 것입니다. 하위 셸 내에서 기본 셸 또는 운영 체제의 환경에 영향을 주지 않고 환경 변수를 해제할 수 있습니다.
[source,console]
$ (unset URL; antora antora-playbook.yml)
환경 변수가 플레이북 파일에 정의된 키보다 우선한다는 점을 기억하세요. 따라서 예상하지 않은 결과가 발생하면 항상 환경 변수를 확인하여 원인을 찾으십시오.
=== 변수 및 형식
다음 표는 Antora의 동작을 제어하는 데 사용할 수 있는 환경 변수를 요약한 것입니다.
|===
|변수 |형식 |기본값 |더 알아보기
|ANTORA_CACHE_DIR
|문자열
|<user cache>/antora
|cache_dir 키 및 --cache-dir 옵션 참조
|ANTORA_LOG_FAILURE_LEVEL
|문자열
|설정되지 않음
|failure_level 키 및 --log-failure-level 옵션 참조
|ANTORA_LOG_FILE
|문자열
|설정되지 않음
|file 키 및 --log-file 옵션 참조
|ANTORA_LOG_FORMAT
|문자열
|CI=true 또는 터미널이 대화형이면 pretty, 그렇지 않으면 json
|format 키 및 --log-format 옵션 참조
|ANTORA_LOG_LEVEL
|문자열
|warn
|level 키 및 --log-level 옵션 참조
|ANTORA_LOG_LEVEL_FORMAT
|문자열
|label
|level_format 키 및 --log-level-format 옵션 참조. 로그 형식이 json인 경우에만 적용됩니다.
|GIT_CREDENTIALS
|문자열
|설정되지 않음
|Private Repository Authentication 참조
|GIT_CREDENTIALS_PATH
|문자열
|설정되지 않음
|git credentials file path 및 --git-credentials-path 옵션 참조
|GOOGLE_ANALYTICS_KEY
|문자열
|설정되지 않음
|Google Analytics key 참조
|http_proxy
|문자열
|설정되지 않음
|http_proxy 키 및 --http-proxy 옵션 참조
|https_proxy
|문자열
|설정되지 않음
|https_proxy 키 및 --https-proxy 옵션 참조
|no_proxy
|문자열
|설정되지 않음
|no_proxy 키 및 --noproxy 옵션 참조. CLI 옵션의 이름은 환경 변수 및 플레이북 키의 이름과 다릅니다.
|URL
|문자열
|설정되지 않음
|site url 키 및 --url 옵션 참조
|===

== Publish Your Site

== Publish Your Site - How Antora Builds URLs

Antora는 리소스 ID, 사이트 URL 및 사이트의 플레이북에 있는 URL 설정의 정보를 사용하여 게시 가능한 리소스(페이지, 첨부 파일 및 이미지)의 URL을 빌드합니다.
=== 사이트 URL
사용자 정의. 선택 사항.
사이트 URL은 사이트가 게시되는 위치를 식별합니다. 사이트 URL은 플레이북의 site.url 키, --url 명령줄 옵션 또는 URL 환경 변수에 허용 가능한 값을 할당하여 정의됩니다. 허용되는 사이트 URL에는 두 가지 유형이 있습니다: 절대 URL과 루트 기준 URL.
Antora는 오프라인에서 볼 수 있고 로컬 파일 시스템에서 볼 수 있는 사이트를 생성하도록 설계되었습니다. 이러한 이유로 Antora는 사이트를 빌드하는 데 사이트 URL이 필요하지 않습니다. 그러나 Antora가 허용 가능한 사이트 URL 값을 감지하지 못하면 특정 게시 기능을 자동으로 비활성화합니다. 영향을 받는 기능의 전체 목록은 사이트 URL에 의존하는 기능을 참조하십시오.
=== 절대 사이트 URL
절대 사이트 URL은 https://로 시작하고 그 뒤에 사이트 도메인 또는 하위 도메인이 옵니다.
.절대 사이트 URL의 다이어그램
image::absolute-site-url.png[절대 사이트 URL]
사이트를 하위 폴더에 게시하는 경우 사이트 도메인 뒤에 하위 경로가 옵니다.
.하위 경로가 있는 절대 사이트 URL의 다이어그램
image::absolute-site-url-with-subpath.png[하위 경로가 있는 절대 사이트 URL]
경로 세그먼트 또는 경로명이라고도 하는 하위 경로는 Antora에서 관리하는 사이트가 위치한 도메인의 루트에서의 위치를 나타냅니다. 즉, 사이트를 도메인의 하위 폴더에 게시하는 경우 절대 사이트 URL에 이 경로를 포함해야 합니다. 하위 경로가 있는 절대 사이트 URL 사용에 대한 자세한 내용은 절대 사이트 URL 구성 및 사이트 URL에 하위 경로를 포함해야 하는 경우를 참조하십시오.
=== 루트 기준 사이트 URL
루트 기준 사이트 URL은 슬래시(/)로 시작하며, 한 문자 이상인 경우 하위 경로입니다.
.루트 기준 사이트 URL의 다이어그램
image::root-relative-site-url.png[루트 기준 사이트 URL]
자세한 내용은 루트 기준 사이트 URL 구성을 참조하십시오.
=== 사이트 경로명
계산됨.
사이트 경로명은 게시 기능에서 사이트 루트에 상대적인 URL이 필요한 경우 Antora에서 사용하는 내부 속성 site.path를 나타냅니다. Antora는 사이트 URL을 기반으로 사이트 경로명을 계산합니다. 사이트 경로명 값은 일반적으로 절대 사이트 URL에 하위 경로가 포함되어 있거나 사이트 URL이 루트 기준 사이트 URL인 경우를 제외하고는 비어 있습니다. site.url이 하위 경로를 포함하는 절대 사이트 URL인 경우 Antora는 하위 경로를 추출하여 사이트 경로명으로 사용합니다. 예를 들어 그림 2의 절대 사이트 URL을 사용하면 Antora는 하위 경로 /docs를 추출하여 site.path에 할당합니다. site.url에 할당된 값이 루트 기준 사이트 URL인 경우 Antora는 전체 값을 추출하여 사이트 경로명으로 사용합니다. Antora는 리디렉션과 같은 기능에서 계산된 URL이 사이트 도메인 또는 사이트 루트에 상대적일 때 리소스 URL을 사이트 경로명에 추가하여 도메인 기준 URL을 생성합니다.
=== 올바른 URL, 올바른 위치
Antora는 사이트의 모든 URL을 생성하고 관리합니다. Antora는 게시 가능한 리소스의 리소스 URL을 사이트 경로명에 상대적인 절대 경로로 빌드합니다. 그런 다음 리소스 URL은 컨텍스트와 URL이 사용되는 기능에 따라 현재 페이지에 상대적인 URL, 사이트 URL(site-pathname/resource-URL) 또는 절대 URL(absolute-site-URL/resource-URL)로 변환됩니다.
=== 리소스 URL
계산됨.
Antora는 사이트의 각 게시 가능한 리소스에 대해 리소스 URL을 계산합니다. 게시 가능한 리소스는 페이지, 이미지 및 첨부 파일 패밀리에 속하는 소스 파일입니다. 리소스 URL은 애플리케이션 전체에서 정규화되도록 사이트 경로명에 상대적인 절대 경로로 계산됩니다.
리소스 URL은 슬래시(/)로 시작하고 리소스의 ID와 플레이북의 URL 설정에서 Antora가 파생한 세그먼트를 포함합니다. 이러한 세그먼트는 종종 구성 요소 이름, 버전, 모듈 및 리소스 파일 이름을 나타냅니다.
.Antora에 의해 계산된 리소스 URL의 다이어그램
image::computed-resource-url.png[Antora에 의해 계산된 리소스 URL]
특정 플레이북 키는 리소스 URL의 일부를 수정, 추가 또는 제거할 수 있습니다. 일부 리소스 URL 세그먼트는 리소스가 페이지가 아니거나 ROOT 구성 요소, 버전이 지정되지 않은 구성 요소 버전 또는 ROOT 모듈에 속하는 경우 추가되거나 없습니다. 각 세그먼트와 Antora가 해당 값을 추출하는 위치에 대한 정보는 리소스 URL 세그먼트를 참조하십시오.
Antora는 리소스의 계산된 리소스 URL을 내부 속성 pub.url에 할당합니다. 여기서 pub는 게시와 관련된 속성의 속성 그룹입니다.
=== 상대화된 URL
계산됨.
Antora는 리소스에 대한 참조를 상대 URL로 변환합니다. Antora는 이 변환을 상대화라고 합니다.
상대화 변환이 발생하는 위치는 페이지, 이미지, 첨부 파일 또는 UI 리소스일 수 있는 리소스에 따라 다릅니다. AsciiDoc의 xref 및 이미지의 경우 Antora는 Asciidoctor용 확장 HTML 변환기에서 내부적으로 상대화를 호출합니다. 탐색 항목, 브레드크럼, 페이지 매김 링크 및 페이지 버전 선택기의 경우 UI는 상대화 도우미를 사용하여 리소스 URL을 현재 페이지에서 상대 URL로 변환합니다. UI 리소스의 경우 UI는 uiRootPath 변수를 사용하여 리소스에 대한 상대 URL을 생성합니다.
Antora가 리소스에 연결하기 위해 상대 URL을 생성하는 데에는 두 가지 이유가 있습니다. 첫째, 생성된 HTML의 크기를 제한하기 위해 URL의 길이를 가능한 짧게 유지합니다. 더 중요한 것은 URL이 환경 간에 이식 가능하도록 보장한다는 것입니다. 이는 Antora 사이트가 파일 시스템에서 직접 볼 때 작동하는 주요 이유입니다. 상대 참조는 URL을 해결하기 위해 웹 서버에 의존하지 않습니다. 대신 현재 페이지에서 시작하여 파일 시스템을 위아래로 걸어 대상 리소스에 도달하는데, 이는 어디에서나 작동합니다. 같은 이유로 사이트가 특정 도메인이나 사이트 루트에 묶이지 않기 때문에 게시를 단순화합니다.
=== 도메인 기준 URL
계산됨.
Antora는 페이지 별칭, 구성 요소 버전 시작 페이지 및 최신 버전 세그먼트 redirect:to 및 replace 전략에 대한 재작성 규칙을 생성할 때 도메인 기준 URL을 계산합니다. 사이트 경로명에 빈 값이 아닌 값이 할당되면 Antora는 사이트 경로명을 리소스 URL 앞에 추가합니다. 사이트 경로명이 비어 있으면 리소스 URL은 이미 도메인 기준 URL과 동일합니다. 예를 들어 그림 4의 리소스 URL과 사이트 경로명 /docs를 사용하면 Antora는 그림 5와 같이 도메인 기준 URL을 계산합니다.
.Antora에 의해 계산된 도메인 기준 URL의 다이어그램
image::computed-domain-relative-url.png[Antora에 의해 계산된 도메인 기준 URL]
site.url 키가 설정되지 않은 경우 Antora는 도메인 기준 URL을 계산하지 않으며 이를 필요로 하는 게시 기능은 런타임에 자동으로 비활성화됩니다.
=== 절대 URL
계산됨.
절대 URL은 게시 가능한 리소스의 전체 URL입니다. 절대 URL을 계산하기 위해 Antora는 절대 사이트 URL로 시작하여 리소스 URL을 추가합니다. 예를 들어 그림 2의 사이트 URL과 그림 4의 리소스 URL을 사용하면 Antora는 그림 6과 같이 절대 URL을 계산합니다.
.Antora에 의해 계산된 절대 URL의 다이어그램
image::computed-absolute-url.png[Antora에 의해 계산된 절대 URL]
그림 6은 페이지의 URL이 브라우저 주소 표시줄이나 사이트맵에 표시되는 방식의 예입니다. Antora는 사이트맵을 생성하고 각 페이지의 head에 있는 meta 태그에 대한 정식 URL을 계산할 때 절대 URL을 계산합니다. site.url 키에 절대 사이트 URL이 할당되지 않은 경우 절대 URL을 필요로 하는 게시 기능은 런타임에 자동으로 비활성화됩니다.
=== 리소스 URL 세그먼트
다음 섹션에서는 리소스 URL의 각 세그먼트와 Antora가 각 세그먼트의 값을 추출하는 위치에 대해 설명합니다. 게시된 페이지의 리소스 URL 세그먼트는 일반적으로 그림 7에 표시된 순서로 구성됩니다.
.Antora에 의해 조립된 페이지 URL 세그먼트의 다이어그램
image::page-url-segments.png[게시된 페이지의 리소스 URL 세그먼트]
이미지와 첨부 파일의 리소스 URL에는 각각 _images 또는 _attachments라는 추가 패밀리 세그먼트가 포함됩니다. 패밀리 세그먼트는 그림 8과 같이 모듈 세그먼트 뒤에 옵니다.

.Antora에 의해 조립된 이미지의 리소스 URL 세그먼트의 다이어그램
image::image-url-segments.png[게시된 이미지의 리소스 URL 세그먼트]
=== 구성 요소 세그먼트
URL의 구성 요소 세그먼트는 게시된 리소스가 속한 구성 요소의 이름입니다. 리소스가 특별히 명명된 ROOT 구성 요소에 속하는 경우 구성 요소 세그먼트는 URL에서 삭제됩니다. 구성 요소 이름은 antora.yml 파일의 name 키로 지정됩니다.
Antora가 계산하여 리소스의 pub.url 속성에 할당하는 리소스 URL은 항상 이 세그먼트로 시작합니다.
=== 버전 세그먼트
URL의 버전 세그먼트는 게시된 리소스가 속한 구성 요소 버전의 실제 버전 또는 상징적 버전입니다. 실제 버전은 구성 요소 버전의 antora.yml 파일의 version 키 또는 플레이북에 지정된 콘텐츠 소스의 version 키에 할당된 값입니다. 모든 구성 요소 버전에는 실제 버전이 있지만 해당 버전은 버전이 지정되지 않은 것으로 정의될 수 있습니다. 구성 요소 버전이 버전이 지정되지 않은 경우 버전 세그먼트는 해당 리소스의 URL에서 삭제됩니다.
상징적 버전은 리소스가 구성 요소의 최신 버전 또는 최신 사전 릴리스 버전에 속하는 경우에만 버전 세그먼트에 적용되는 선택적 구성 설정입니다. 상징적 버전은 URL에서 실제 버전을 대체합니다. 상징적 버전은 플레이북의 latest_version_segment 키 또는 latest_prerelease_version_segment 키를 사용하여 정의됩니다. 상징적 버전은 버전이 지정되지 않은 구성 요소 버전에는 적용되지 않습니다. 버전 세그먼트는 항상 해당 리소스의 게시된 URL에서 삭제됩니다.
=== 모듈 세그먼트
Antora는 리소스의 소스 파일이 저장된 모듈 디렉터리 이름에서 모듈 세그먼트를 파생합니다. 리소스가 특별히 명명된 ROOT 모듈에 속하는 경우 모듈 세그먼트는 URL에서 삭제됩니다. 예제 및 자세한 정보는 페이지 URL의 모듈 세그먼트를 참조하십시오.
=== 패밀리 세그먼트
패밀리 세그먼트는 이미지와 첨부 파일의 리소스 URL에만 적용됩니다. 이미지 및 첨부 파일 URL에는 밑줄(_)로 시작하는 패밀리 세그먼트가 포함됩니다. 이미지의 경우 이 세그먼트는 _images입니다. 첨부 파일의 경우 이 세그먼트는 _attachments입니다. 페이지의 URL에는 패밀리 세그먼트가 포함되지 않습니다.
=== 상대 경로 세그먼트
상대 경로 세그먼트는 리소스의 소스 파일의 패밀리 기준 경로에서 파생됩니다. 페이지의 경우 .adoc 확장자는 삭제되고 .html 또는 지정된 HTML 확장자 스타일로 대체됩니다. 다른 리소스의 URL은 .svg 또는 .pdf와 같은 원래 파일 확장자를 유지합니다.
=== HTML 확장자
.html 확장자와 html_extension_style 키는 페이지 URL에만 적용됩니다. 기본적으로 Antora는 페이지 URL에 .html 확장자를 추가합니다. html_extension_style 플레이북 키 또는 --html-url-extension-style 옵션은 이 동작을 수정합니다. 확장자를 삭제(drop)하거나 삭제하고 슬래시로 대체(indexify)할 수 있습니다.
페이지가 아닌 리소스의 URL은 html_extension_style에 할당된 값에 관계없이 소스 파일의 파일 확장자를 사용합니다.



== Publish Your Site - Add a 404 Error Page

걱정하지 마세요, 누락된 페이지에 착륙한 것이 아닙니다. 이 페이지는 404 오류 페이지와 이를 게시된 사이트에 추가하는 방법에 대한 것입니다.
=== 404 오류 페이지란 무엇입니까?
웹 서버가 URL에 대한 페이지를 찾을 수 없는 경우 브라우저에 404 상태 코드를 반환합니다(일반적인 200 상태 코드 대신). 이는 방문자가 사이트 내의 깨진 링크, 검색 엔진을 클릭하거나 브라우저 위치 표시줄에 URL을 잘못 입력한 경우에 발생할 수 있습니다.
웹 서버는 방문자에게 빈 페이지나 저수준 오류 메시지를 보여주는 대신 일반적으로 404 오류 페이지(이하 404 페이지)의 내용을 표시합니다.
404 페이지를 제공하기 위해 웹 서버는 게시된 사이트의 루트에 있는 404.html 파일을 찾습니다. 이 파일의 내용은 방문자가 볼 수 있었던 HTML 대신 사용됩니다. 방문자는 다른 페이지로 리디렉션되지 않으므로 원래 URL이 브라우저 위치 표시줄에 계속 표시됩니다.
404 페이지를 정의하고 Antora 사이트에 추가하는 방법을 알아보겠습니다.
=== 404 페이지 정의
Antora 사이트에서 404 페이지는 UI에서 제공하는 레이아웃 템플릿을 사용하여 생성됩니다. 이를 위해서는 UI가 layouts/404.hbs 경로에 404라는 레이아웃 템플릿을 정의해야 합니다. Antora는 이 템플릿을 사용하여 404.html 파일을 생성한 다음 게시된 사이트의 루트에 출력합니다.
기본 UI를 사용하거나 확장하는 경우 404 페이지의 레이아웃 템플릿이 이미 제공되어 있습니다.
404 레이아웃 템플릿은 현재 페이지에 대한 정보(페이지가 없기 때문에)를 page.title과 page.layout을 제외하고 포함하지 않는 축소된 UI 모델로 컴파일됩니다. 템플릿은 uiRootPath 및 site.components와 같은 UI 모델의 다른 모든 변수에 액세스할 수 있습니다.
일반 페이지와 달리 uiRootPath 및 siteRootPath 템플릿 변수는 404 템플릿에서 루트 기준 경로입니다. 이는 서버에서 제공할 때 404 페이지가 올바르게 작동하는 데 필요합니다. 그 이유는 404 페이지 내용이 방문자가 원래 요청한 URL에서 제공되기 때문입니다.
=== 404 페이지 활성화
Antora는 플레이북의 site.url 키에 값이 있는 경우에만 404 페이지를 생성합니다. 사이트 URL이 지정되면 사이트가 웹 서버에 게시된다고 가정합니다.
site.url 키의 값은 사이트 URL 페이지에 설명된 대로 절대 URL 또는 루트 기준 경로일 수 있습니다. 경로 세그먼트는 비어 있지 않을 수 있으며, 이는 다음 섹션에서 다룰 것입니다.
Antora가 UI 번들(또는 추가 UI)에서 이름이 404인 레이아웃 템플릿을 찾지 못하면 플레이북에 site.url 키가 설정되어 있더라도 사이트에 대한 404 페이지를 생성하지 않습니다.
=== 하위 경로에 게시할 때 404 페이지 구성
일반적으로 404 페이지가 작동하기 위해 추가로 필요한 것은 없습니다. 웹 서버는 게시된 사이트의 루트에 있는 404.html 파일을 자동으로 선택하고 방문자가 누락된 페이지에 도착할 때 이를 사용합니다.
그러나 사이트를 도메인의 하위 경로(예: https://example.org/site-a)에 게시하는 경우 추가 구성이 필요합니다.
사이트의 URL에 경로 세그먼트가 포함되면 사이트의 404 페이지는 더 이상 웹 서버 루트에 위치하지 않습니다. 대신 나머지 파일과 함께 하위 경로 아래에 위치하게 됩니다. 문제는 웹 서버가 이 하위 경로가 중요하다는 것을 모른다는 것입니다(즉, 웹 서버는 하위 경로가 개별 사이트의 경계라는 것을 모릅니다). 결과적으로 웹 서버는 누락된 페이지 대신 이 404 페이지를 제공해야 한다는 것을 알지 못합니다. 따라서 우리는 웹 서버에 이를 알려야 합니다. 사이트의 파일을 제공할 때 기본 위치(즉, /404.html)의 404 페이지 대신 하위 경로(예: /site-a/404.html) 아래의 404 페이지를 사용하도록 웹 서버를 구성해야 합니다.
이를 설정하는 데 필요한 세 가지 단계는 다음과 같습니다. 도메인이 example.com, 하위 경로가 site-a, 웹 서버가 nginx라고 가정하겠습니다.
플레이북 파일에서 절대 URL을 사용하여 하위 경로와 함께 site.url을 정의합니다:
[source,yaml]
site:
url: https://example.com/site-a
또는 루트 기준 경로를 사용합니다:
[source,yaml]
site:
url: /site-a
플레이북에 정의된 사이트 URL은 하위 경로를 포함해야 합니다. 그렇지 않으면 404 페이지의 URL이 올바르지 않습니다(예: CSS 파일의 URL).
하위 경로 아래의 누락된 URL에 대해 하위 경로 폴더의 404.html을 사용하도록 nginx를 구성합니다:
[source]
location /site-a/ {
error_page 404 /site-a/404.html;
}
사이트의 하위 경로와 일치하도록 하위 경로 위치를 조정하십시오.
Antora에서 생성한 사이트 파일을 웹 서버 루트 아래의 하위 경로에 복사합니다:
[source,console]
rsync -r --delete build/site/ /usr/share/nginx/html/site-a
즉, 하위 경로 폴더는 웹 서버 루트 또는 가상 호스트의 루트에 있어야 합니다.
Antora 데모는 이 구성의 예입니다(GitLab Pages 서버는 자동으로 하위 경로에서 404 페이지를 매핑합니다). antora.gitlab.io/demo/docs-site/component-b/2.0/no-such-page.html을 참조하세요. CSS 파일의 URL이 루트 기준 경로 /demo/docs-site//css/site.css_임을 주목하세요.



== Publish Your Site - Automatic Sitemap

playbook에 정의된 사이트 URL 값이 절대 URL인 경우 Antora는 자동으로 사이트맵을 생성하고 생성된 사이트의 루트에 출력합니다.
사이트맵 구조
Antora가 생성하는 사이트맵은 여러 파일로 구성됩니다. 단일 sitemap.xml 파일이 아니라 Antora는 사이트맵을 여러 개의 파일로 분할합니다. sitemap.xml 파일은 개별 구성 요소 사이트맵 파일을 나열하는 사이트맵 인덱스입니다. 사이트맵 파일은 검색 엔진이 찾을 것으로 예상되는 게시된 사이트의 루트에 배치됩니다.
....
404.html
index.html
robots.txt
sitemap.xml
sitemap-colorado.xml
sitemap-wyoming.xml
...
....
각 구성 요소 사이트맵 파일의 이름은 sitemap-<name>.xml이며, 여기서 <name>은 구성 요소 이름입니다. 파일에는 사이트의 각 게시 가능한 페이지에 대한 <url> 항목이 포함되어 있습니다. 다른 유형의 리소스는 사이트맵에 포함되지 않습니다.
<url>의 <loc> 태그 값은 해당 페이지의 절대 URL입니다. <url> 값은 사이트 URL(하위 경로 포함)과 페이지의 (루트 상대) URL을 결합하여 생성됩니다. <url>의 <lastmod> 태그 값은 사이트가 생성된 날짜입니다.
항목은 실행 간에 순서가 안정적으로 유지되도록 단순히 정렬됩니다.
예제
예제를 살펴보겠습니다. 사이트에 colorado와 wyoming이라는 두 개의 구성 요소가 있고 사이트 URL은 https://docs.example.org라고 가정하겠습니다. sitemap.xml은 다음과 같을 수 있습니다:
[source,xml]
<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<sitemap>
<loc>https://docs.example.org/sitemap-colorado.xml</loc>
</sitemap>
<sitemap>
<loc>https://docs.example.org/sitemap-wyoming.xml</loc>
</sitemap>
</sitemapindex>
----
sitemap-colorado.xml은 다음과 같을 수 있습니다:
[source,xml]
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url>
<loc>https://docs.example.org/colorado/6.0/index.html</loc>
<lastmod>2021-12-24T23:00:00.123Z</lastmod>
</url>
...
</urlset>
----


== Publish Your Site - Publish to GitHub Pages

Antora는 정적 웹 호스트 또는 로컬 파일 시스템에서 실행되는 사이트를 만들도록 설계되었습니다. 그러나 일부 호스트는 Antora의 출력을 방해하는 "기능"을 제공합니다. GitHub Pages가 그 중 하나입니다.
Jekyll과 밑줄 파일
기본적으로 GitHub Pages는 Jekyll이라는 또 다른 정적 사이트 생성기를 통해 모든 파일을 실행합니다(저장소가 Jekyll을 사용하도록 설정되지 않은 경우에도). Antora는 이미 완성된 사이트를 생성하므로 이 단계가 절대적으로 필요하지 않습니다. 그러나 이는 낭비되는 노력 이상의 문제입니다.
Jekyll은 밑줄(_)로 시작하는 모든 파일을 제거하는 불쾌한 부작용이 있습니다. 왜 이것이 문제일까요? 기본적으로 Antora는 UI 파일을 _라는 폴더에 넣습니다. 또한 _images라는 폴더 안에 이미지를 배치합니다. Jekyll이 실행되면 이러한 폴더를 삭제합니다. 그 결과 UI와 이미지가 없어집니다.
.nojekyll
다행히도 GitHub Pages의 이 "기능"을 비활성화할 수 있는 방법이 있습니다. 해결책은 게시된 사이트의 루트(즉, 플레이북에 구성된 출력 디렉토리)에 .nojekyll 파일을 추가하는 것입니다.
gh-pages 브랜치의 루트에 .nojekyll 파일이 있으면 GitHub Pages에 게시된 파일을 Jekyll을 통해 실행하지 않도록 지시합니다. 그 결과 Antora로 만든 사이트가 예상대로 작동합니다.
Antora를 실행할 때 .nojekyll 파일을 만드는 두 가지 방법을 살펴보겠습니다.
수동으로 파일 터치하기
이 파일을 추가하는 한 가지 방법은 Antora가 실행된 후 GitHub Pages에 파일을 커밋하기 전에 출력 디렉토리에서 .nojekyll 파일을 터치하는 것입니다. 예를 들면 다음과 같습니다:
[source,bash]
touch build/site/.nojekyll
다행히도 별도의 명령을 실행하지 않고도 이를 수행할 수 있는 방법이 있습니다.
보충 UI 사용하기
추가 명령의 필요성을 피하기 위해 다른 방법은 Antora의 보충 UI 기능을 사용하여 파일을 주입하는 것입니다. 이렇게 하려면 플레이북 파일의 ui 카테고리 아래에 다음 supplemental_files 블록을 추가하십시오:
.antora-playbook.yml that adds .nojekyll file using supplemental UI
[source,yaml]
ui:
bundle:
url: <url-of-bundle-goes-here>
supplemental_files:

path: ui.yml
contents: |
static_files:

.nojekyll


path: .nojekyll


이 구성은 메모리에서 파일을 정의합니다. 첫 번째 파일인 ui.yml은 static_files 키를 사용하여 사이트의 루트(UI 폴더 외부)로 승격할 파일을 Antora에 알려줍니다. 두 번째 파일인 .nojekyll은 게시된 사이트의 루트에 작성됩니다. contents 키가 없으므로 Antora는 빈 파일을 생성합니다(위의 touch 명령과 동일).
GitHub Actions 사용하기
플레이북 저장소가 GitHub에 호스팅되어 있는 경우 GitHub Actions 워크플로를 구성하여 사이트를 빌드하고 GitHub Pages에 게시할 수 있습니다. GitHub Actions를 사용하면 두 가지 이점이 있습니다. 첫째, 게시된 파일을 gh-pages 브랜치에 복사하여 게시할 필요가 없습니다. 둘째, 액션이 .nojekyll 파일을 처리하므로 이에 대해 걱정할 필요가 없습니다. 시작해 보겠습니다!
예제 2는 Antora의 최신 안정 릴리스를 사용하여 사이트를 빌드하고 GitHub Pages에 게시하는 GitHub Actions 워크플로의 예를 보여줍니다. 이 워크플로는 플레이북 저장소의 기본 브랜치 이름이 main이고, 플레이북 파일의 이름이 antora-playbook.yml이며, Antora가 build/site 디렉토리에 파일을 게시하도록 구성되었다고 가정합니다. 사이트에서 다른 설정을 사용하는 경우 워크플로 파일의 값을 그에 따라 업데이트해야 합니다.
.github/workflows/publish.yml builds the Antora site and deploys it to GitHub Pages using GitHub Actions
[source,yaml]
name: Publish to GitHub Pages
on:
push:
branches: [main]
Allows you to run this workflow manually from the Actions tab
workflow_dispatch:
concurrency:
group: github-pages
cancel-in-progress: false
Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
contents: read
pages: write
id-token: write
jobs:
build:
runs-on: ubuntu-latest
environment:
name: github-pages
url: ${{ steps.deployment.outputs.page_url }}
steps:
- name: Checkout repository
uses: actions/checkout@v4
- name: Configure Pages
uses: actions/configure-pages@v3
- name: Install Node.js
uses: actions/setup-node@v4
with:
node-version: '18'
- name: Install Antora
run: npm i antora
- name: Generate Site
run: npx antora antora-playbook.yml
- name: Upload Artifacts
uses: actions/upload-pages-artifact@v2
with:
path: build/site
- name: Deploy to GitHub Pages
id: deployment
uses: actions/deploy-pages@v2
예제 2에서 볼 수 있듯이 워크플로에서 직접 Antora를 설치하고 실행할 수 있습니다. 이 워크플로는 특정 Antora 릴리스(CLI 및 사이트 생성기 패키지 모두)를 설치한 다음 워크플로에서 Antora CLI를 사용합니다. 그런 다음 워크플로는 peaceiris/actions-gh-pages 액션을 사용하여 필요한 .nojekyll 파일과 함께 사이트를 GitHub Pages에 게시합니다.
다른 버전의 Antora를 설치하고 사용하려면 antora@3.0.3과 같이 패키지 이름에 버전을 추가하십시오.
이제 Antora Lunr Extension을 추가하여 빌드된 사이트에 검색 위젯을 통합하는 것으로 한 단계 더 나아가 보겠습니다. 먼저 해당 프로젝트의 README에 설명된 대로 Antora Lunr Extension의 최소 요구 사항을 충족하도록 플레이북 저장소와 UI를 업데이트해야 합니다. 완료되면 GitHub Actions 워크플로로 돌아가서 Antora를 설치할 때 확장 프로그램을 설치하도록 구성하십시오. 결과는 예제 3과 같습니다.
.github/workflows/publish.yml includes the Antora Lunr Extension
[source,yaml]
name: Publish to GitHub Pages with Lunr Search Extension
on:
push:
branches: [main]
Allows you to run this workflow manually from the Actions tab
workflow_dispatch:
concurrency:
group: github-pages
cancel-in-progress: false
Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
contents: read
pages: write
id-token: write
jobs:
build:
runs-on: ubuntu-latest
environment:
name: github-pages
url: ${{ steps.deployment.outputs.page_url }}
steps:
- name: Checkout repository
uses: actions/checkout@v4
- name: Configure Pages
uses: actions/configure-pages@v3
- name: Install Node.js
uses: actions/setup-node@v4
with:
node-version: '18'
- name: Install Antora with the Antora Lunr Extension
run: npm i antora @antora/lunr-extension
- name: Generate Site
run: npx antora antora-playbook.yml
- name: Upload Artifacts
uses: actions/upload-pages-artifact@v2
with:
path: build/site
- name: Deploy to GitHub Pages
id: deployment
uses: actions/deploy-pages@v2
다른 버전의 Antora Lunr Extension을 설치하고 사용하려면 @antora/lunr-extension@1.0.0-alpha.5와 같이 패키지 이름에 버전을 추가하십시오.
사용자 지정 도메인 사용하기
Github Pages 사용자 지정 도메인을 사용하여 기본 <username>.github.io 이외의 다른 URL에서 사이트를 제공할 수 있습니다.
소스로 GitHub Actions를 사용하여 사이트를 게시하는 경우 GitHub 웹 인터페이스의 Settings → Pages 구성 화면에서 사용자 지정 도메인을 구성할 수 있습니다. CI 워크플로에서 다른 작업이 필요하지 않습니다.
반면에 브랜치(예: gh-pages)에서 사이트를 게시하는 경우 사이트의 루트에 있는 CNAME 파일에 사용자 지정 도메인을 작성해야 합니다. 이렇게 하려면 Antora를 실행한 후 GitHub Actions 워크플로 파일(또는 사용 중인 CI 파이프라인에 해당하는 파일)에 다음 단계를 추가하십시오.
[source,bash]

name: Create CNAME file
run: echo my-domain-name.com > build/site/CNAME


또는 앞서 .nojekyll 파일을 추가한 것과 유사하게 보충 UI를 사용하여 CNAME 파일을 추가할 수 있습니다.
.antora-playbook.yml that adds CNAME file using supplemental UI
[source,yaml]
ui:
bundle:
url: <url-of-bundle-goes-here>
supplemental_files:

path: ui.yml
contents: |
static_files:

CNAME


path: CNAME
contents: |
my-domain-name.com


이 구성은 메모리에서 파일을 정의합니다. 첫 번째 파일인 ui.yml은 static_files 키를 사용하여 사이트의 루트(UI 폴더 외부)로 승격할 파일을 Antora에 알려줍니다. 두 번째 파일인 CNAME은 게시된 사이트의 루트에 작성되며 브랜치에서 게시할 때 GitHub Pages에서 요구하는 대로 사용자 지정 도메인 이름을 포함합니다. 이 접근 방식의 장점은 CI 워크플로에 추가 단계가 필요하지 않다는 것입니다.
사용자 지정 도메인을 사용하는 방법과 활성화하는 방법에 대한 자세한 내용은 GitHub 설명서의 GitHub Pages 사이트에 대한 사용자 지정 도메인 관리를 참조하십시오.



== Publish Your Site - Publish to GitLab Pages

GitLab은 Antora 기반 문서를 웹에 게시하는 데 필요한 모든 것을 제공하는 DevOps 플랫폼입니다. 이 페이지에서는 GitLab을 사용하여 Antora로 첫 번째 문서 사이트를 게시하는 방법을 살펴보겠습니다.
GitLab 개요
각 GitLab 프로젝트는 코드 호스팅(Git 저장소), 지속적 통합(GitLab CI), 리디렉션 지원이 포함된 정적 웹 호스팅(GitLab Pages)을 제공합니다. 따라서 GitLab은 소스에서 게시된 사이트에 이르기까지 Antora 기반 문서 사이트 전체를 종단 간에 관리하기에 적합합니다.
GitLab CI/CD를 사용하여 Antora 사이트를 게시하려면 다음이 필요합니다:

Antora 플레이북 파일을 저장하는 로컬 Git 저장소로 시작하는 플레이북 프로젝트.
콘텐츠 파일을 호스팅하는 Git 저장소가 있는 0개 이상의 콘텐츠 프로젝트.
플레이북 프로젝트의 Git 저장소 루트에 있는 .gitlab-ci.yml 파일로, CI/CD 구성을 제공합니다.

계속하기 전에 GitLab 문서에서 핵심 CI/CD 개념과 .gitlab-ci.yml 파일 개요를 공부하는 것이 좋습니다.
시작하기
GitLab에서 플레이북 프로젝트를 호스팅할 새 프로젝트를 만드는 것으로 시작하세요. 해당 페이지의 지침에 따라 로컬 Git 저장소를 GitLab으로 푸시하세요. 플레이북이 다른 콘텐츠 소스 저장소를 참조하는 경우 해당 저장소도 GitLab으로 푸시해야 합니다.
다음으로 CI/CD를 구성해야 합니다. 플레이북 저장소의 기본 브랜치에서만 GitLab CI/CD를 설정하면 됩니다. Antora는 플레이북에 선언된 다른 저장소에서 콘텐츠를 자동으로 가져옵니다.
Antora Docker 이미지를 사용하여 Antora로 사이트를 빌드하고 GitLab Pages에 게시하는 기본 GitLab CI/CD 구성 파일로 시작하겠습니다.
.gitlab-ci.yml to build and deploy an Antora site
[source,yaml]
image:
name: antora/antora
pages:
stage: deploy
interruptible: true
script:

antora --fetch --redirect-facility=gitlab --to-dir=public antora-playbook.yml
artifacts:
paths:

public




.gitlab-ci.yml 파일을 Git에 커밋하고 원격 저장소로 푸시하세요. 그러면 첫 번째 CI/CD 파이프라인이 트리거됩니다. 파이프라인이 성공하면 Pages 설정 페이지에 나열된 URL에서 사이트에 액세스할 수 있습니다.
기본적으로 GitLab Pages는 Use unique domain 옵션을 자동으로 활성화하여 사이트가 호스팅되는 URL에 고유한 번호를 추가합니다. 이는 원하는 것이 아닐 가능성이 높습니다. 모호한 URL일 뿐만 아니라 사용자 지정 도메인 사용을 방해할 수 있습니다. 이를 수정하려면 다음 단계를 따르세요:

프로젝트 저장소에서 Deploy → Pages 메뉴 옵션으로 이동합니다.
Use unique domain 옵션을 선택 취소합니다.
Save changes를 클릭합니다.

GitLab Pages 사이트의 URL은 이제 다음 패턴을 따릅니다:
https://<group-name>.gitlab.io/<project-name>
프로젝트가 비공개인 경우에도 사이트는 공개됩니다.
Antora 데모를 위한 플레이북 프로젝트를 참조하여 GitLab Pages를 사용하여 Antora 사이트를 빌드하고 게시하는 또 다른 예를 확인할 수 있습니다. 이 예제는 GitLab CI/CD의 몇 가지 추가 기능을 활용합니다.
빌드 사용자 지정
지금까지 우리는 CI/CD에서 Antora를 실행하기 위해 Antora Docker 이미지에 의존했습니다. Antora Docker 이미지는 Antora 핵심 구성 요소만 제공합니다. 확장 기능은 포함되어 있지 않습니다.
Antora Docker 이미지를 사용하는 것이 빠르게 시작하는 편리한 방법이지만, 플레이북 프로젝트 내에서 사이트의 종속성을 선언하는 것이 좋습니다(또는 Docker 이미지를 확장). 그렇게 하면 빌드가 자체 포함되고 이식 가능하게 유지됩니다. 이는 @antora/lunr-extension 및 asciidoctor-kroki와 같은 추가 패키지에 의존하는 경우 특히 중요합니다.
플레이북 프로젝트에 Antora, Antora Lunr Extension 및 Asciidoctor Kroki에 대한 종속성을 선언하는 다음과 같은 package.json 파일이 있다고 가정해 보겠습니다.
.package.json
[source,json]
{
"name": "my-docs-site",
"description": "My Docs Site",
"private": true,
"devDependencies": {
"antora": "~3.0",
"@antora/lunr-extension": "1.0.0-alpha.8",
"asciidoctor-kroki": "0.15.4"
}
}
먼저 npm i를 실행하여 package-lock.json 파일을 생성하고 두 파일을 모두 커밋해야 합니다.
해당 구성이 준비되면 GitLab CI/CD 구성을 Antora Docker에서 사용하는 기본 이미지인 node:16-alpine을 기반으로 수정할 수 있습니다. 그런 다음 기본 이미지에서 Antora를 제공하지 않으므로 각 빌드에서 종속성을 가져와야 합니다.

..gitlab-ci.yml
[source,yaml]
----
image:
name: node:16-alpine
variables:
ANTORA_CACHE_DIR: .cache/antora
NODE_OPTIONS: --max-old-space-size=4096
before_script:
npm ci
pages:
stage: deploy
interruptible: true
rules:
if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
cache:
paths:
.cache
script:
npx antora --fetch --redirect-facility=gitlab antora-playbook.yml
artifacts:
paths:
public


<1> Antora Docker에서 사용하는 기본 이미지로, 플레이북 프로젝트에 로컬로 패키지를 설치하는 경우 사용할 수 있습니다.
<2> 실행 간에 저장소 및 UI 번들 캐시를 저장합니다.
<3> (선택 사항) Node.js에 예약된 메모리를 늘려 Antora가 무거운 빌드를 처리할 수 있도록 합니다.
<4> package-lock.js 파일에 정의된 종속성을 설치합니다. npm i 대신 npm ci를 사용하면 실행 간에 종속성 버전이 안정적으로 유지됩니다.
<5> 이 저장소의 기본 브랜치에서만 실행합니다.
<6> npx를 사용하여 Antora를 호출합니다. npx는 프로젝트 내에 설치된 antora 명령을 찾아 실행합니다. --fetch 플래그는 Antora가 이전 실행에서 저장된 캐시로 업데이트를 가져오도록 합니다.
<7> public 디렉토리는 GitLab Pages에 사이트를 게시하기 위해 미리 정의된 폴더입니다.
----

콘텐츠 저장소 중 일부가 비공개인 경우 이 환경에서 해당 저장소에 액세스할 수 있는 자격 증명을 보유한 GIT_CREDENTIALS CI/CD 변수를 정의할 수 있습니다. 콘텐츠 저장소에서 배포 토큰을 설정하여 플레이북 프로젝트의 CI/CD 파이프라인(및 Antora)에 해당 저장소에 대한 읽기 전용 액세스 권한을 부여할 수 있습니다.
경고나 치명적이지 않은 오류가 있는 경우 Antora가 CI/CD 파이프라인을 실패하도록 하려면 antora 명령에 --log-failure-level=warn을 추가하세요. 또는 플레이북에서 runtime.log.failure_level 키를 설정하여 영구 설정으로 만들 수 있습니다.



== Extend Antora

== Extend Antora - Antora Extensions

Antora는 생성기의 기능을 확장하거나 영향을 미치기 위해 활용할 수 있는 이벤트 기반 확장 기능을 제공합니다. 이 확장 기능은 모든 경험 수준의 사용자를 위해 설계되었습니다. 이 페이지에서는 확장 기능이 작동하는 방식에 대한 상위 수준의 요약을 제공하고 확장 기능을 생성하거나 사용하는 데 필요한 개념과 용어를 소개합니다. 후속 페이지에서는 첫 번째 확장 기능을 생성하는 과정을 안내합니다.
생성기 이벤트
Antora 작동 방식에서 설명한 대로 Antora의 사이트 생성기는 정적 사이트 생성을 위해 점진적으로 작동하는 개별적이고 기능적인 단계의 시퀀스입니다. 이 파이프라인 단계는 플레이북을 읽고 소스 자료를 수집하는 것으로 시작하여 HTML 파일과 웹 자산을 출력 대상에 게시하는 것으로 끝납니다. Antora의 사이트 생성기에서 구현된 Antora의 확장 기능은 생성기의 빌드 프로세스에 사용자 지정 코드를 연결하는 방법을 제공합니다.
Antora의 확장 기능은 이벤트 기반이므로 이벤트를 발생시켜 작동합니다. 이벤트는 사이트 생성(즉, Antora의 실행) 중에 발생하는 흥미로운 전환을 확장 코드(즉, 이벤트 리스너)에 알리기 위해 발생(또는 실행)됩니다. 특히 생성기의 각 개별 단계가 완료되고 다른 주요 전환점에 도달하면 Antora는 명명된 이벤트(예: contentAggregated)를 발생시킵니다.
이벤트는 리스너라고 하는 함수에 의해 처리되며, 해당 이벤트에 등록되어야 합니다. Antora의 작동에 코드를 연결하려면 이러한 이벤트 중 하나 이상을 수신하는 확장 기능을 등록합니다. 이러한 리스너는 확장 기능의 register 함수에 정의되어 있습니다.
이벤트의 리스너는 동기식 또는 비동기식일 수 있지만 동기적으로 순차적으로 호출됩니다. 이벤트 리스너에서 반환되는 모든 값은 무시됩니다. 이벤트의 모든 리스너가 실행을 마치면 생성기는 다음 단계로 진행합니다.
간단히 말해, Antora 확장 기능은 사이트 생성기에서 발생하는 전환 이벤트에 응답하는 리스너를 등록합니다. 후속 페이지에서는 리스너 설정 방법, 해당 리스너가 관찰할 수 있는 이벤트 및 컨텍스트 변수에 액세스하는 방법에 대해 자세히 설명합니다.
생성기 컨텍스트
Antora의 확장 기능은 Node.js의 EventEmitter를 기반으로 합니다. Antora는 이 이벤트 시스템에 대한 추상화인 GeneratorContext를 사용하여 이 사용 사례에 맞게 EventEmitter를 조정합니다.
생성기가 시작되면 생성기 컨텍스트라고 하는 GeneratorContext의 인스턴스를 생성합니다. 그런 다음 이 객체를 각 확장 기능 및 해당 이벤트 리스너에 바인딩합니다. 생성기 컨텍스트는 이벤트 리스너를 추적하고, 생성기 함수를 저장하고, 생성기를 통해 흐르는 컨텍스트 변수를 관리하고, 이벤트의 리스너에 알리고, 확장 기능 작성을 쉽게 만드는 도우미를 제공할 책임이 있습니다. 문자 그대로 생성기 실행의 컨텍스트입니다.
대부분의 경우 생성기 컨텍스트에서 제공하는 on 메서드를 사용하여 이벤트 리스너를 이벤트에 바인딩합니다. 또한 생성기 컨텍스트를 사용하여 사용자 지정 생성기 함수를 제공할 수 있습니다.
이벤트 리스너란?
이벤트 리스너는 이벤트가 발생할 때 호출(즉, 알림)되는 콜백 함수입니다. 이 콜백 메커니즘은 생성기의 두 개별 단계 사이에 코드를 삽입할 수 있는 방법을 제공합니다. Antora는 비동기식이더라도 리스너가 완료될 때까지 기다린 후 진행합니다.
리스너는 생성기의 범위 내 변수의 상태를 수정하거나 새 변수를 추가하거나 기존 변수를 대체할 수 있습니다. 대부분의 경우 리스너는 처리 또는 게시를 위해 하나 이상의 카탈로그에 추가 파일을 추가합니다.
동일한 이벤트의 리스너는 서로 간섭하지 않도록 순서대로 호출됩니다.
생성기 함수란?
생성기 함수는 생성기가 수행하는 미리 정의된 개별 단계입니다. 대부분의 확장 기능은 생성기 이벤트를 수신하지만 확장 기능은 또한 이러한 생성기 함수 중 하나 이상을 대체할 수 있습니다. 이 기능은 탐색 구성 방식과 같이 Antora의 기본 제공 동작을 변경하려는 경우에 사용됩니다. 이벤트 리스너와 마찬가지로 생성기 함수는 생성기 컨텍스트에서 구성됩니다. 사용자 지정 생성기 함수를 Antora의 작동에 연결하려면 해당 함수를 생성기 컨텍스트에 할당하는 확장 기능을 등록합니다.
컨텍스트 변수란?
확장 기능은 생성기에서 처리 중인 구성, 콘텐츠 또는 기타 데이터에 액세스할 수 없다면 큰 소용이 없을 것입니다. 여기에서 컨텍스트 변수가 필요합니다.
컨텍스트 변수는 생성기를 통해 흐르는 범위 내 객체에 대한 액세스를 제공합니다. 이러한 변수는 생성기 컨텍스트에 저장되므로 컨텍스트 변수라는 이름이 붙었습니다.
리스너는 생성기 컨텍스트에서 해당 변수를 선택하여 작업할 수 있습니다. 실제로 리스너는 생성기 자체가 읽을 수 있는 것과 동일한 변수를 읽을 수 있습니다. 또한 리스너는 해당 변수가 잠겨 있지 않은 한 새 변수 또는 대체 변수를 컨텍스트로 푸시할 수 있습니다.
확장 기능으로 무엇을 할 수 있나요?
작성할 수 있는 확장 기능의 종류와 가능한 작업에 대한 아이디어를 제공하기 위해 확장 기능이 생성기의 작동에 영향을 미치기 위해 수행할 수 있는 작업을 간략하게 살펴보겠습니다:

구성(즉, 플레이북) 수정
카탈로그에 새 파일 추가와 같은 컨텍스트 변수의 상태 변경
새 변수를 컨텍스트로 푸시
컨텍스트 변수 대체 또는 프록시
생성기 함수 대체 또는 프록시
새로운 단계 도입(리스너 또는 사용자 지정 생성기 함수에서)
사용자 지정 이벤트 발생
메시지 로깅
사용자 코드 요구
HTML 파일의 문자열 대체와 같은 콘텐츠 후처리
새 파일 게시
파일 게시 취소
처리 중지

일반적으로 확장 기능은 생성기에 연결되어 그 동작을 조정하지만 전체적으로 생성기를 대체하지는 않습니다. 이 접근 방식에는 몇 가지 제한 사항이 있지만 널리 액세스할 수 있는 것을 제공하기 위한 절충안입니다.
확장 기능으로 무엇을 할 수 없나요?
확장 기능은 생성기가 수행하는 단계(즉, 생성기 함수)의 순서를 변경할 수 없습니다. 또한 생성기가 단계를 건너뛰도록 할 수 없습니다. 그러나 기존 단계를 빈 함수 또는 사용자 지정 함수로 대체할 수 있습니다.
확장 기능이 할 수 있는 가장 극단적인 일은 처리를 조기에 중단하는 것입니다. 이 작업은 확장 기능의 작업이 완료되고 추가 처리가 필요하지 않은 경우에 유용합니다. 예를 들어, 확장 기능은 사이트의 콘텐츠에 대해서만 보고해야 할 수 있으며, 이 경우 게시 단계 전에 생성기를 중지할 수 있습니다.



== Extend Antora - Antora Extensions - Define an Extension

Antora 확장 기능은 register라는 이름의 내보낸 JavaScript 함수입니다. Antora는 생성기가 시작되는 즉시(플레이북이 빌드된 후) 이 함수를 호출합니다. 이 함수는 일반적으로 생성기 이벤트를 수신하는 이벤트 리스너를 추가합니다. 이벤트 리스너는 Antora 생성기의 수명 주기에 연결되어 확장 기능의 대부분의 작업을 수행합니다.
확장 기능을 정의하려면 새 JavaScript 파일(이하 확장 파일)을 만드는 것부터 시작하세요. 이 확장 기능의 이름을 my-extension.js로 지정하겠습니다. 확장 파일에서 함수를 만들고 모듈 내보내기의 register 속성에 할당합니다. 이 내보내기를 등록 함수라고 합니다. 함수를 내보내면 Antora가 함수에 액세스할 수 있습니다.
.my-extension.js
[source,js]
'use strict'
module.exports.register = () => {
}
선호하는 스타일이라면 함수 정의를 내보내기 문에서 분리할 수 있습니다.
.my-extension.js
[source,js]
'use strict'
const register = () => {
}
module.exports = { register }
또는 클래스 기반 확장으로 확장 기능을 정의할 수 있습니다.
확장 파일을 'use strict' 문으로 시작하는 것이 좋습니다. 이 문은 모든 버전의 Node.js에서 엄격 모드를 활성화합니다. 엄격 모드는 일반적인 프로그래밍 오류를 포착하는 제한된 JavaScript 변형을 활성화합니다. 이 문서 영역의 나머지 예제에서는 제외하지만 항상 존재한다고 가정합니다.
이 예제에서는 화살표 함수 구문을 사용하여 등록 함수를 정의합니다. 더 공식적인 function () {} 구문을 사용할 수도 있으며, 생성기 컨텍스트에 액세스하려면 이 구문을 사용해야 합니다.
스크립트를 플레이북 리포지토리에 넣습니다. 나중에 npmjs.com과 같은 패키지 리포지토리에 게시하여 다른 사이트나 브랜치 간에 공유할 수 있습니다.
지금까지 우리의 확장 기능은 실제로 아무 작업도 수행하지 않습니다. 등록 함수는 일종의 리스너이므로 플레이북이 빌드된 직후 작업을 수행할 기회로 사용할 수 있습니다. 인사를 하는 데 사용해 보겠습니다.
.my-extension.js
[source,js]
module.exports.register = () => {
console.log('Hello from Antora!')
}
재미있는 기능이지만 우리가 원하는 것은 아닙니다. 우리가 하고 싶은 것은 생성기의 메커니즘에 더 깊이 연결하여 실제 작업을 수행하고 Antora가 처리 중인 콘텐츠를 수정할 수 있도록 하는 것입니다. 이를 위해서는 생성기 컨텍스트를 가져와야 합니다.
등록 함수를 바인딩할 수 있는 경우, 즉 function 키워드 또는 이와 동등한 키워드를 사용하여 정의된 경우 Antora는 생성기 컨텍스트를 해당 함수의 this 키워드에 바인딩합니다. this 키워드는 확장 기능이 생성기 컨텍스트에 액세스할 수 있는 한 가지 방법입니다.
.my-extension.js
[source,js]
module.exports.register = function () {
this.on(...)
}
또는 함수가 생성기 컨텍스트를 첫 번째 매개변수로 받아들이는 경우(문자로 시작하는 모든 이름 사용) Antora는 this 키워드에 바인딩하는 대신 함수의 첫 번째 인수로 전달합니다.
.my-extension.js without binding
[source,js]
module.exports.register = (context) => {
context.on(...)
}
생성기 컨텍스트는 이벤트 리스너를 등록하는 데 사용됩니다. 그곳에 도달하기 전에 컨텍스트 변수에 액세스하기 위한 선택적 매개변수를 살펴보겠습니다.
등록 함수의 첫 번째 위치 매개변수(또는 함수가 생성기 컨텍스트를 첫 번째 매개변수로 선언하는 경우 두 번째 매개변수)는 컨텍스트 변수의 객체입니다. 이 객체에는 플레이북과 확장 구성이 포함됩니다. 이 객체에서 개별 변수를 선택하려면 객체 구조 분해를 사용해야 합니다.
모든 이벤트 리스너는 플레이북을 검색할 수 있지만 리스너를 등록할 때 더 일찍 필요할 수 있습니다. 등록 함수에서 플레이북에 액세스하는 방법은 다음과 같습니다:
.my-extension.js
[source,js]
module.exports.register = function ({ playbook }) {
console.log(Antora is building the ${playbook.site.title}.)
}
이제 확장 기능을 등록한 다음 이벤트 리스너를 추가해 보겠습니다.



== Extend Antora - Antora Extensions - Register an Extension

Antora에 등록될 때까지 확장 기능은 활성화되지 않습니다. 확장 기능을 등록하는 방법에는 두 가지가 있습니다. --extension CLI 옵션을 사용하여 지정하거나 플레이북 파일의 antora 카테고리 키 아래 extensions 키의 항목으로 나열할 수 있습니다.
등록되면 Antora는 플레이북 파일에 나열되거나 CLI에 전달된 순서대로 확장 기능의 등록 함수를 호출합니다. 플레이북 파일의 확장 기능은 CLI에 전달된 확장 기능보다 먼저 등록되지만, 요청 시 등록된 확장 기능을 활성화하여 이 순서를 변경할 수 있습니다.
CLI 옵션
플레이북 파일을 수정하지 않고 확장 기능을 등록(및 활성화)하는 빠른 방법은 antora CLI에서 제공하는 --extension 옵션을 사용하여 지정하는 것입니다. --extension CLI 옵션은 런타임에 Antora 플레이북의 extensions 키에 항목을 추가합니다.
다음은 이 CLI 옵션을 사용하여 확장 기능을 등록하는 방법의 예입니다.
[source,bash]
--extension ./my-extension.js
등록할 확장 기능이 둘 이상인 경우 이 옵션을 여러 번 지정할 수 있습니다.
CLI 옵션을 사용하려면 Antora를 실행할 때마다 더 긴 명령을 입력해야 합니다. 따라서 특히 항상 사용할 예정이라면 플레이북 파일에 지정하는 것이 좋습니다. 나중에 플레이북 파일에 추가하더라도 CLI를 사용하여 활성화 시기를 제어할 수 있다는 것을 알게 될 것입니다.
플레이북 키
Antora 확장 기능은 extensions 키를 사용하여 플레이북 파일에 등록할 수 있습니다. extensions 키는 antora 카테고리 키 아래에 지정됩니다. extensions 키의 값은 배열이어야 합니다. 배열의 각 항목은 문자열 또는 맵(키/값 쌍)입니다.
값이 문자열인 경우 값은 확장 스크립트를 확인하는 require 요청(즉, 경로 또는 모듈 이름)인 것으로 간주됩니다. 값이 맵인 경우 require 키를 사용하여 require 요청을 지정해야 합니다. 맵을 사용하면 사전 정의된 키(예: enabled)와 사용자 지정 키 모두에 대한 추가 구성 키를 사용할 수 있습니다.
확장 기능을 패키지 리포지토리에 게시하는 경우 require 요청은 해당 패키지의 이름(즉, 모듈 이름)이 됩니다. 이 경우 Node.js가 패키지를 가져오도록 패키지가 플레이북 프로젝트의 종속성으로 구성되어 있는지 확인하세요. Antora는 npm 패키지를 자동으로 다운로드하지 않습니다.
구성 없이
^^^
플레이북 파일에 확장 기능을 등록하여 작동하는 모습을 살펴보겠습니다. 가장 간단한 형태로, 확장 항목은 확장 스크립트에 대한 require 요청(즉, 경로)입니다.
.antora-playbook.yml with extension
[source,yaml]
antora:
extensions:

./my-extension.js


경로 앞에 ./를 붙여 위치가 플레이북 파일에 상대적임을 나타냅니다. Antora가 플레이북 파일에서 require 요청을 확인하는 방법을 알아보려면 @antora/user-require-helper 사용법을 참조하세요.
Antora를 실행하면 터미널에 다음과 같은 줄이 표시되어야 합니다:
[source,bash]
Antora is building the Example Docs.
구성 포함
^^^
확장 기능에 대한 구성 설정을 지정해야 하는 경우 항목 유형을 문자열에서 맵으로 변경해야 합니다. 이 변경을 수행할 때 require 키에 require 요청을 지정해야 합니다.
.antora-playbook.yml with extension specified using require key
[source,yaml]
antora:
extensions:

require: ./my-extension.js
optional_behavior: true


맵을 사용하면 require 키의 형제로 추가 키를 추가하여 확장 기능에 구성을 전달할 수 있습니다. 이러한 추가 키를 사용하여 확장 기능을 구성하는 방법의 예는 확장 기능 구성 페이지에서 찾을 수 있습니다.
다음 단계는 확장 기능에 이벤트 리스너를 추가하는 것입니다.



== Extend Antora - Antora Extensions - Add Event Listeners

Antora 확장 기능의 대부분의 작업은 이벤트 리스너에 의해 수행됩니다. 이벤트 리스너는 수신 대기 중인 이벤트가 발생할 때마다 호출되는 함수입니다. 리스너에서 반환되는 모든 값은 무시됩니다. 등록 함수는 이러한 리스너 함수를 특정 이벤트와 연결할 책임이 있습니다. 이를 위해 생성기 컨텍스트의 on 메서드에 이벤트 이름과 리스너 함수를 전달하여 리스너를 추가합니다. 생성기 컨텍스트의 API는 Node.js EventEmitter의 API를 따릅니다.
이벤트 리스너를 추가하도록 업데이트하여 정의한 확장 기능을 기반으로 구축해 보겠습니다. 생성기에서 발생하는 첫 번째 이벤트와 마지막 이벤트인 playbookBuilt 및 sitePublished 이벤트를 수신합니다. 이를 통해 사이트 생성 및 게시에 걸린 시간을 대략적으로 측정할 수 있습니다.
.time-generation-extension.js
[source,js]
module.exports.register = function () {
this
.on('playbookBuilt', () => {
console.time('generation time')
})
.on('sitePublished', () => {
console.timeEnd('generation time')
})
}
예제 1에서는 생성기 컨텍스트의 on 메서드를 사용하여 두 개의 리스너를 추가합니다. 하나는 playbookBuilt 이벤트가 발생할 때 호출되고 다른 하나는 sitePublished 이벤트가 발생할 때 호출됩니다. on 메서드는 생성기 컨텍스트를 반환하므로 이전 예제와 같이 호출을 연결하는 데 사용할 수 있습니다.
내장 이벤트는 한 번만 발생하므로 on 대신 once를 사용하여 내장 이벤트에 대한 리스너를 등록할 수 있습니다.
[source,js]
this.once('playbookBuilt', () => { ... })
once를 사용하면 매우 약간의 최적화를 제공합니다. 남아있는 리스너가 더 이상 없으면 이벤트 에미터가 스스로 비활성화되도록 합니다.
기본적으로 리스너는 추가된 순서대로 호출됩니다. 타이머가 다른 확장 기능의 리스너보다 먼저 시작되는 것을 보장하려면 playbookBuilt 리스너가 playbookBuilt 이벤트의 다른 리스너보다 먼저 호출되어야 하고 sitePublished 리스너는 sitePublished 이벤트의 다른 리스너 이후에 호출되어야 합니다. 이를 위해서는 두 가지 변경 사항이 필요합니다.
첫째, on 대신 prependListener 메서드를 사용하여 해당 이벤트와 이미 연결된 다른 리스너보다 먼저 playbookBuilt 리스너를 추가할 수 있습니다.
.time-generation-extension.js
[source,js]
module.exports.register = function () {
this
.prependListener('playbookBuilt', () => {
console.time('generation time')
})
.on('sitePublished', () => {
console.timeEnd('generation time')
})
}
둘째, 플레이북에서 확장 기능을 마지막에 나열해야 합니다. 이 두 가지 단계를 수행하면 타이머가 다른 모든 리스너를 둘러싸고 실행됩니다.
생성기의 특정 단계를 타이밍하려면 이 확장 기능을 업데이트하여 다른 생성기 이벤트를 수신하도록 할 수 있습니다. 타이머를 Node.js가 종료될 때까지 확장하려면 Node.js 프로세스 객체의 exit 이벤트를 수신할 수 있습니다.
[source,js]
process.on('exit', () => {
console.timeEnd('generation time')
})
Node.js 프로세스에서 발생하는 exit 이벤트 및 기타 이벤트에 대해 자세히 알아보려면 Node.js 프로세스 이벤트를 참조하세요.
생성기 컨텍스트가 상속하는 EventEmitter API는 리스너를 검색, 제거 및 다시 추가할 수 있도록 합니다. 이를 통해 필요한 경우 한 확장 기능이 다른 확장 기능에 의해 추가된 리스너를 재정렬할 수 있습니다. 확장 기능은 동일한 메서드를 사용하여 사용자 지정 이벤트를 발생시키고 수신할 수도 있습니다.
실행 시간을 측정하고 콘솔에 메시지를 출력하는 것보다 더 흥미로운 작업을 수행하려면 컨텍스트 변수를 사용해야 합니다. 다음으로 이 작업을 수행하는 방법을 알아보겠습니다.



== Extend Antora - Antora Extensions - Use Context Variables

Antora 확장 기능의 주요 목표는 주요 전환점에서 생성 프로세스에 연결되는 코드를 작성하고 해당 시점에 시스템을 통해 흐르는 변수에 액세스할 수 있도록 하는 것입니다. 이러한 컨텍스트 변수에 액세스하기 시작하면 확장 기능의 재미가 시작됩니다.
컨텍스트 변수에 액세스
컨텍스트 변수는 이벤트가 발생할 때 범위 내에 있고 생성기가 생성기 컨텍스트에 바인딩하는 변수입니다. 확장 기능에서 컨텍스트 변수에 액세스하여 다음을 수행할 수 있습니다:

객체에서 속성 읽기
객체에서 메서드 호출
객체의 속성 수정(객체가 고정되지 않은 경우)

컨텍스트 변수 업데이트에서는 객체의 프록시로 변수를 대체하는 방법에 대해 알아봅니다. 이는 또 다른 옵션입니다.
각 이벤트 리스너의 첫 번째 위치 매개변수는 컨텍스트 변수의 객체입니다. 객체 구조 분해를 사용하여 이 객체에서 개별 변수를 선택해야 합니다(예: { playbook }). 각 이벤트의 범위 내 변수는 생성기 이벤트 참조 페이지에 정의되어 있습니다.
이 목적으로 보충 UI를 사용하는 대신 사이트 카탈로그를 검색하고 .nojekyll 파일을 추가하는 방식으로 확장 기능을 구축해 보겠습니다.
.nojekyll-extension.js
[source,js]
module.exports.register = function () {
this.on('beforePublish', ({ siteCatalog }) => {
siteCatalog.addFile({ contents: Buffer.alloc(0), out: { path: '.nojekyll' } })
})
}
예제 1에서는 { siteCatalog }를 사용하여 컨텍스트에서 사이트 카탈로그를 검색합니다. 여러 변수를 검색하려면 쉼표를 사용하여 변수 이름을 구분합니다(예: { playbook, siteCatalog }).
컨텍스트 변수는 getVariables 메서드를 사용하여 생성기 컨텍스트에서 직접 검색할 수도 있습니다:
[source,js]
const { siteCatalog } = this.getVariables()
내장 컨텍스트 변수 외에도 확장 기능은 다른 확장 기능에서 문서화되고 게시된 컨텍스트 변수에 액세스할 수 있습니다.
컨텍스트 변수 업데이트
대부분의 확장 기능은 컨텍스트 변수를 읽고 참조된 객체의 메서드와 상호 작용하지만 컨텍스트 변수를 추가하거나 대체할 수도 있습니다. 한 가지 사용 사례는 동일한 확장 기능의 다른 확장 기능 또는 리스너가 액세스할 수 있는 새 변수를 정의하는 것입니다. 이는 생성기를 통해 추가 데이터를 전달하는 한 가지 방법입니다. 또 다른 사용 사례는 생성기에서 사용하는 내장 변수를 대체하는 것입니다. 아마도 프록싱을 통해서 말이죠. Antora의 동작을 drastically하게 변경해야 하고 카탈로그에서 파일을 추가하거나 제거하여 수행할 수 없는 경우 이 작업을 수행할 수 있습니다.
콘텐츠 카탈로그를 프록시하여 별칭을 등록하지 못하도록 하려는 경우를 고려해 보겠습니다. 예제 2에서는 contentClassified 이벤트를 수신하고 contentCatalog 컨텍스트 변수를 검색한 다음 객체의 프록시로 변수를 대체합니다.
.객체의 프록시로 변수 대체
[source,js]
module.exports.register = function () {
this.on('contentClassified', function ({ contentCatalog }) {
contentCatalog = new Proxy(contentCatalog, {
get(target, property) {
return property === 'registerPageAlias' ? () => undefined : target[property]
},
})
this.updateVariables({ contentCatalog })
})
}
예제 2는 자신의 구현으로 registerPageAlias 함수를 대체하기 위한 시작점을 제공합니다.
이전 예제에서는 화살표 함수 대신 공식 function 키워드를 사용하여 리스너를 선언합니다. 이런 방식으로 함수를 정의하면 표준 this 키워드에 액세스할 수 있습니다. 이는 생성기 컨텍스트에 대한 참조입니다. 리스너가 등록되면 Antora는 함수를 생성기 컨텍스트에 바인딩하여 표준 this 키워드를 사용하여 함수 내에서 생성기 컨텍스트에 액세스할 수 있도록 합니다.
컨텍스트 변수 잠금
내장 컨텍스트 변수가 확립되면, 일반적으로 변수가 도입된 이벤트가 발생한 후에는 해당 변수가 잠깁니다. 이 규칙에는 예외가 있지만 대부분 그대로 유지됩니다. 잠긴 변수는 교체할 수 없습니다. 교체를 시도하면 오류가 발생합니다.
잠긴 내장 변수와 잠기는 시기는 생성기 이벤트 참조 페이지에 표시되어 있습니다.
내장 변수가 잠기는 이유는 두 가지입니다. 첫째, 변수를 반드시 대체해야 하는 경우 언제 대체해야 하는지 알려줍니다. 둘째, 사이트 생성기와 다른 확장 기능이 해당 변수가 교체되었는지 확인할 필요 없이 해당 변수에 대한 로컬 참조를 저장할 수 있도록 합니다.
잠긴 변수는 변수 자체가 교체되는 것만 방지합니다. 객체에 속성을 추가, 업데이트 또는 제거하는 등 변수가 참조하는 객체를 수정할 수 있습니다. 단, 고정 객체인 플레이북은 예외입니다.



== Extend Antora - Antora Extensions - Configure an Extension

작성하거나 사용하는 확장 기능은 동작을 구성하기 위해 추가 설정이 필요할 수 있습니다. 확장 기능이 플레이북 또는 Antora가 구축 중인 콘텐츠 소스에서 이미 사용 가능한 정보를 활용할 수 있지만 확장 기능을 직접 구성해야 할 수도 있습니다. 확장 기능은 플레이북 파일의 항목에 지정된 중첩될 수 있는 임의의 수의 속성을 허용할 수 있습니다. 이러한 속성은 확장 기능의 등록 함수에 전달되는 config라는 컨텍스트 변수를 통해 액세스할 수 있습니다.
기본 구성
문서 사이트를 만드는 사람들에게 크레딧을 주기 위해 humans.txt라는 파일을 게시한다고 가정해 보겠습니다. 확장 기능의 이름을 humans-txt-extension.js라고 지정하겠습니다. 물론 확장 기능은 누구에게 크레딧을 줘야 할지 모르므로 일부 구성을 전달해야 합니다.
플레이북에서 새 확장 기능을 등록하고 names 키를 사용하여 사람 목록을 전달하는 것부터 시작하겠습니다. 이 키의 값은 이름 배열이 됩니다.
[source,yaml]
antora:
extensions:

require: ./humans-txt-extension.js
names:

Doc Writer
Dr. Austen
Emily Story




추가 키를 위한 공간을 만들기 위해 확장 기능의 항목을 단일(문자열) 값에서 맵으로 변환했습니다. require 요청 값은 require 키로 이동합니다. 그러면 추가 키를 정의할 공간이 남습니다. 이 경우에는 names입니다.
이제 이 구성을 수락하고 사용하여 humans.txt 파일을 만드는 확장 기능을 작성해 보겠습니다:
.humans-txt-extension.js
[source,js]
module.exports.register = function ({ config }) {
this.on('beforePublish', ({ siteCatalog }) => {
const teamInfo = '/* TEAM */\n' + config.names.map((name) => Name: ${name}).join('\n')
const contents = Buffer.from(teamInfo + '\n')
siteCatalog.addFile({ contents, out: { path: 'humans.txt' } })
})
}
확장 기능의 config 객체는 다른 컨텍스트 변수와 마찬가지로 객체 구조 분해를 사용하여 액세스합니다. JavaScript의 변수 범위 지정 덕분에 beforePublish 이벤트의 리스너에서 해당 변수에 계속 액세스할 수 있습니다. 제공된 정보를 사용하여 humans.txt 파일의 내용을 채우고 사이트 카탈로그에 추가합니다. 그러면 Antora는 게시된 사이트에 humans.txt 파일을 포함합니다.
구성 키 변환
YAML에서 키 이름은 snake_case 명명 규칙을 사용합니다. JavaScript에서 속성 이름은 camelCase 명명 규칙을 사용합니다. YAML과 JavaScript 간의 명명 규칙 불일치를 해결하기 위해 Antora는 플레이북 파일의 snake_case 키 이름을 자동으로 구성 객체의 camelCase 속성으로 변환합니다. 예를 들어 Antora는 cache_dir을 cacheDir로 변환합니다. 대부분의 경우 이는 문제가 되지 않습니다. 그러나 확장 기능이 구성 또는 데이터를 다른 애플리케이션에 전달하는 경우 이 변환은 문제가 될 수 있습니다.
구성 데이터
이 구성을 우회하려면 data 키 안에 키를 숨길 수 있습니다. data 키(임의의 깊이에서) 내의 모든 키는 수정 없이 전달됩니다.
humans.txt 파일에 대한 구조화된 콘텐츠를 지정하려 한다고 가정해 보겠습니다. Antora가 이 구조화된 콘텐츠를 변환할 필요가 없으므로 data라는 키 안에 저장할 수 있습니다.
[source,yaml]
antora:
extensions:

require: ./humans-txt-extension.js
data:
TEAM:

Lead Writer: Doc Writer
Contact: doc [at] example.org
Location: Denver, CO
Information Architect: Dr. Austen
Location: Winchester, Hampshire, England
Narrator: Emily Story
Location: Antwerp, Belgium




이제 확장 기능은 config.data의 키를 반복하고 humans.txt 파일의 내용을 레이아웃할 수 있습니다.
[source,js]
const contents = Buffer.from(
Object.entries(config.data).reduce((accum, [category, entries]) => {
if (accum.length) accum.push('')
accum.push(/* ${category} */)
entries.forEach((entry) => {
accum.push('')
for (const [key, val] of Object.entries(entry)) accum.push(${key}: ${val})
})
return accum
}, []).join('\n')
)



== Extend Antora - Antora Extensions - Enable an Extension

기본적으로 플레이북 파일에서 확장 기능을 등록하면 Antora가 자동으로 활성화합니다. 요청 시에만 확장 기능을 활성화하는 한 가지 방법은 CLI 옵션(--extension)을 사용하여 지정하는 것입니다. 그러나 그것만으로는 구성 키를 제공하거나 로드 순서에 영향을 줄 수 없습니다. 여기서 확장 기능 활성화가 작동합니다.
플레이북 파일에서 선택적 구성과 함께 확장 기능을 등록한 다음 Antora에게 활성화하지 않도록 지시할 수 있습니다. 그런 다음 CLI 옵션(--extension)을 사용하여 활성화할 수 있으며, 플레이북에 나열된 순서대로 다른 확장 기능에 상대적으로 등록됩니다.
Antora가 플레이북 파일에 지정된 확장 기능을 활성화하지 않도록 하려면 미리 정의된 구성 키 enabled를 false 값으로 설정합니다. Antora는 enabled 키의 값이 false인 것을 보면 확장 기능을 등록하지 않습니다.
.활성화되지 않은 확장 기능
[source,yaml]
antora:
extensions:

require: ./my-extension.js
enabled: false
custom: value


enabled 키를 사용하여 플레이북에서 확장 기능을 제거하지 않고도 빠르게 끌 수 있습니다. 그러나 더 많은 경우 CLI 옵션을 사용하여 활성화할 수 있도록 이러한 방식으로 표시합니다. 그러나 그렇게 하려면 참조할 수 있는 방법이 필요합니다. 그것이 미리 정의된 구성 키 id의 목적입니다. id 키는 --extension CLI 옵션을 사용하여 플레이북 파일에서 활성화되지 않은 것으로 표시된 확장 기능을 활성화하기 위해 참조할 수 있는 값을 지정합니다.
먼저 확장 기능에 ID를 부여해 보겠습니다:
.ID가 있지만 활성화되지 않은 확장 기능
[source,yaml]
antora:
extensions:

id: my-extension
require: ./my-extension.js
enabled: false
custom: value


이제 CLI에서 다음과 같이 이 확장 기능을 활성화할 수 있습니다:
[source,console]
$ antora --extension=my-extension antora-playbook.yml
일반적으로 --extension CLI 옵션의 값은 require 요청이지만, 확장 기능을 활성화하는 경우 값은 플레이북 파일에서 확장 기능 항목의 ID입니다.
Antora가 --extension CLI 옵션의 값과 일치하는 ID를 가진 항목을 찾을 수 없는 경우 해당 값을 require 요청으로 처리하는 것으로 대체됩니다.



== Extend Antora - Antora Extensions - Extension Helpers

생성기 컨텍스트는 확장 기능 작성을 쉽게 만드는 여러 유틸리티 메서드를 제공합니다. 이러한 유틸리티 메서드는 확장 기능 작성에 도움이 되므로 도우미라고 합니다.

도우미 액세스
도우미는 GeneratorContext API를 제공하는 생성기 컨텍스트에 위치합니다. 따라서 도우미를 사용하려면 생성기 컨텍스트에 대한 참조가 필요합니다.

생성기 컨텍스트를 가져오는 방법에는 두 가지가 있습니다. 리스너 함수가 확장 기능의 등록 함수 내에 정의된 경우 변수 범위를 통해 등록 함수에서 생성기 컨텍스트에 액세스할 수 있습니다. 그렇지 않으면 리스너 함수는 표준 this 키워드를 사용하여 생성기 컨텍스트를 참조할 수 있습니다. 리스너 함수가 등록될 때 생성기 컨텍스트가 리스너 함수에 바인딩됩니다.

getVariables()
컨텍스트 변수에 액세스하는 한 가지 방법은 객체 구조 분해(예: { playbook })를 사용하여 등록 함수 또는 이벤트 리스너 함수의 첫 번째 매개변수를 통해 수락하는 것입니다. 그러나 컨텍스트 변수가 조건부로만 필요한 상황이 있을 수 있습니다. 함수 시그니처를 단순화하기 위해 getVariables 도우미를 사용하여 생성기 컨텍스트에서 직접 컨텍스트 변수를 검색할 수 있습니다.

다음은 getVariables 메서드를 사용하여 생성기 컨텍스트(this에 바인딩됨)에서 컨텍스트 변수에 액세스하는 방법의 예입니다:

[source,js]
const { playbook, contentCatalog } = this.getVariables()
매개변수 구조 분해는 여전히 등록 함수가 확장 기능의 config 객체에 액세스하는 유일한 방법입니다.

updateVariables(Object)
updateVariables 도우미 메서드는 컨텍스트 변수를 추가하거나 대체할 수 있는 수단을 제공합니다. 이 메서드는 Object 유형의 단일 인수를 허용하며, 객체의 키는 변수 이름이고 값은 변수 값입니다. 이 메서드는 값을 반환하지 않습니다.

변수를 제거하려면 값을 undefined로 지정하세요. 잠긴 변수는 교체할 수 없습니다.

다음은 리스너에서 playbook 및 siteCatalog 변수를 대체하는 방법을 보여주는 예입니다:

[source,js]
playbook = JSON.parse(JSON.stringify(playbook)) siteCatalog = new Proxy(siteCatalog, {}) this.updateVariables({ playbook, siteCatalog })
updateVariables 메서드를 사용하여 컨텍스트에 새 변수를 도입할 수도 있습니다. 사이트 생성기는 이러한 변수를 인식하거나 사용하지 않습니다. 그러나 다른 확장 기능이나 동일한 확장 기능의 리스너에서 사용할 수 있습니다.

stop(Integer)
stop 도우미 메서드는 정상적인 종료를 사용하여 생성기의 작동을 중지할 수 있는 방법을 제공합니다. 이 메서드는 선택적 종료 코드 값을 허용하고 값을 반환하지 않습니다.

호출되면 이 메서드는 컨텍스트가 contextStopped 및 contextClosed 이벤트를 발생시킵니다. 실패 수준 임계값을 초과하는 메시지가 로깅되면 Antora는 0이 아닌 종료 코드로 종료됩니다. 그렇지 않으면 Antora는 지정된 종료 코드 또는 종료 코드가 지정되지 않은 경우 0 종료 코드(즉, 성공적으로)로 종료됩니다.

stop 도우미는 Antora를 부분적으로만 실행해야 하고 Antora를 중지하기 위해 오류를 throw하고 싶지 않은 경우에 유용합니다. 캐시를 워밍업하거나 참조 유효성 검사를 수행하는 데 사용할 수 있습니다. sitePublished 이벤트 전에 stop을 호출하면 Antora가 사이트를 게시하지 않습니다.

다음은 리스너에서 Antora에게 처리를 중지하도록 신호를 보내는 방법을 보여주는 예입니다:

[source,js]
console.log('Our work is done here. Wrap it up.') this.stop()
getLogger(String)
getLogger 도우미 메서드를 사용하면 로거의 인스턴스를 검색할 수 있습니다.

다음은 로거의 인스턴스를 검색하고 리스너에서 사용하는 방법을 보여주는 예입니다:

[source,js]
module.exports.register = function () { const logger = this.getLogger('extension-name') this.on('playbookBuilt', () => { logger.info('Let it be known. The playbook has been built!') }) }
이 확장 기능을 활성화하고(--log-level=info 옵션과 함께) Antora를 실행하면 터미널에 다음 메시지가 표시됩니다:

[source,bash]
[12:24:37.731] INFO (extension-name): Let it be known. The playbook has been built!
require(String)
require 도우미 메서드를 사용하면 Antora 설치의 컨텍스트 내에서 라이브러리를 요구할 수 있습니다. 이 메서드는 String 유형의 단일 인수를 허용하며, 이는 require 요청(즉, Node.js 모듈 또는 모듈 내의 소스 파일 이름)입니다. 이 메서드는 지정된 모듈 또는 소스 파일이 내보내는 객체를 반환합니다. 요청을 확인할 수 없는 경우 이 메서드는 code MODULE_NOT_FOUND와 함께 Error를 throw합니다.

확장 기능을 작성할 때 때때로 Antora에서 제공하는 코드에 액세스해야 할 수 있습니다. 예로는 로거, ContentCatalog 또는 parseResourceId와 같은 유틸리티 함수가 있습니다. 이 메서드를 사용하면 Antora에 대한 종속성을 선언하지 않고도 이 코드를 요구할 수 있습니다. 확장 기능이 Antora의 컨텍스트 내에서 실행되므로 해당 종속성은 암시적입니다. 이 메서드는 해당 코드를 요구하는 방법을 제공합니다.

다음은 리스너에서 현재 실행 중인 사이트 생성기의 버전을 가져오는 방법을 보여주는 예입니다:

[source,js]
const { name, version } = this.require('@antora/site-generator/package') console.log(Running ${name} version ${version})
확장 기능이 이미 사이트 생성기의 컨텍스트에서 실행 중이므로 동일한 결과를 얻는 약간 더 간단한 방법은 다음과 같습니다:

[source,js]
const { name, version } = this.require('../package') console.log(Running ${name} version ${version})
보다 실용적인 예로, require 도우미 메서드를 사용하여 확장 기능에 대한 자식 로거를 만들 수 있습니다. 일반적으로 등록 함수에서 이 작업을 수행한 다음 확장 기능 전체에서 로거의 동일한 인스턴스에 액세스합니다.

[source,js]
module.exports.register = function () { const logger = this.require('@antora/logger')('extension-name') this.on('playbookBuilt', () => { logger.info('Let it be known. The playbook has been built!') }) }
이 확장 기능을 활성화하고(--log-level=info 옵션과 함께) Antora를 실행하면 터미널에 다음 메시지가 표시됩니다:

[source,bash]
[12:24:37.731] INFO (extension-name): Let it be known. The playbook has been built!
로거 인스턴스를 검색하는 더 간단한 방법은 getLogger(String) 메서드를 사용하는 것입니다.



== Extend Antora - Antora Extensions - Class-Based Extension

확장 기능이 여러 이벤트를 수신하고 상태를 추적할 경우 확장 기능을 JavaScript 클래스로 정의하는 것을 고려할 수 있습니다. 클래스는 객체를 생성하기 위한 템플릿입니다. 데이터와 해당 데이터에 대해 작동하는 메서드를 모두 캡슐화합니다. 이 캡슐화는 확장 기능을 더 체계적으로 유지하는 데 도움이 될 수 있습니다. 어려운 점은 Antora 확장 기능으로 사용할 수 있는 방식으로 클래스를 정의하는 방법을 고안하는 것입니다. 이 페이지에서는 이를 수행하는 방법을 보여줍니다.
확장 클래스 구조
클래스 기반 확장 기능의 기본 구조는 다음과 같습니다:

확장 기능의 이름을 따서 클래스 정의(예: MyExtension)
Antora가 호출할 수 있는 정적 register 메서드 추가
리스너를 인스턴스 메서드로 정의(예: onPlaybookBuilt({ playbook }))
생성기 컨텍스트를 허용하고 클래스에서 리스너를 등록하는 생성자 추가
클래스 정의 내보내기

확장 클래스의 골격은 다음과 같습니다:
[source,js]
class MyExtension {
}
세부 정보를 채워보겠습니다.
register 메서드와 인스턴스화
Antora는 클래스의 인스턴스를 생성하지 않지만 클래스의 정적 register 메서드를 사용하여 인스턴스를 생성할 수 있습니다. Java에서 오는 경우 클래스의 main 메서드와 같다고 생각할 수 있습니다. 해당 진입점은 다음과 같습니다:
[source,js]
class MyExtension {
static register () {
new MyExtension(this)
}
}
module.exports = MyExtension
Antora는 내보낸 클래스 정의의 register 메서드만 보게 되며, Antora는 이를 호출하여 프로세스를 시작합니다. 나머지 작업은 확장 인스턴스에서 발생합니다.
정적 register 메서드가 정적 함수에서 확장 클래스의 인스턴스로 전환되었음을 확인하세요. register 메서드는 생성기 컨텍스트를 확장 클래스의 생성자에 전달하여 생성자가 생성기 컨텍스트에 액세스하고 참조를 저장할 수 있도록 합니다.
리스너 메서드
리스너는 확장 클래스의 메서드로 정의됩니다. 다른 리스너 함수와 마찬가지로 호출되지만 클래스의 현재 인스턴스(this)와 생성기 컨텍스트(this.context)에 대한 참조를 모두 가지게 됩니다. 그래서 확장 기능(확장 상태)의 속성과 생성기의 컨텍스트 변수에 모두 액세스할 수 있습니다. 다음은 리스너가 메서드로 정의된 확장 클래스입니다:
[source,js]
class MyExtension {
static register () {
new MyExtension(this)
}
onPlaybookBuilt () {
this.startTime = +new Date
}
onSitePublished () {
const elapsed = (+new Date - this.startTime) / 1000
const logger = this.context.getLogger('my-extension')
logger.info(elapsed time: ${elapsed}s)
}
}
module.exports = MyExtension
이제 남은 것은 이러한 리스너를 이벤트에 연결하는 것뿐입니다.
생성자와 리스너 추가
다음 단계는 생성기 컨텍스트를 허용하고 리스너를 추가하는 생성자를 만드는 것입니다. 생성자가 있는 확장 클래스는 다음과 같습니다:
[source,js]
class MyExtension {
static register () {
new MyExtension(this)
}
constructor (generatorContext) {
;(this.context = generatorContext)
.on('playbookBuilt', this.onPlaybookBuilt.bind(this))
.on('sitePublished', this.onSitePublished.bind(this))
}
onPlaybookBuilt () {
this.startTime = +new Date
}
onSitePublished () {
const elapsed = (+new Date - this.startTime) / 1000
const logger = this.context.getLogger('my-extension')
logger.info(elapsed time: ${elapsed}s)
}
}
module.exports = MyExtension
각 리스너를 추가할 때 확장 인스턴스(즉, this)에 바인딩해야 합니다. 그렇지 않으면 리스너는 확장 인스턴스의 속성에 액세스할 수 없습니다. 리스너는 생성자가 생성기 컨텍스트를 할당하는 context 속성을 사용하여 여전히 생성기 컨텍스트에 액세스할 수 있습니다.
보았듯이 클래스 기반 확장 기능을 사용하면 확장 기능 코드를 더 체계적으로 유지할 수 있습니다. 또한 확장 기능은 상속, 컴포지션 및 위임과 같은 다른 객체 지향 패턴을 활용할 수 있습니다.



== Extend Antora - Antora Extensions - Asynchronous Listeners

Antora는 등록된 순서대로 리스너를 동기적으로 호출합니다. 리스너가 async 키워드를 사용하여 비동기로 표시되거나 리스너가 Promise를 반환하더라도 마찬가지입니다. Antora는 다음 리스너를 호출하기 전에(따라서 자체 작업을 계속하기 전에) 리스너 호출이 완료될 때까지 기다립니다. 이 동작은 Node.js의 내장 NodeEmitter의 동작과 다릅니다.
리스너를 async로 표시하거나 Promise를 반환하는 이점은 리스너가 비동기 작업을 수행할 수 있다는 것입니다. 물론 Antora가 진행되기 전에 이러한 모든 작업이 해결되므로 함수 경계 외부에서 동기식 방식으로 동작하도록 만들어집니다.
Promise는 프로그램이 await를 호출할 때 종료됩니다. 분명히 이 요구사항은 프로그램의 최상위 함수까지 거슬러 올라갑니다. Antora는 확장 리스너를 async로 정의하거나 Promise를 반환할 수 있도록 하여 이 세부 사항을 숨깁니다.
URL에서 파일을 가져와 사이트에 게시하는 예제를 살펴보겠습니다.
.fetch-and-publish-readme-extension.js
[source,js]
module.exports.register = function () {
this.on('beforePublish', async ({ siteCatalog }) => {
const https = require('https')
const contents = await new Promise((resolve, reject) => {
const buffer = []
https
.get('https://gitlab.com/antora/antora/-/raw/HEAD/README.adoc', (response) => {
response.on('data', (chunk) => buffer.push(chunk.toString()))
response.on('end', () => resolve(buffer.join('').trimRight()))
})
.on('error', reject)
})
siteCatalog.addFile({ contents: Buffer.from(contents), out: { path: 'README.adoc' } })
})
}
리스너 함수에 async 키워드를 추가했음을 확인하세요. 이를 통해 함수 내에서 await 키워드를 사용할 수 있습니다.
연습으로, 각 콘텐츠 소스의 각 브랜치에서 파일을 검색하여 게시된 사이트에 추가해 볼 수 있습니다. 힌트를 드리자면, 콘텐츠 소스 목록을 가져오려면 playbook 변수에 액세스해야 합니다.
Antora가 비동기 리스너 완료를 기다리지 않도록 하려면 빈 promise를 반환하거나(예: return Promise.resolve()) 리스너에서 async 키워드를 제거하면 됩니다. 그러나 그렇게 하려면 Antora가 완료되기 전에 promise를 해결할 수 있도록 생성기의 나중에 발생하는 이벤트(예: contextClosed)를 수신하는 리스너를 추가해야 합니다.
이전과 동일한 예제를 살펴보겠지만, 사이트가 생성되는 동안 백그라운드에서 README.adoc을 다운로드합니다. 보류 중인 promise의 상태를 관리하는 데 도움이 되도록 클래스 기반 확장으로 다시 작성되었습니다.
.background-fetch-and-publish-readme-extension.js
[source,js]
const https = require('https')
class FetchAndPublishReadmeExtension {
static register ({ config }) {
return new FetchAndPublishReadmeExtension(this, config)
}
constructor (context, config) {
;(this.context = context)
.on('playbookBuilt', this.onPlaybookBuilt.bind(this))
.on('beforePublish', this.onBeforePublish.bind(this))
this.readmeUrl = config.readmeUrl || 'https://gitlab.com/antora/antora/-/raw/HEAD/README.adoc'
this.contentsPromise = undefined
}
playbookBuilt ({ siteCatalog }) {
this.contentsPromise = new Promise((resolve, reject) => {
const buffer = []
https
.get(this.readmeUrl, (response) => {
response.on('data', (chunk) => buffer.push(chunk.toString()))
response.on('end', () => resolve(buffer.join('').trimRight()))
})
.on('error', reject)
})
}
async onBeforePublish ({ siteCatalog }) {
const contents = await this.contentsPromise
siteCatalog.addFile({ contents: Buffer.from(contents), out: { path: 'README.adoc' } })
}
}
module.exports = FetchAndPublishReadmeExtension
onBeforePublish 리스너 함수만 async이므로 onPlaybookBuilt 리스너 함수에 의해 시작된 promise를 기다릴 수 있습니다. 이제 확장 기능은 readme_url이라는 구성 키로 README의 URL도 허용합니다.



== Extend Antora - Antora Extensions - Replace Generator Functions

Antora의 사이트 생성기는 일련의 단계로 구현됩니다. 각 단계는 함수에 의해 수행됩니다. 이러한 함수를 생성기 함수라고 합니다. 생성기 함수는 convertDocument와 같이 생성기 함수가 수행할 수 있는 주요 하위 단계에 대한 함수를 포함할 수 있습니다.
생성기는 생성기 컨텍스트에서 이러한 함수를 검색합니다. 이러한 함수는 Antora 확장 기능에 의해 프로그래밍 방식으로 검색 및 교체될 수도 있습니다. 따라서 이러한 생성기 함수는 교체 가능하도록 설계되어 Antora를 확장하는 더 강력한 방법을 제공합니다.
확장 기능에서 함수를 교체하면 Antora의 주요 버전 사이에 코드가 손상될 위험이 더 커집니다.
함수 가져오기
컨텍스트 변수와 마찬가지로 생성기 함수는 생성기 컨텍스트에서 사용할 수 있습니다. 생성기 함수는 contextStarted 이벤트의 리스너 내에서 또는 그 이후 언제든지 getFunctions 메서드를 호출하여 검색할 수 있습니다. 이 메서드는 키-값 쌍의 객체를 반환하며, 키는 함수 이름이고 값은 함수 객체입니다.
내장 생성기 함수는 contextStarted 이벤트가 발생할 때까지 사용할 수 없습니다.
다음은 this가 생성기 컨텐츠에 바인딩되어 있다고 가정할 때 확장 기능에서 aggregateContent 함수를 검색하는 방법을 보여주는 예제입니다.
[source,js]
this.once('contextStarted', () => {
const { aggregateContent } = this.getFunctions()
})
생성기 함수를 검색하는 한 가지 이유는 유틸리티로 사용하기 위해서입니다. 예를 들어 확장 기능에서 Antora와 같이 AsciiDoc을 로드해야 하는 경우 이 목적으로 loadAsciiDoc 함수를 검색할 수 있습니다. 다음은 그 예시입니다:
[source,js]
this.once('contentClassified', (contentCatalog, siteAsciiDocConfig) => {
const { loadAsciiDoc } = this.getFunctions()
const page = contentCatalog.resolvePage('ROOT::index.adoc')
const scopedAsciiDocConfig = contentCatalog.getComponentVersion(page.src.component, page.src.version).asciidoc
const doc = loadAsciiDoc(page, contentCatalog, scopedAsciiDocConfig || siteAsciiDocConfig)
const sections = doc.findBy({ context: 'section' }, (it) => it !== doc.getHeader())
console.log(sections.map((it) => it.getTitle()))
})
생성기 함수를 검색하는 또 다른 이유는 장식(래핑)하기 위해서입니다. 이 경우 원래 함수를 장식된 함수로 교체해야 합니다. 또는 원래 함수를 자신의 구현으로 교체할 수 있습니다.
함수 교체
생성기 함수를 교체하면 Antora의 사이트 생성기의 단계를 재정의할 수 있습니다.
생성기 함수는 replaceFunctions 메서드에 함수를 전달하여 교체할 수 있습니다. 이 메서드는 getFunctions 메서드가 반환하는 것과 동일한 객체 시그니처를 허용하며, 키는 함수 이름이고 값은 함수 객체입니다.
교체할 함수만 replaceFunctions에 전달하면 됩니다. 생성기는 교체되지 않은 함수에 대해 기본적으로 내장 함수를 사용합니다.
다음은 확장 기능에서 publishFiles 함수를 교체하는 방법을 보여주는 예제입니다:
[source,js]
module.exports.register = function () {
this.replaceFunctions({
async publishFiles () {
console.log('Not publishing today')
return []
}
})
}
함수를 교체하는 시점이 중요합니다. 등록 메서드에서 직접 함수를 교체하면(contextStarted 이벤트가 발생하기 전) Antora가 해당 내장 함수를 요구하고 등록하는 것을 중지합니다. contextStarted 리스너에서 함수를 교체하면 이미 요구되고 등록된 해당 내장 함수를 교체합니다.
contextStarted 이벤트는 여기에 표시된 대로 내장 함수에 위임(즉, 래핑)할 수 있는 기회를 제공합니다:
[source,js]
module.exports.register = function () {
this.once('contextStarted', () => {
const { publishFiles: publishFilesDelegate } = this.getFunctions()
this.replaceFunctions({
async publishFiles (playbook, catalogs) {
console.log('It's publish time!')
return publishFilesDelegate.call(this, playbook, catalogs)
}
})
})
}
함수를 교체할 때는 함수 참조에 정의된 대로 함수의 시그니처를 준수해야 합니다. 등록 함수 및 이벤트 리스너 함수와 마찬가지로 생성기 함수는 자동으로 생성기 컨텍스트에 바인딩됩니다.
함수 참조
확장 기능에 의해 교체될 수 있는 함수의 목록은 다음과 같이 시그니처와 함께 표시됩니다:

aggregateContent(playbook): Promise<Object>
buildNavigation(contentCatalog, siteAsciiDocConfig): NavigationCatalog
classifyContent(playbook, contentAggregate, siteAsciiDocConfig): ContentCatalog
convertDocument(file, contentCatalog, siteAsciiDocConfig): File
convertDocuments(contentCatalog, siteAsciiDocConfig): void
createPageComposer(playbook, contentCatalog, uiCatalog, env): Function
extractAsciiDocMetadata(doc): Object
loadAsciiDoc(file, contentCatalog, config): Document
loadUi(uiCatalog): Promise<UiCatalog>
mapSite(playbook, publishablePages): File[]
produceRedirects(playbook, contentCatalog): File[]
publishFiles(playbook, catalogs): Promise<Object[]>
resolveAsciiDocConfig(playbook): Object

이러한 함수에 대해 자세히 알아보려면 Antora 소스 코드를 참조하세요.



== Extend Antora - Antora Extensions - Extension Tutorial

Antora 확장 기능의 작동 방식을 이해하고 개념을 확실히 파악했다면 이 페이지에서는 전체 보기를 제공하고 Antora의 이 기능을 최대한 활용할 수 있도록 심층적인 예제를 통해 안내하는 종단 간 튜토리얼을 제공합니다.
이 튜토리얼에서는 목록에 없는 페이지, 즉 내비게이션에서 액세스할 수 없는 페이지를 찾는 확장 기능을 만들 것입니다. 확장 기능은 먼저 각 구성 요소 버전에 대한 내비게이션 트리를 검색합니다. 그런 다음 해당 구성 요소 버전의 페이지를 반복하고 해당 내비게이션 트리에서 찾을 수 없는 페이지를 찾습니다. 목록에 없는 페이지를 찾으면 각 페이지에 대해 경고를 로그합니다. 그렇게 하도록 구성된 경우 내비게이션의 전용 카테고리 아래에 해당 페이지를 추가합니다.
이 예제에서는 확장 기능에서 사용할 수 있는 대부분의 기능을 사용할 수 있는 기회를 제공합니다. 확장 기능을 생성하고 플레이북에 등록하고 구성한 다음 마지막으로 활성화된 상태로 Antora를 실행합니다. 시작해 보겠습니다.
확장 기능 생성
시작하려면 먼저 확장 기능을 생성해야 합니다. 확장 파일의 이름을 unlisted-pages-extension.js로 지정하고 플레이북 리포지토리에 깔끔하게 정리되도록 플레이북에 인접한 lib/ 폴더에 배치합니다.
예제 1에 표시된 소스 코드로 확장 파일을 채웁니다. 다음 섹션에서는 이 코드가 수행하는 작업을 분석합니다.
.lib/unlisted-pages-extension.js
[source,js]
module.exports.register = function ({ config }) {
const { addToNavigation, unlistedPagesHeading = 'Unlisted Pages' } = config
const logger = this.getLogger('unlisted-pages-extension')
this
.on('navigationBuilt', ({ contentCatalog }) => {
contentCatalog.getComponents().forEach(({ versions }) => {
versions.forEach(({ name: component, version, navigation: nav, url: defaultUrl }) => {
const navEntriesByUrl = getNavEntriesByUrl(nav)
const unlistedPages = contentCatalog
.findBy({ component, version, family: 'page' })
.filter((page) => page.out)
.reduce((collector, page) => {
if ((page.pub.url in navEntriesByUrl) || page.pub.url === defaultUrl) return collector
logger.warn({ file: page.src, source: page.src.origin }, 'detected unlisted page')
return collector.concat(page)
}, [])
if (unlistedPages.length && addToNavigation) {
nav.push({
content: unlistedPagesHeading,
items: unlistedPages.map((page) => {
const title = 'navtitle' in page.asciidoc
? page.asciidoc.navtitle
: (page.src.module === 'ROOT' ? '' : page.src.module + ':') + page.src.relative
return { content: title, url: page.pub.url, urlType: 'internal' }
}),
root: true,
})
}
})
})
})
}
function getNavEntriesByUrl (items = [], accum = {}) {
items.forEach((item) => {
if (item.urlType === 'internal') accum[item.url.split('#')[0]] = item
getNavEntriesByUrl(item.items, accum)
})
return accum
}
잠시 멈추고 이 확장 기능이 수행하는 작업을 단계별로 분석해 보겠습니다.
확장 기능의 작동 방식
확장 기능은 register 함수를 내보내는 것으로 시작하며, Antora는 확장 파일을 요구한 직후 이 함수를 호출합니다. register 함수는 생성기 컨텍스트에 바인딩되며, 이를 사용하여 리스너를 추가할 수 있습니다. 이 함수는 확장 기능의 config 객체를 유일한 인수로 받습니다(객체 구조 분해를 통해). 그런 다음 config 객체에서 여러 구성 키를 가져와 동작을 사용자 지정합니다.
[source,js]
module.exports.register = function ({ config }) {
const { addToNavigation, unlistedPagesHeading = 'Unlisted Pages' } = config
}
다음으로 확장 기능은 목록에 없는 페이지를 보고하는 데 사용할 수 있는 명명된 로거를 생성합니다. 컨텍스트에서 getLogger를 호출하여 명명된 로거를 생성합니다. 이 메서드는 차례로 Antora에서 제공하는 @antora/logger 모듈을 요구한 다음 해당 이름을 기본 함수에 전달하여 자식 로거를 생성합니다.
[source,js]
const logger = this.getLogger('unlisted-pages-extension')
그런 다음 확장 기능은 navigationBuilt 이벤트에 대한 리스너를 추가합니다. 확장 기능은 내비게이션에 액세스해야 하므로 생성기에서 내비게이션 트리를 검사하는 적절한 기회입니다. 내비게이션과 페이지에 액세스하기 위해 리스너는 객체 구조 분해를 사용하여 컨텍스트 변수에서 contentCatalog 객체를 검색합니다. navigationBuilt 이벤트는 페이지가 변환된 후에 발생하므로 각 페이지의 navtitle에 액세스할 수 있습니다.
[source,js]
this
.on('navigationBuilt', ({ contentCatalog }) => {
})
호출되면 navigationBuilt 이벤트의 리스너는 콘텐츠 카탈로그에서 각 구성 요소 버전에 대한 내비게이션 트리와 해당 페이지를 찾는 데 필요한 구성 요소 버전에 대한 일부 정보를 검색합니다.
[source,js]
contentCatalog.getComponents().forEach(({ versions }) => {
versions.forEach(({ name: component, version, navigation: nav, url: defaultUrl }) => {
})
})
내비게이션에서 페이지를 더 쉽게 찾을 수 있도록 확장 기능은 중복을 무시하면서 URL별로 내비게이션의 각 항목에 대한 조회 테이블을 생성하는 도우미를 제공합니다.
[source,js]
function getNavEntriesByUrl (items = [], accum = {}) {
items.forEach((item) => {
if (item.urlType === 'internal') accum[item.url.split('#')[0]] = item
getNavEntriesByUrl(item.items, accum)
})
return accum
}
그런 다음 확장 기능은 이 도우미를 사용하여 각 내비게이션에 대한 조회 테이블을 생성합니다:
[source,js]
const navEntriesByUrl = getNavEntriesByUrl(nav)
이제 실제 작업이 시작됩니다. 확장 기능은 콘텐츠 카탈로그로 돌아가 현재 구성 요소 버전의 모든 페이지를 찾고 해당 목록을 필터링하여 게시 가능한 페이지(즉, out 속성이 있는 페이지)만 찾습니다. 그런 다음 리소스 URL을 비교하여 페이지가 내비게이션에 있는지 확인합니다. 일치하는 항목을 찾을 수 없는 경우 로거를 사용하여 경고를 로그하고 반환되는 수집기에 페이지를 추가합니다.
[source,js]
const unlistedPages = contentCatalog
.findBy({ component, version, family: 'page' })
.filter((page) => page.out)
.reduce((collector, page) => {
if ((page.pub.url in navEntriesByUrl) || page.pub.url === defaultUrl) return collector
logger.warn({ file: page.src, source: page.src.origin }, 'detected unlisted page')
return collector.concat(page)
}, [])
경고 메시지를 자세히 살펴보겠습니다.
[source,js]
logger.warn({ file: page.src, source: page.src.origin }, 'detected unlisted page')
첫 번째 인수로 객체를 전달하고 두 번째 인수로 메시지를 전달하는 것을 확인하세요. 첫 번째 인수로 전달된 객체의 키는 구조화된 로그 메시지에 병합됩니다. Antora의 로거는 pretty 로그 메시지를 출력할 때 file 및 source 키에 대한 사용자 지정 포맷터를 제공합니다. file 키는 path 키와 해당하는 경우 abspath 키가 있는 객체를 가리켜야 합니다. 이 내용을 제공하는 가장 간단한 방법은 가상 파일의 src 속성을 전달하는 것입니다. 이 속성에는 파일이 위치한 위치에 대한 모든 필요한 정보가 포함되어 있습니다. origin 키는 가상 파일의 src.origin 속성을 가리켜야 합니다. 이 속성은 콘텐츠 소스에 대한 정보를 제공합니다. 선택적으로 line 키를 사용하여 줄 번호를 전달할 수도 있습니다. 사용자 지정 포맷터는 이 모든 정보를 컴파일하여 사용자가 관련 파일을 찾는 데 도움이 되는 형식이 지정된 메시지로 만듭니다.
마지막으로 확장 기능이 목록에 없는 페이지를 찾으면 구성된 경우 특수 제목이 있는 내비게이션의 새 카테고리에 해당 페이지를 추가합니다.
[source,js]
if (unlistedPages.length && addToNavigation) {
nav.push({
content: unlistedPagesHeading,
items: unlistedPages.map((page) => {
const title = 'navtitle' in page.asciidoc
? page.asciidoc.navtitle
: (page.src.module === 'ROOT' ? '' : page.src.module + ':') + page.src.relative
return { content: title, url: page.pub.url, urlType: 'internal' }
}),
root: true,
})
}
addToNavigation 변수는 확장 항목의 add_to_navigation 구성 키에서 가져옵니다. Antora는 구성 키 이름을 자동으로 camelCase로 변환하여 JavaScript의 변수 명명 규칙과 일치시킵니다.
목록에 없는 페이지 제거
목록에 없는 페이지를 내비게이션에 추가하는 대신 사이트에서 제거할 수 있습니다. 이는 게시되는 페이지를 제한하는 한 가지 방법이 될 것입니다.
[source,js]
unlistedPages.forEach((page) => contentCatalog.removeFile(page))
이 경로를 사용하는 경우 목록에 없는 페이지에 대한 경고를 제거하거나 info 또는 debug 심각도 수준으로 낮추는 것이 좋습니다.
이제 확장 기능이 작성되었고 수행하는 작업을 이해했으므로 등록할 시간입니다.
확장 기능 등록
확장 기능을 등록하려면 플레이북의 antora.extensions 키에 해당 항목에 대한 require 요청을 추가합니다. 우리의 경우 require 요청은 플레이북 파일에서 확장 파일까지의 상대 경로입니다.
[source,yaml]
antora:
extensions:

./lib/unlisted-pages-extension.js


확장 기능은 Antora를 다음에 실행할 때 호출됩니다. 그러나 이 확장 기능은 구성 가능하므로 해당 구성 키를 위한 공간을 만들기 위해 더 공식적인 항목 형식을 사용하는 것이 좋습니다.
확장 기능 구성
구성으로 확장 기능을 등록하려면 플레이북의 antora.extensions 키에 해당 맵 항목을 추가합니다. 이렇게 하면 require 키에 require 요청을 정의하여 다른 구성 키를 위한 공간을 만들 수 있습니다.
[source,yaml]
antora:
extensions:

require: ./lib/unlisted-pages-extension.js
add_to_navigation: true
unlisted_pages_heading: Orphans


--extension CLI 옵션을 사용하여 지정된 경우에만 확장 기능을 사용하려면 id 및 enabled 키도 설정해야 합니다.
[source,yaml]
antora:
extensions:

id: unlisted-pages
enabled: false
require: ./lib/unlisted-pages-extension.js
add_to_navigation: true
unlisted_pages_heading: Orphans


이제 Antora를 실행할 때 --extension=unlisted-pages를 전달해야만 확장 기능이 실행됩니다.
확장 기능이 구성을 허용하는 경우 기본적으로 활성화하지 않더라도 항상 플레이북에 등록하는 것이 현명합니다.
확장 기능 사용
남은 것은 Antora를 실행할 때 확장 기능을 사용하는 것뿐입니다. 확장 기능이 활성화된 경우(기본적으로 활성화됨) 일반적으로 하는 것처럼 Antora를 실행하고 플레이북 파일을 전달하기만 하면 됩니다:
[source,bash]
antora antora-playbook
확장 기능이 활성화되지 않은 경우 --extension CLI 옵션을 사용하여 Antora를 실행할 때 확장 기능을 활성화해야 합니다:
[source,bash]
antora --extension=unlisted-pages antora-playbook.yml
플레이북에 목록에 없는 페이지가 있는 경우 다음과 같은 경고 메시지가 표시됩니다:
[source,bash]
[12:02:02.532] WARN (unlisted-pages-extension): detected unlisted page
source: /path/to/worktree (refname: main <worktree>, start path: docs)
file: modules/ROOT/pages/name-of-page.adoc
add_to_navigation 키가 true이면 내비게이션 트리 하단의 목록에 없는 페이지 카테고리에 해당 페이지가 나열됩니다.
목록에 없는 페이지 문제를 해결하려면 적절한 nav 파일을 찾아 목록에 없는 페이지에 대한 항목을 추가한 다음 Antora를 다시 실행하여 작업을 확인하세요.
축하합니다! 첫 번째 Antora 확장 기능을 만들었습니다.



== Extend Antora - Antora Extensions - Generator Events Reference

Antora 확장 기능은 Antora가 실행될 때 생성기에서 발생하는 이벤트를 수신합니다. 각 리스너는 이벤트가 발생할 때 범위 내에 있는 변수에 액세스할 수 있습니다. 다음 표는 발생 순서대로 생성기 이벤트와 각 이벤트에 해당하는 컨텍스트(범위 내) 변수를 나열합니다. 변수가 잠겨 있어 교체할 수 없는 경우 기울임꼴로 표시됩니다.
.Antora 확장 기능 이벤트 및 범위 내 변수
[cols="1,1"]
|===
|이벤트 이름|범위 내 변수
|register()^1^
|playbook, config
|contextStarted^2^
|playbook
|playbookBuilt
|playbook
|beforeProcess
|playbook, siteAsciiDocConfig, siteCatalog
|contentAggregated^3^
|playbook, siteAsciiDocConfig, siteCatalog, contentAggregate
|uiLoaded^3^
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog
|contentClassified
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog
|documentsConverted
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog
|navigationBuilt
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog, navigationCatalog
|pagesComposed
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog
|redirectsProduced
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog
|siteMapped^4^
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog
|beforePublish
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog
|sitePublished
|playbook, siteAsciiDocConfig, siteCatalog, uiCatalog, contentCatalog, publications
|contextStopped
|(컨텍스트가 중지될 때 여전히 범위 내에 있는 모든 변수)
|contextClosed^5^
|(컨텍스트가 닫힐 때 여전히 범위 내에 있는 모든 변수)
|===
이 표에 나열된 내장 컨텍스트 변수 외에도 확장 기능은 다른 확장 기능에서 문서화되고 게시된 컨텍스트 변수에 액세스할 수 있습니다.

register 함수는 이벤트가 아니라 확장 기능에서 리스너를 등록할 수 있도록 Antora가 호출하는 함수입니다.
이 이벤트가 발생할 때까지 내장 생성기 함수를 사용할 수 없습니다.
contentAggregated 및 uiLoaded 이벤트의 상대적 순서는 보장되지 않습니다.
siteMapped 이벤트는 사이트 URL이 플레이북에 지정된 경우에만 발생합니다.
contextClosed 이벤트의 리스너는 모든 리스너에 알릴 수 있도록 자체 오류를 catch해야 합니다.



== Extend Antora - Antora Extensions - GeneratorContext API Reference

GeneratorContext API는 Antora의 확장 기능에 액세스하는 주요 지점입니다. Antora는 GeneratorContext의 인스턴스를 생성하고, 이를 생성기 컨텍스트라고 하며, 확장 기능의 register 함수와 추가하는 모든 리스너에 바인딩합니다. 이 객체는 모든 확장 기능과 이벤트 리스너에서 공유됩니다. 생성기 컨텍스트는 해당 이벤트 리스너를 추가하는 방법을 제공합니다. 또한 확장 기능 작성을 쉽게 만드는 몇 가지 컨텍스트 인식 도우미를 제공합니다.
GeneratorContext 클래스는 Node.js EventEmitter 유형을 확장합니다. EventEmitter의 모든 메서드는 생성기 컨텍스트에서 상속되어 사용할 수 있습니다. 그러나 emit 객체를 호출하여 Antora 자체 이벤트 중 하나를 발생시켜서는 안 됩니다.
EventEmitter의 메서드 외에도 다음 표는 GeneratorContext API에서 제공하는 메서드를 설명합니다.
.GeneratorContext에서 제공하는 추가 메서드
[cols="1,1,3"]
|===
|메서드 이름|매개변수|설명
|getFunctions
|없음
|생성기 함수의 객체를 반환합니다. 생성기 함수는 생성기의 개별 단계 및 해당 단계에서 사용하는 주요 유틸리티 함수 중 하나로 정의됩니다. 내장 생성기 함수는 contextStarted 이벤트가 발생할 때까지 사용할 수 없습니다. 이 객체는 읽기 전용입니다.
|getLogger
|String
|지정된 명명된 로거의 인스턴스를 생성합니다. 인수가 지정되고 값이 falsy가 아닌 경우 메서드는 지정된 이름의 자식 로거를 반환합니다. 인수가 지정되고 값이 비어 있는 경우 메서드는 루트 로거를 반환합니다. 인수가 지정되고 값이 null인 경우 메서드는 루트 로거를 반환하거나 로거가 구성되지 않은 경우 undefined를 반환합니다. 인수가 지정되지 않은 경우 메서드는 antora라는 이름의 로거를 반환합니다. 인수 값이 null이 아닌 한 필요한 경우 항상 로거가 생성됩니다.
|getVariables
|없음
|컨텍스트 변수의 객체를 반환합니다. 이 객체는 읽기 전용입니다.
|lockVariable
|String
|지정된 컨텍스트 변수를 잠그고 해당 값을 반환합니다.
|replaceFunctions
|Object
|지정된 함수를 생성기 컨텍스트에 바인딩하고 이를 사용하여 생성기 컨텍스트의 기존 함수를 대체합니다. 이 메서드가 contextStarted 이벤트 이전에 호출되면 해당 내장 생성기 함수는 필요하지 않으며 등록되지 않습니다.
|removeVariable
|String
|변수가 잠겨 있지 않은 경우 지정된 컨텍스트 변수를 제거하고 해당 값을 반환합니다. 변수가 잠겨 있으면 오류가 발생합니다.
|require
|String
|Antora 생성기의 컨텍스트에서 모듈의 이름을 요구합니다. 이 메서드를 사용하면 Antora 구성 요소를 종속성으로 선언하지 않고도 Antora 내부를 요구할 수 있습니다.
|stop
|없음
|지정된 종료 코드를 사용하여 종료하고(contextStopped 및 contextClosed 이벤트를 발생시켜 정상적인 종료를 사용하여) 생성기의 작동을 중지합니다. 종료 코드가 지정되지 않은 경우 프로세스는 프로세스에 설정된 종료 코드를 사용하거나 종료 코드가 설정되지 않은 경우 0을 사용합니다.
|updateVariables
|Object
|지정된 변수로 컨텍스트 변수를 추가하거나 대체합니다.
|===
GeneratorContext는 EventEmitter이므로 리스너를 등록하는 데 사용할 수 있을 뿐만 아니라 등록된 리스너 목록을 가져오고, 리스너 등록을 취소하고, 다른 순서로 리스너를 다시 등록할 수 있습니다.



== Extend Antora - Antora Extensions - Extension Use Cases

이 페이지에서는 확장 기능을 사용하여 Antora의 기능을 향상시킬 수 있는 방법을 보여주는 간단한 예제 모음을 제공합니다. 각 섹션에서는 다양한 사용 사례를 소개하고 시작점으로 사용할 수 있는 확장 코드를 제시합니다.
보다 복잡한 예제를 연구하려면 Antora 프로젝트에서 제공하는 공식 확장 프로젝트를 참조할 수도 있습니다.
전역 AsciiDoc 속성 설정
동적 값으로 전역 AsciiDoc 속성을 정의하려면 확장 기능을 사용할 수 있습니다. 플레이북에는 전역 AsciiDoc 속성을 포함하는 AsciiDoc 구성 객체가 들어 있습니다. 확장 기능은 playbookBuilt 이벤트를 수신하고 이 맵에 속성을 추가할 수 있습니다.
.set-global-asciidoc-attributes-extension.js
[source,js]
module.exports.register = function () {
this.on('beforeProcess', ({ siteAsciiDocConfig }) => {
const buildDate = new Date().toISOString()
siteAsciiDocConfig.attributes['build-date'] = buildDate
})
}
확장 기능은 파일 또는 환경 변수에서 이러한 값을 읽을 수도 있습니다.
구성 요소 버전에 범위가 지정된 AsciiDoc 속성을 설정해야 하는 경우 대신 contentClassified 이벤트를 수신해야 합니다. 거기에서 구성 요소 버전 객체의 asciidoc 속성에서 AsciiDoc 속성에 액세스할 수 있습니다. 콘텐츠 카탈로그 객체의 getComponentVersion 메서드를 사용하여 이름과 버전으로 구성 요소 버전을 조회할 수 있습니다. 또는 콘텐츠 카탈로그 객체의 getComponents 메서드에서 반환된 각 구성 요소의 versions 속성에서 구성 요소 버전에 액세스할 수 있습니다.
AsciiDoc 속성 출력
사이트 문제를 해결하는 경우 확장 기능을 사용하여 사이트 수준에서 AsciiDoc 속성과 구성 요소 버전별 속성 보고서를 생성할 수 있습니다. 이 보고서를 만들 때 페이지에서 사용할 수 있는 AsciiDoc 속성을 컴파일된 상태로 표시할지 아니면 정의된 상태로 표시할지 선택할 수 있습니다(즉, 컴파일되지 않음).
다음 확장을 사용하여 각 구성 요소 버전에 대해 컴파일된 모든 AsciiDoc 속성을 출력할 수 있습니다. 또한 이 확장은 플레이북에서 컴파일된 모든 속성을 출력하지만 이러한 속성이 각 구성 요소 버전의 속성에 통합된다는 점을 염두에 두어야 합니다.
.print-compiled-asciidoc-attributes-extension.js
[source,js]
module.exports.register = function () {
this.once('contentClassified', ({ siteAsciiDocConfig, contentCatalog }) => {
console.log('site-wide attributes (compiled)')
console.log(siteAsciiDocConfig.attributes)
contentCatalog.getComponents().forEach((component) => {
component.versions.forEach((componentVersion) => {
console.log(${componentVersion.version}@${componentVersion.name} attributes (compiled))
if (componentVersion.asciidoc === siteAsciiDocConfig) {
console.log('same as site-wide attributes')
} else {
console.log(componentVersion.asciidoc.attributes)
}
})
})
})
}
다음 확장을 사용하여 플레이북과 각 구성 요소 버전(출처별)의 antora.yml 파일에 정의된 모든 AsciiDoc 속성을 출력할 수 있습니다.
.print-defined-asciidoc-attributes-extension.js
[source,js]
module.exports.register = function () {
this.once('contentClassified', ({ playbook, contentCatalog }) => {
console.log('site-wide attributes (as defined in playbook)')
console.log(playbook.asciidoc.attributes)
contentCatalog.getComponents().forEach((component) => {
component.versions.forEach((componentVersion) => {
getUniqueOrigins(contentCatalog, componentVersion).forEach((origin) => {
console.log(${componentVersion.version}@${componentVersion.name} attributes (as defined in antora.yml))
console.log(origin.descriptor.asciidoc?.attributes || {})
})
})
})
})
}
function getUniqueOrigins (contentCatalog, componentVersion) {
return contentCatalog.findBy({ component: componentVersion.name, version: componentVersion.version })
.reduce((origins, file) => {
const origin = file.src.origin
if (origin && !origins.includes(origin)) origins.push(origin)
return origins
}, [])
}
다른 확장 기능을 작성할 때 이러한 AsciiDoc 속성 모음을 활용하는 것이 유용할 수 있습니다.
비공개 콘텐츠 소스 제외
일부 기여자나 CI 작업에 플레이북의 비공개 콘텐츠 소스에 대한 권한이 없는 경우 플레이북 파일을 수정하지 않고도 확장 기능을 사용하여 필터링할 수 있습니다.
이 확장 기능은 playbookBuilt 이벤트 중에 실행됩니다. 플레이북을 검색하고 콘텐츠 소스를 반복하며 비공개로 감지되어 인증이 필요한 콘텐츠 소스를 제거합니다. 확장 기능에 비공개 콘텐츠 소스를 알리기 위해 규칙에 의존할 것입니다. 해당 규칙은 git@으로 시작하는 SSH URL을 사용하는 것입니다. Antora는 SSH URL을 HTTP URL로 자동 변환하므로 이 구문을 사용하면 단순히 URL이 비공개이며 인증을 요청할 것이라는 힌트를 사용자와 확장 기능에 제공합니다.
.exclude-private-content-sources-extension.js
[source,js]
module.exports.register = function () {
this.on('playbookBuilt', function ({ playbook }) {
playbook.content.sources = playbook.content.sources
.filter(({ url }) => !url.startsWith('git@'))
this.updateVariables({ playbook })
})
}
이 확장 기능은 플레이북이 이 이벤트가 끝날 때까지 변경 가능하고 그 시점에서 Antora가 플레이북을 고정하기 때문에 작동합니다. 생성기 컨텍스트에서 플레이북 변수를 대체하기 위해 this.updateVariables를 호출하는 것은 필수는 아니지만 여기서는 의도를 표현하고 확장 기능을 미래에 대비하기 위해 사용됩니다.
플래그가 지정된 페이지 게시 취소
페이지를 게시하지 않으려면 파일 이름 앞에 밑줄(예: _hidden.adoc)을 접두사로 사용할 수 있습니다. 그러나 페이지를 조건부로만 게시 취소하려면 확장 기능을 사용해야 합니다.
이 확장 기능을 사용하면 page-unpublish 페이지 속성을 설정하는 모든 페이지가 게시되지 않습니다(즉, 게시 취소됨). 예를 들면 다음과 같습니다:
[source,asciidoc]
= Secret Page
:page-unpublish:
This page will not be published.
플레이북이나 CLI 옵션에 설정된 다른 AsciiDoc 속성의 유무에 따라 page-unpublish 페이지 속성을 설정할 수 있습니다. 예를 들면 다음과 같습니다:
[source,asciidoc]
= Secret Page
ifndef::include-secret[:page-unpublish:]
This page will not be published.
이 확장 기능은 documentsConverted 이벤트 중에 실행됩니다. 이는 가상 파일의 AsciiDoc 메타데이터에 액세스할 수 있는 가장 빠른 이벤트입니다. 확장 기능은 콘텐츠 카탈로그의 모든 게시 가능한 페이지를 반복하고 page-unpublish 속성을 설정하는 페이지를 게시 취소합니다. 페이지를 게시 취소하기 위해 확장 기능은 가상 파일에서 out 속성을 제거합니다. out 속성이 없으면 페이지가 게시되지 않습니다.
.page-unpublish-tag-extension.js
[source,js]
module.exports.register = function () {
this.on('documentsConverted', ({ contentCatalog }) => {
contentCatalog.getPages((page) => page.out).forEach((page) => {
if (page.asciidoc?.attributes['page-unpublish'] != null) {
delete page.out
}
})
})
}
게시 취소된 페이지에 대한 참조가 있을 수 있음을 염두에 두세요. Antora에서 해결되지만 참조 대상을 사용할 수 없어 웹 서버에서 404 응답이 발생합니다.
페이지가 게시 취소되는 시기를 보다 세밀하게 제어하려면 convertDocument 또는 convertDocuments 함수를 대체하는 확장 기능을 작성할 수 있습니다. 이렇게 하면 다른 페이지에서 페이지에 대한 참조가 해결되기 전에 페이지를 게시 취소할 수 있으므로 경고로 나타납니다.
목록에 없는 페이지 보고
새 페이지를 만든 후에는 독자가 액세스할 수 있도록 탐색에 추가하는 것을 잊기 쉽습니다. 확장 기능을 사용하여 탐색에 없는 페이지를 식별하고 로거를 사용하여 보고할 수 있습니다.
이 확장 기능은 navigationBuilt 이벤트 중에 실행됩니다. 각 구성 요소 버전을 반복하고 해당 내부 탐색 항목의 병합된 목록을 검색한 다음 해당 목록에 없는 페이지가 있는지 URL로 페이지를 비교하여 확인합니다. 그러한 페이지를 찾으면 선택적으로 탐색에 추가하여 해당 페이지에 대한 보고서를 작성합니다.
.unlisted-pages-extension.js
[source,js]
module.exports.register = function ({ config }) {
const { addToNavigation, unlistedPagesHeading = 'Unlisted Pages' } = config
const logger = this.getLogger('unlisted-pages-extension')
this
.on('navigationBuilt', ({ contentCatalog }) => {
contentCatalog.getComponents().forEach(({ versions }) => {
versions.forEach(({ name: component, version, navigation: nav, url: defaultUrl }) => {
const navEntriesByUrl = getNavEntriesByUrl(nav)
const unlistedPages = contentCatalog
.findBy({ component, version, family: 'page' })
.filter((page) => page.out)
.reduce((collector, page) => {
if ((page.pub.url in navEntriesByUrl) || page.pub.url === defaultUrl) return collector
logger.warn({ file: page.src, source: page.src.origin }, 'detected unlisted page')
return collector.concat(page)
}, [])
if (unlistedPages.length && addToNavigation) {
nav.push({
content: unlistedPagesHeading,
items: unlistedPages.map((page) => {
const title = 'navtitle' in page.asciidoc
? page.asciidoc.navtitle
: (page.src.module === 'ROOT' ? '' : page.src.module + ':') + page.src.relative
return { content: title, url: page.pub.url, urlType: 'internal' }
}),
root: true,
})
}
})
})
})
}
function getNavEntriesByUrl (items = [], accum = {}) {
items.forEach((item) => {
if (item.urlType === 'internal') accum[item.url.split('#')[0]] = item
getNavEntriesByUrl(item.items, accum)
})
return accum
}
이 확장 기능에 대한 자세한 내용과 구성 방법은 확장 기능 튜토리얼에서 확인할 수 있습니다.

=== 목록에 없는 페이지 게시 취소

목록에 없는 페이지를 보고하는 대신 게시에서 해당 페이지를 제거할 수 있습니다. 이는 탐색을 사용하여 게시할 페이지를 결정하는 한 가지 방법입니다.
이 확장 기능은 navigationBuilt 이벤트 중에 실행됩니다. 각 구성 요소 버전을 반복하고 해당 내부 탐색 항목의 병합된 목록을 검색한 다음 해당 목록에 없는 페이지가 있는지 URL로 페이지를 비교하여 확인합니다. 그러한 페이지를 찾으면 게시를 취소합니다.
.unpublish-unlisted-pages-extension.js
[source,js]
module.exports.register = function ({ config }) {
this
.on('navigationBuilt', ({ contentCatalog }) => {
contentCatalog.getComponents().forEach(({ versions }) => {
versions.forEach(({ name: component, version, navigation: nav, url: defaultUrl }) => {
const navEntriesByUrl = getNavEntriesByUrl(nav)
const unlistedPages = contentCatalog
.findBy({ component, version, family: 'page' })
.filter((page) => page.out)
.reduce((collector, page) => {
if ((page.pub.url in navEntriesByUrl) || page.pub.url === defaultUrl) return collector
return collector.concat(page)
}, [])
if (unlistedPages.length) unlistedPages.forEach((page) => delete page.out)
})
})
})
}
function getNavEntriesByUrl (items = [], accum = {}) {
items.forEach((item) => {
if (item.urlType === 'internal') accum[item.url.split('#')[0]] = item
getNavEntriesByUrl(item.items, accum)
})
return accum
}
페이지에서 out 속성을 제거하면 페이지가 게시되지 않지만 include 지시문을 사용하여 여전히 참조할 수 있습니다. 또는 페이지를 콘텐츠 카탈로그에서 완전히 제거하도록 선택할 수 있습니다.
발견된 구성 요소 버전 나열
플레이북을 설정할 때 Antora에서 일부 구성 요소 버전을 발견하지 못하는 경우가 있습니다. 확장 기능을 사용하면 콘텐츠 집계 중에 Antora가 발견한 구성 요소 버전과 해당 버전을 가져온 콘텐츠 소스를 나열할 수 있습니다.
.discovered-component-versions-extension.js
[source,js]
module.exports.register = function () {
this.once('contentAggregated', ({ contentAggregate }) => {
console.log('Discovered the following component versions')
contentAggregate.forEach((bucket) => {
const sources = bucket.origins.map(({ url, refname }) => ({ url, refname }))
console.log({ name: bucket.name, version: bucket.version, files: bucket.files.length, sources })
})
})
}
항목이 누락된 경우 플레이북의 콘텐츠 소스 정의를 조정해야 할 수 있음을 알 수 있습니다.
자세한 정보를 원하면 전체 버킷 항목을 출력할 수 있습니다.
첨부 파일의 속성 참조 확인
첨부 파일 계열의 파일은 출력 사이트로 직접 전달됩니다. Antora는 첨부 파일의 AsciiDoc 속성 참조를 확인하지 않습니다. (반면에 Asciidoctor는 첨부 파일이 속성 대체가 활성화된 AsciiDoc 페이지에 포함된 경우에만 첨부 파일 내용의 AsciiDoc 속성 참조를 확인합니다.) Antora 확장 기능을 사용하여 첨부 파일이 게시되기 전에 Antora가 첨부 파일의 속성 참조를 확인하도록 할 수 있습니다.
이 확장 기능은 첨부 파일이 처음 식별되고 분류되는 contentClassified 이벤트 중에 실행됩니다. 모든 첨부 파일을 반복하고 해당 첨부 파일의 구성 요소 버전으로 범위가 지정된 속성에 대한 모든 참조를 확인합니다. 파일 내용이 변경된 경우 가상 파일의 내용을 업데이트된 값으로 대체합니다.
.resolve-attributes-references-in-attachments-extension.js
[source,js]
module.exports.register = function () {
this.on('contentClassified', ({ contentCatalog }) => {
const componentVersionTable = contentCatalog.getComponents().reduce((componentMap, component) => {
componentMap[component.name] = component.versions.reduce((versionMap, componentVersion) => {
versionMap[componentVersion.version] = componentVersion
return versionMap
}, {})
return componentMap
}, {})
contentCatalog.findBy({ family: 'attachment' }).forEach((attachment) => {
const componentVersion = componentVersionTable[attachment.src.component][attachment.src.version]
let attributes = componentVersion.asciidoc?.attributes
if (!attributes) return
attributes = Object.entries(attributes).reduce((accum, [name, val]) => {
accum[name] = val && val.endsWith('@') ? val.slice(0, val.length - 1) : val
return accum
}, {})
let modified
const result = attachment.contents.toString().replace(/{([\p{Alpha}\d_][\p{Alpha}\d_-]*)}/gu, (match, name) => {
if (!(name in attributes)) return match
modified = true
let value = attributes[name]
if (value.endsWith('@')) value = value.slice(0, value.length - 1)
return value
})
if (modified) attachment.contents = Buffer.from(result)
})
})
}
이 확장 기능은 텍스트 기반 첨부 파일에서만 작동하는 것으로 알려져 있습니다. 이진 파일에서 작동하도록 이 확장 기능을 수정해야 할 수 있습니다.
워드 프로세서 첨부 파일을 PDF로 변환
AsciiDoc 파일(.adoc)이 Antora에 의해 HTML(.html)로 변환되는 것처럼 첨부 파일에서도 동일하게 수행할 수 있습니다. 이 확장 기능은 첨부 파일이 처음 식별되고 분류되는 contentClassified 이벤트 중에 실행됩니다. 워드 프로세서 형식(즉, .docx, .odt, .fodt)의 모든 첨부 파일을 반복하고 libreoffice 명령(서버 모드의 LibreOffice)을 사용하여 각 파일을 PDF로 변환합니다.
.doc-to-pdf-extension.js
[source,js]
const fsp = require('node:fs/promises')
const ospath = require('node:path')
const { posix: path } = ospath
const { execFile } = require('node:child_process')
module.exports.register = function () {
this.once('contentClassified', async ({ playbook, contentCatalog }) => {
const docExtnames = { '.docx': true, '.fodt': true, '.odt': true }
const filesToConvert = contentCatalog.getFiles().filter(({ src }) => src.family === 'attachment' && docExtnames[src.extname])
if (!filesToConvert.length) return
const buildDirBase = ospath.join(playbook.dir, 'build/doc-to-pdf')
const convertArgs = ['--writer', '--convert-to', 'pdf']
const convertOpts = { cwd: buildDirBase, windowsHide: true }
try {
await fsp.mkdir(buildDirBase, { recursive: true })
await Promise.all(filesToConvert.map((file) => {
const sourceRelpath = ${file.src.component}-${file.src.module}-${file.out.basename}
convertArgs.push(sourceRelpath)
return fsp.writeFile(ospath.join(buildDirBase, sourceRelpath), file.contents)
}))
await new Promise((resolve, reject) => {
execFile('libreoffice', convertArgs, convertOpts, (err, stderr, stdout) => {
if (!err) return resolve()
const splitIdx = stderr.indexOf('Usage: ')
if (~splitIdx) stderr = stderr.slice(0, splitIdx).trimEnd()
if (stderr) err.message += stderr
reject(err)
})
})
await Promise.all(filesToConvert.map((file) => {
file.out.path = path.join(file.out.dirname, (file.out.basename = file.out.basename.slice(0, -file.src.extname.length) + '.pdf'))
file.pub.url = file.pub.url.slice(0, -file.src.extname.length) + '.pdf'
const sourceRelpath = ${file.src.component}-${file.src.module}-${file.out.basename}
return fsp.readFile(ospath.join(buildDirBase, sourceRelpath)).then((contents) => (file.contents = contents))
}))
} finally {
await fsp.rm(buildDirBase, { recursive: true, force: true })
}
})
}
파일을 변환하고 메타데이터를 업데이트하면 xref 매크로를 사용하여 소스 문서를 참조할 수 있습니다. 해당 참조는 자동으로 생성된 사이트의 PDF에 대한 링크로 변환됩니다.



== Extend Antora - Antora Components

이 페이지에서는 사용자 정의 사이트 생성기 파이프라인으로 조립할 수 있는 Antora 구성 요소 목록을 찾을 수 있습니다. Antora는 구성 요소를 쉽게 제거하고 교체할 수 있도록 모듈식 아키텍처를 가지고 있습니다. API 덕분에 Asciidoctor 확장 기능도 통합할 수 있습니다.
코어 구성 요소
코어 구성 요소는 사이트 생성기 기본 구성 요소에 의해 파이프라인으로 조립됩니다. 코어 구성 요소는 함께 버전이 지정됩니다.
현재 동일한 버전의 코어 구성 요소만 함께 작동하도록 설계되어 있습니다. 예를 들어 사용자 정의 사이트 생성기에서 콘텐츠 분류기와 페이지 작성기를 사용하려면 각 구성 요소의 버전이 동일한지 확인하세요.
사이트 생성기(@antora/site-generator)와 함께 CLI(@antora/cli)를 사용하는 경우 CLI와 사이트 생성기의 버전을 동기화하기만 하면 됩니다. 사용자 정의 사이트 생성기를 만들면 사용하는 각 개별 구성 요소를 동기화할 책임이 있습니다.
확장 구성 요소
확장 구성 요소는 특수 사용 사례에 대한 핵심 기능을 제공합니다. 확장 구성 요소의 예로는 Amazon S3 버킷용 파일 게시자 공급자가 있습니다. 일반 가용성 준비가 완료되면 확장 구성 요소가 개별적으로 릴리스되고 버전이 지정됩니다.
지원되는 코어 및 확장 구성 요소 매트릭스
[cols="1,3,1,1,1"]
|===
|이름 / 패키지 |설명 |코어 |확장 |라이선스
|AsciiDoc 로더
@antora/asciidoc-loader
|Antora에서 AsciiDoc 콘텐츠를 처리하기 위한 재사용 가능한 라이브러리입니다. AsciiDoc 콘텐츠를 AsciiDoc 문서 객체(AST)로 로드합니다.
|✅
|
|MPL-2.0
|CLI
@antora/cli
|Antora의 명령줄 인터페이스(CLI)입니다.
|✅
|
|MPL-2.0
|콘텐츠 집계기
@antora/content-aggregator
|여러 로컬 및 원격 git 리포지토리에 분산된 콘텐츠를 가져와서 집계합니다.
|✅
|
|MPL-2.0
|콘텐츠 분류기
@antora/content-classifier
|집계된 콘텐츠를 가상 파일 카탈로그로 구성합니다.
|✅
|
|MPL-2.0
|문서 변환기
@antora/document-converter
|AsciiDoc 문서를 임베딩 가능한 HTML로 변환합니다.
|✅
|
|MPL-2.0
|로거
@antora/logger
|로깅, 형성 및 애플리케이션 메시지 보고를 위한 인프라를 제공합니다.
|✅
|
|MPL-2.0
|내비게이션 빌더
@antora/navigation-builder
|내비게이션 파일에서 소싱된 내비게이션 카탈로그를 빌드합니다. 이 내비게이션 카탈로그는 페이지에 사이트 내비게이션을 추가하는 데 사용할 수 있습니다.
|✅
|
|MPL-2.0
|페이지 작성기
@antora/page-composer
|콘텐츠 카탈로그의 각 페이지 파일의 임베딩 가능한 HTML 내용을 HTML 페이지 레이아웃으로 래핑합니다. 이 단계에서는 생성된 사이트의 독립 실행형 HTML 페이지가 생성됩니다.
|✅
|
|MPL-2.0
|플레이북 빌더
@antora/playbook-builder
|사용자 입력에서 플레이북 객체를 빌드하는 구성 구성 요소입니다.
|✅
|
|MPL-2.0
|리디렉션 생성기
@antora/redirect-producer
|등록된 별칭에서 지정된 페이지로 리디렉션(HTTP 리디렉션)을 생성합니다.
|✅
|
|MPL-2.0
|사이트 생성기
@antora/site-generator
|Antora의 사이트 생성기입니다. Antora CLI의 generate 명령에 의해 호출되어 정적 문서 사이트를 생성하고 게시합니다. 이 패키지는 CLI를 제외한 다른 모든 비확장 패키지를 그룹화(즉, 종속성이 있음)합니다.
이전 이름: @antora/site-generator-default.
|✅
|
|MPL-2.0
|사이트 매퍼
@antora/site-mapper
|사이트의 사이트맵 파일을 생성합니다. 크롤러가 읽도록 의도된 이러한 파일은 URL별로 게시된 모든 페이지의 목록을 제공합니다.
|✅
|
|MPL-2.0
|파일 게시자
@antora/file-publisher
|가상 파일 카탈로그의 게시 가능한 파일을 플레이북에 지정된 대상에 게시(즉, 작성)합니다.
이전 이름: @antora/site-publisher.
|✅
|
|MPL-2.0
|UI 로더
@antora/ui-loader
|UI 번들을 다운로드하고 캐시한 다음 해당 번들에서 파일을 추출하여 UI 카탈로그에 로드합니다. UI 파일은 Antora 문서 파이프라인 끝에서 콘텐츠 파일과 결합되어 완전한 사이트를 생성합니다.
|✅
|
|MPL-2.0
|Lunr 확장
@antora/lunr-extension
|Lunr과 통합되어 Lunr 기반 오프라인 전체 텍스트 검색을 Antora 문서 사이트에 추가하는 Antora 확장입니다.
|
|✅
|MPL-2.0
|===



== Get Help

Antora는 문서 작성 및 게시를 지원하도록 설계되었습니다. 그러나 여러분의 피드백 없이는 이 목표를 완전히 실현할 수 없습니다! 아래에 제공된 커뮤니케이션 채널을 사용하여 문제를 보고하고, 질문하고, 아이디어를 공유하거나 이 프로젝트의 다른 측면에 대해 논의할 것을 권장합니다.
채팅
프로젝트 채팅은 Antora의 모든 사용자를 위한 선호되는 커뮤니케이션 수단입니다. 이 정책은 프로젝트의 지속 가능성을 유지하는 데 도움이 됩니다.
프로젝트 관리자 및 커뮤니티 구성원과 실시간으로 도움을 요청하거나 피드백을 공유하거나 아이디어를 교환하려면 프로젝트 채팅에 참여하세요.
Chat (Zulip)
채팅은 주제별로 스트림으로 분할됩니다. 이 분할은 대화를 체계적으로 유지하고 팔로우할 주제를 필터링할 수 있게 해줍니다. 처음 참여할 때는 주제가 어디에서 논의되고 있는지 숙지하는 데 몇 분 정도 시간을 할애하세요.
Antora 사용과 관련하여 도움을 요청하기 위해 관리자에게 직접 메시지를 보내지 마세요. 프로젝트 관리자는 1대1 지원을 제공하지 않습니다. 모든 지원은 대부분 #users 스트림에서 공개적으로 이루어져야 합니다. 직접 메시지는 개인적인 문제에만 사용되어야 합니다.
새 주제를 시작하기 전에 필터 또는 검색 기능을 사용하여 새 주제를 시작하기 전에 기존 주제를 찾아보세요. 이미 진행된 토론 내에서 찾고 있는 정보를 찾을 수 있습니다. 게시물의 주제와 일치하는 진행 중인(즉, 해결되지 않은) 토론을 찾으면 해당 토론에 자유롭게 참여하세요.
질문에 답변하는 기존 주제를 찾을 수 없거나 이미 해결된 것으로 표시된 경우 새 주제를 시작할 수 있습니다. 새 주제를 만들기 전에 적절한 스트림을 선택하는 것이 좋습니다. 어디에 게시할지 잘 모르겠다면 #users 스트림에서 새 주제를 만들면 필요한 경우 중재자가 재분류합니다.
스트림을 선택한 후 "New Topic"을 클릭하고 제목을 입력한 다음 게시물을 작성하고 "Send"를 클릭합니다. "New Topic"을 클릭한 후 스트림을 선택할 수도 있습니다.
프로젝트 채팅의 토론은 보관되고 공개됩니다. 로그가 무기한 저장된다는 보장은 없지만 허용되는 한 계속 보관할 계획입니다.
프로젝트 채팅은 1대1 지원이 아닙니다. 공개 공간에 있습니다. 사용자는 자발적으로 프로젝트 채팅에 참여합니다. 그들의 시간과 관심사를 존중해 주세요.
메시지를 작성할 때 a) 주제가 절대적으로 해당 사람의 주의를 필요로 하거나 b) 해당 사람이 이미 주제에 답변했고 귀하와 상호 작용하는 경우가 아니면 누군가를 @ 멘션하지 마세요. @ 멘션을 사용하여 질문에 주의를 끄는 것은 그 사람에 대한 예의가 아니며 참여하는 다른 사람들에게 공정하지 않습니다. 전체 커뮤니티에 메시지를 자유롭게 게시할 수 있습니다(@ 멘션 없음). 누군가 응답할 내용이 있다면 시간이 있을 때 그렇게 할 것입니다. @_ 접두사를 사용하여 알리지 않고도 누군가를 참조할 수 있으며, 이는 허용되는 행위로 간주됩니다.
이슈
이슈 트래커는 소프트웨어 변경 사항을 추적하고 릴리스를 계획하는 데 사용됩니다. 이슈 트래커는 지원 포털이 아닙니다. 대신 이슈 트래커는 문제 보고(검증 가능한 버그, 회귀 및 보안 취약점)와 새로운 기능 요청을 위해 예약되어 있습니다. 소프트웨어 변경이 필요하다고 확신할 수 없다면 채팅에 게시하세요.
Issue tracker (GitLab)
소프트웨어에 대한 중요한 변경 사항이나 프로젝트에 대한 결정은 이슈 트래커에 기록되어야 합니다.
트위터
Antora 경험을 공유하거나 홍보하는 데 도움을 주고 싶다면 소셜 미디어에 게시할 것을 권장합니다. 트위터에서 Antora에 대해 이야기할 때 프로젝트의 공식 계정을 언급할 수 있습니다:
@antoraproject - 트위터의 공식 Antora 계정.
또한 #antora 해시태그를 사용하여 프로젝트를 홍보하거나 프로젝트에 대해 이야기하는 다른 사람들을 발견할 수 있습니다.
코드 및 콘텐츠 기여
관리자가 프로젝트를 개선하는 데 도움을 주는 데 관심이 있다면 Antora 기여 가이드라인을 확인하세요.



== Security Bulletins

소프트웨어 결함 및 보안 취약점에 대한 신속한 대응은 Antora의 최우선 과제입니다. 위협이 일상적인 현실이지만 거의 100%의 테스트 커버리지로 품질 보증을 진지하게 받아들이고 있습니다. 이 페이지에서는 누락된 항목과 해결 방법을 문서화합니다.
보안 공지 CVE-2020-28469
ID
CVE-2020-28469
게시일
2021년 6월 7일
요약
이 프로젝트가 vinyl-fs(glob-stream을 통해)의 전이 종속성으로 가져오는 glob-parent 버전에 알려진 보안 취약점이 있습니다. 우리는 이 문제를 인식하고 있으며 가능한 한 빨리 종속성 체인에서 제거할 계획입니다.
영향을 받는 버전
Antora의 모든 버전.
해결 계획
vinyl-fs의 관리자가 문제 해결을 거부하므로 Antora에서 vinyl-fs를 완전히 제거할 예정입니다. 그러나 이는 사소한 변경이 아니므로 해결하는 데 시간이 걸릴 것입니다. 3.x 릴리스 라인의 이후 릴리스에서 완전히 제거할 계획입니다.
그 동안 package.json 파일에 다음 재정의를 추가하여 종속성 체인에서 이 종속성을 명시적으로 업그레이드하여 npm에서 내보내는 경고를 제거할 수 있습니다.
[source,json]
"overrides": {
"vinyl-fs": {
"glob-stream": "~7.0"
}
}
이 해결책은 이 사이트를 빌드할 때 사용됩니다. npm 재정의에 대한 자세한 내용은 package.json 문서에서 확인할 수 있습니다. 안타깝게도 npm 재정의는 라이브러리 자체가 아닌 라이브러리의 소비자만 사용할 수 있습니다. 따라서 이는 Antora 자체가 제정할 수 있는 해결책이 아닙니다.
사용되지 않는 inflight 패키지에 대한 경고가 표시될 수도 있습니다. 이 패키지는 glob의 종속성이며, glob은 glob-stream에서 사용됩니다. 사용 중단 메시지를 숨기려면 재정의 항목을 추가하여 git에서 직접 가져올 수 있습니다. 이 패키지는 Antora에서 사용될 때 안전하지 않은 것으로 간주되지 않습니다.
[source,json]
"overrides": {
"glob": {
"inflight": "https://github.com/isaacs/inflight-DEPRECATED-DO-NOT-USE#v1.0.6"
},
"vinyl-fs": {
"glob-stream": "~7.0"
}
}
이 재정의는 inflight의 사용이 인정되고 허용됨을 문서화합니다.
평가
다행히도 Antora는 제어된 방식으로 glob-parent를 사용하므로 이 취약점은 Antora에 대한 공격 벡터가 아닙니다. 그러나 알림이 성가시고 이를 보는 사용자에 대해 보안 프로토콜을 트리거할 수 있음을 인식하고 있습니다.
참조

CVE-2020-28469
GHSA-ww39-953v-wcq6



== Project Governance

== Project Governance - Release Schedule

Antora 핵심 구성 요소의 각 주요 릴리스 라인은 일반적으로 일반 가용성(GA)에 들어간 후 1년 동안 지원됩니다.
[cols="1,1,1,1,1,1"]
|===
|릴리스 라인 |최신 릴리스 |상태 |GA |유지보수 |EOL
|Antora 3
|3.1.7
|Active
|2021/12/25
|TBD
|TBD
|Antora 2
|2.3.4
|EOL
|2018/12/25
|2022/01/25
|2022/02/25
|===
일반 가용성(GA)
Antora 2.x와 같은 릴리스 라인은 소프트웨어의 초기 최종 주요 버전(예: Antora 2.0.0)이 릴리스되고 다운로드할 수 있는 날짜에 일반 가용성에 들어갑니다.
활성
릴리스 라인이 적극적으로 개선되고 지원되고 있습니다.
유지보수
릴리스 라인이 유지보수 기간에 들어가면 가장 최근의 마이너 버전만 중요한 보안 패치 릴리스를 받게 됩니다. 릴리스 라인은 다음 주요 릴리스 라인이 GA로 전환된 후 30일 후에 이 단계를 시작합니다.
수명 종료(EOL)
릴리스 라인이 더 이상 지원이나 릴리스를 받지 않는 날짜입니다.
버전 정책
Antora는 시맨틱 버전 규칙을 따릅니다. 각 Antora 구성 요소 릴리스는 major.minor.patch로 버전이 지정됩니다.
메이저
기능에 상당한 변경 사항이 있거나 새로운 기능이 이전 버전과의 호환성을 깨뜨릴 때 주요 릴리스가 발생합니다. 동일한 주요 릴리스 라인 내의 릴리스는 API 호환성을 유지합니다.
마이너
마이너 릴리스는 새로운 기능, 기존 기능의 개선 사항 및 이전 버전과의 호환성을 유지하는 수정 사항을 추가합니다.
패치
패치 릴리스는 버그를 수정하고 이전 버전과의 호환성을 유지합니다. 주요 릴리스 라인의 최신 마이너 릴리스만 패치를 받게 됩니다. 패치 릴리스는 수정 사항의 긴급성에 따라 필요에 따라 이루어집니다.
프리릴리스
주요 및 마이너 릴리스에는 프리릴리스 버전(major.minor.patch-alpha.n | -beta.n | -rc.n)이 포함될 수 있습니다. 프리릴리스 버전은 npm 클라이언트가 안정 버전보다 프리릴리스를 선호하지 않도록 next로 태그가 지정됩니다. 릴리스 후보(rc)가 철저히 테스트되면 안정 릴리스가 게시됩니다.
로드맵
현재 예정된 개발 작업 목록은 Antora의 마일스톤과 이슈 트래커를 참조하세요. 마일스톤은 정보 제공 목적으로만 사용됩니다. 제안된 기능, 범위 및 릴리스 시간표는 추정치일 뿐 확고한 약속이 아닙니다.



== Project Governance - Copyright and License

저작권
Copyright © 2017-현재 OpenDevise Inc. 및 Antora에 기여한 개인.

라이선스
Antora의 사용은 Mozilla Public License Version 2.0(MPL-2.0)의 조항에 따라 허가됩니다.

상표
AsciiDoc® 및 AsciiDoc Language™는 Eclipse Foundation, Inc.의 상표입니다.



== Project Governance - Land Acknowledgement

우리의 성명
Antora 프로젝트가 주로 Cheyenne, Očhéthi Šakówiŋ 및 Ute 족의 전통적이고 양도되지 않은 영토(Fort Laramie 조약: 1851년 및 1868년, 양도 426)를 점유하는 토지에서 개발되고 있음을 인정하고 싶습니다. 이들은 여러 세대에 걸쳐 토지와 물을 관리해 왔습니다.
이 토지 인정을 통해 우리는 원주민의 주권, 역사 및 경험을 확인합니다. 이 인정이 과거와 현재 원주민의 가르침을 경청하고 존중하며, 토지와 물을 보호하는 데 도움으로써 그들의 이 토지 및 물과의 신성한 관계를 지지하겠다는 우리의 약속을 표현하기를 바랍니다.
토지 인정이란 무엇인가요?
토지 인정은 현재와 역사적으로 우리가 거주하는 토지에서 일하고 살았던 원주민들에게 감사와 감사를 표하는 공식 성명입니다. 이러한 성명은 원주민 문화, 그들의 조상의 고향, 토지의 신성함을 존중하는 동시에 식민주의의 복잡하고 지속적인 역사와 우리가 사는 곳에 대한 특권을 인정합니다.
미국과 캐나다의 원주민 토지의 역사와 그 역사를 인정하는 것이 왜 중요한지에 대해 Native Land Digital에서 자세히 알아볼 수 있습니다.